{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-01-25T01:08:09.511683+00:00",
  "repo": "cbor-wg/cbor-dns",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOIM0M7M5t8SLz",
      "title": "Represent names as their compontents",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/2",
      "state": "CLOSED",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "During the [mailing list discussions of `-03`](https://mailarchive.ietf.org/arch/msg/cbor/JOHCCBOzC46PrSq-61MMev--mpU/), @chrysn proposed to represent names as their components instead of `tstr`, similar to how it is done in [draft-ietf-core-href](https://datatracker.ietf.org/doc/draft-ietf-core-href/):\r\n\r\n>     host-name   = (*text) ; lowercase, NFC labels\r\n>\r\n>   That is, rather than expressing some.hostname.example.com as `\"some.hostname.example.com\"`, it goes for `\"some\",  \"hostname\", \"example\", \"com\"`\r\n\r\nThere are several advantages to that representation:\r\n\r\n- If not put in their own array, but just verbatim into the arrays already used in the spec, we safe the list specifier, i.e, one byte at least\r\n- Dots (\".\") can be expressed as part of a name component without extra encoding (I don't think that is legal in DNS domain names; @chrysn says they can occur in DNS-SD service names though)\r\n- It would be more in line with how DNS encodes names (delimiter identifies the length of the following name component)\r\n   - This would have the additional advantage that we could use a DNS-like name compression (i.e. an int to refer to an offset in the CBOR binary). The only thing we need to do to make names also encodeable as `uint`s is to swap ttl in RR. This way, the first int in a CBOR array that potentially could contain names always would be identifiable as the name (questions always contain a name, so the first `uint` would just be the name).\r\n\r\nThe only disadvantage we found so far is that there is no straightforward way to use the value or inverted references for names with this... But maybe, if we have DNS-like name compression, this wouldn't be needed anyways.",
      "createdAt": "2023-08-10T06:43:08Z",
      "updatedAt": "2024-11-07T13:25:14Z",
      "closedAt": "2024-11-07T13:25:14Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "MEMBER",
          "body": "> I don't think that is legal in DNS domain names\n\nAIU it is perfectly legal in DNS, it's just that URIs can not (due to their interesting escaping rules) express that dot, not even with percent encoding (maybe punycode though?) -- so it works only where DNS names are never put into a URI.\n",
          "createdAt": "2023-08-10T07:09:28Z",
          "updatedAt": "2023-08-10T07:09:28Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is legal, but strongly discouraged: https://datatracker.ietf.org/doc/html/rfc1035#section-2.3.1",
          "createdAt": "2023-08-10T13:09:20Z",
          "updatedAt": "2023-08-10T13:09:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in the two most recent versions",
          "createdAt": "2024-11-07T13:25:14Z",
          "updatedAt": "2024-11-07T13:25:14Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOIM0M7M5t8Uu5",
      "title": "Pre-populated packing tables",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/3",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@chrysn wrote on the [CBOR mailing list](https://mailarchive.ietf.org/arch/msg/cbor/JOHCCBOzC46PrSq-61MMev--mpU/):\r\n\r\n> Are the packing tables pre-populated with any values? (\"_coap._udp.\"\r\n> and \".com\" would come to mind). If so, is the 1 in `;packed=1`\r\n> intended to serve as an extension point that dispatches the values of\r\n> the table?\r\n\r\nI really like this idea! However, some details need to be ironed out as this could go several (somewhat disjunct) routes:\r\n1. Are these extension points pre-defined tables?\r\n2. Do we use CRIs/URIs to identify and find tables (see e.g. https://datatracker.ietf.org/doc/draft-amsuess-cbor-packed-by-reference/)?\r\n3. Should the extension point be used in a similar manner as SCHC rule IDs, i.e., identify some pre-shared tables?\r\n\r\n1. and 3. don't necessarily contradict each other, as we could reserve number ranges for either pre-defined tables or pre-shared tables? 2. could also be integrated, e.g. with a dedicated number.",
      "createdAt": "2023-08-10T06:51:14Z",
      "updatedAt": "2023-08-10T06:51:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOIM0M7M6i7Am6",
      "title": "hex/EDN examples",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/8",
      "state": "OPEN",
      "author": "chrysn",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From today's interim:\r\n\r\n> @or13: Would be nice to see hex / EDN examples in this section: https://www.ietf.org/archive/id/draft-lenders-dns-cbor-10.html#name-dns-representation-in-cbor-",
      "createdAt": "2024-12-11T16:05:01Z",
      "updatedAt": "2025-10-16T05:33:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Examples are, due to previous decisions made, in [Appendix A](https://www.ietf.org/archive/id/draft-lenders-dns-cbor-14.html#name-examples). There are EDN examples. So, would it suffice to just add hex dumps there as well?",
          "createdAt": "2025-10-15T13:19:43Z",
          "updatedAt": "2025-10-15T13:19:43Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Added binary examples in https://github.com/cbor-wg/cbor-dns/commit/39ee3f7b8b00a75e749a4afa2bd66ad2aa18e007",
          "createdAt": "2025-10-16T05:33:44Z",
          "updatedAt": "2025-10-16T05:33:44Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOIM0M7M6y_aZu",
      "title": "`AAAA` record compression",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/9",
      "state": "OPEN",
      "author": "JeremyRand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello; I'm working with Tor Project on compact DNS zone files for usage in onion service descriptors. This spec caught our attention as potentially relevant. I have a question about how IPv6 addresses are represented.\n\nThe spec mentions:\n\n> Especially IPv6 addresses, e.g., in AAAA resource records can benefit from straight referencing to compress common address prefixes.\n\nHowever, this doesn't (unless I'm misreading) cover compression of individual IPv6 addresses. The example address used in the draft, `2001:db8::1`, uses 16 bytes, but it quite clearly has less entropy than this, as evidenced by the fact that its ASCII notation (certainly not optimal) is only 11 bytes long.\n\nWould there be interest in compression of IPv6 addresses? I did some experiments with real-world zone files, and found that the following algorithm worked pretty well:\n\n1. Convert IPv6 address to ASCII notation.\n2. Remove any redundant colons.\n3. Parse as base17.\n\nMaybe there's a better approach, I'm not sure. Curious what your thoughts are on whether IPv6 address compression is a reasonable thing to include within the scope of CBOR-DNS.\n\nBest regards.",
      "createdAt": "2025-04-17T16:34:16Z",
      "updatedAt": "2025-07-07T20:29:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting!\n\nThe assumption here was that \"hole\"-ey IPv6 addresses (with runs of zeros) mostly occur in manually constructed examples and that real-world IPv6 addresses are mostly filled with entropy.\n\nIs there a way you can provide some example data sets for us to look at?\n\nCBOR-Packed has a few tricks up its sleeve that we might want to use here, but then it does not focus on compression of the content of individual (atomic) data items.",
          "createdAt": "2025-04-17T16:43:23Z",
          "updatedAt": "2025-04-17T16:43:23Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Hi!\n\n> Is there a way you can provide some example data sets for us to look at?\n\nI *think* I can provide the dataset that I was given, but let me double-check to make sure it's OK for me to share it.",
          "createdAt": "2025-04-17T16:50:22Z",
          "updatedAt": "2025-04-17T16:50:22Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "That would be really interesting! I did some cursory analysis back when I was thinking about that, but came to the same conclusion @cabo was mentioning: runs of zeros do not appear as often so that a string conversion\u2014which more than doubles the number of required bytes compared to the binary representation before we even can think about removing stuff\u2014would bring any benefit.",
          "createdAt": "2025-04-22T10:14:17Z",
          "updatedAt": "2025-04-22T10:14:17Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "@JeremyRand: We will have the next CBOR meeting on Wednesday this week, so having some real data that we could chew on and present would help us forward.\n",
          "createdAt": "2025-05-11T16:54:35Z",
          "updatedAt": "2025-05-11T16:54:35Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "I've just emailed you the zone files I was given (please let me know if they failed to arrive). Apologies for the delay.\n\nBased on this dataset, my findings were that the base17 approach I described above yielded a smaller size than the DNS wire format in all but two of the `AAAA` records in the dataset. Which would suggest that a potentially valid approach would be to define the format as \"If the `AAAA` data found in the CBOR is 16 bytes, treat it as DNS wire format, if it's less than 16 bytes, treat it as base17.\"\n\n(The savings aren't exactly massive, but they are significant for space-constrained systems like what we're working with.)",
          "createdAt": "2025-05-12T00:00:18Z",
          "updatedAt": "2025-05-12T00:00:18Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you.  The samples I find are highly skewed towards interface identifiers where only the lowest byte is non-zero; only some 3 % of the AAAA records have more bytes in use.  I don't think that is very typical, but it would be worth looking at this for a larger sample set.\n\nBesides the 97 % with a :: run of 7 bytes, there also may be some advantage from eliding leading zero nibbles in the hexlets -- normally the colon overhead would eat this advantage; but in the sample, 40 % of the hexlets don't have full quads (one would expect maybe 1 out of 16), and the average number of hex digits per quad is 2.92, with 30 % single-digit, so the colon conversion does help -- I'd consider this rather atypical as well.\n\nSo identifying a single run of zero bytes might be a near optimal solution that makes good use of the quirks of your sample data set.\nThis can be given as the start position of the run (0..15, and maybe 16 for no such run), and the length of the run can be derived as 16 minus the number of bytes remaining after removing the run.\nIn your sample, you would save almost 7 out of 16 bytes, minus paying a byte or so for the start position; a whopping 36 %.\n",
          "createdAt": "2025-05-12T04:20:09Z",
          "updatedAt": "2025-05-12T04:20:09Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Thanks for the analysis @cabo!\n\nOf the `AAAA` records in my dataset that exhibit the quirks you noted (I am not sure how typical that is, would indeed be useful to get a larger / more diverse sample), the base17 approach I described yields a compressed size ranging from 7 to 10 bytes, with a mean compressed size of 8.41 bytes, which would be a mean of 47.4% savings for such `AAAA` records.\n\nI'm not purporting that the base17 approach is optimal, but so far I haven't managed to find anything that compresses better for this data.",
          "createdAt": "2025-05-14T06:05:48Z",
          "updatedAt": "2025-05-14T06:05:48Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Starting end of the week I will have some time to run this algorithm over my datasets. \n\n> 2\\. Remove any redundant colons.\n\nJust one question: What exactly do you mean by that? For instance, will `2001:db8::1` become `2001db8::1`, `2001db8:1`, `2001db81`, or something else?",
          "createdAt": "2025-05-14T07:59:07Z",
          "updatedAt": "2025-05-14T07:59:07Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "> > 2. Remove any redundant colons.\n> \n> Just one question: What exactly do you mean by that? For instance, will `2001:db8::1` become `2001db8::1`, `2001db8:1`, `2001db81`, or something else?\n\n@miri64 Remove any colon that immediately follows 4 hex digits (since any such colon is just there for formatting convenience and can be inferred unambiguously). So, for example, `1234::5678:9abc:deff:0:0` becomes `1234:56789abcdeff0:0`. (I didn't carefully think about whether a colon at the start of the string could also be inferred unambiguously, e.g. `::1` becoming `:1`, but that might be workable.)",
          "createdAt": "2025-05-14T08:33:11Z",
          "updatedAt": "2025-05-14T08:33:11Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting! With this transformation, and assuming after conversion the base17-string is stored as a (big) integer we only loose 2 bytes in the worst case (i.e., non of the quad-bytes within the hex representation start with a `0` nibble):\n\n![Results of using AAAA record compression for our datasets](https://github.com/user-attachments/assets/a46aed23-9031-47e6-a200-1f7a0f01c7bb)\n\nI used the IPv6 data from two datasets (both provided as PCAPS), namely the AAAA records and the IPv6hint from SVCB/HTTPS records:\n\n- **IoT:** traces from 3 publically available studies that were conducted in Testbeds with consumer-grade off-the-shelf IoT devices (see e.g. https://github.com/anr-bmbf-pivot/Artifacts-CoNEXT23-DoC/tree/main/03-dns-empirical/collect#scan_iot_datapy for details)\n- **Public:** Queried the names from the [Tranco list](https://tranco-list.eu/) from 3 public resolvers (1.1.1.1, 8.8.8.8, 9.9.9.9; there was no IPv6 available at the site we constructed this list from).\n\nI used this function to convert the IPv6 addresses (provided as full hex strings) to a CBOR integer:\n\n```py\ndef to_base17(addr):\n    addr = ipaddress.IPv6Address(bytes.fromhex(addr)).compressed\n    base17_str = re.sub(\"([0-9a-f]{4}):\", r\"\\1\", addr).replace(\":\", \"a\")\n    return cbor2.dumps(int(base17_str, base=17))\n```\n\nThe reference for the comparsion was the address as CBOR binary string (i.e. to length 17). So byte savings _b_ is\n\n$b = 17 - \\mathbf{length}(\\mathtt{to\\\\_base17}(\\mathtt{addr})))$\n\nand gain _g_ is\n\n$g = \\frac{b}{17}$\n\nThe idea case of this compression is in terms of DNS byte savings of 8 at the moment, when an address just about compresses to an 8-byte integer (9 byte in CBOR). The maximum in our dataset is a byte saving of 14 bytes for the address `::1`, i.e., the loopback address which should not really show up in DNS data. But it does apparently at some public resolver. It converts to the 2-byte integer 3061 (3 byte in CBOR). All other addresses compress to big integers.\n\nAs @cabo already confirmed: Your dataset somewhat skews to the ideal case with byte savings 8:\n\n![Results of using AAAA record compression for Jeremy's dataset](https://github.com/user-attachments/assets/a1a831b9-2e98-4de2-9127-f79dbce35e06)\n\nBut overall I'd say this compression is something that we should think about, but maybe only optionally. This might be even something that could be used generally, especially if the kink with the conversion of `::1` could be ironed out (I think it is as easy as adding the step \"If string starts with colon, remove it\" to the \"remove redundant colons\" step, but did not test if that is easily reversable).",
          "createdAt": "2025-05-19T12:44:14Z",
          "updatedAt": "2025-05-19T12:45:07Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> But overall I'd say this compression is something that we should think about, but maybe only optionally.\n\nSee https://github.com/cbor-wg/cbor-dns/pull/10 for an easy, unintrusive start.",
          "createdAt": "2025-05-19T12:57:08Z",
          "updatedAt": "2025-05-19T12:57:08Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Carsten asked me to provide some additional evaluation. Find them below with both for our datasets.\n\n![Image](https://github.com/user-attachments/assets/9bcaf62a-0828-428f-8267-8cd344957ef7)\n\n- **base17** is the same result as [above](https://github.com/cbor-wg/cbor-dns/issues/9#issuecomment-2890876490),\n- **base17 Improved** additionally removes the colon before the last hex-quad if it is complete and strips the front-colon if the string starts with one\n- **skip max-0 run** finds the longest run of 0-bytes that is longer than 2 bytes within an address, removes it and prepends the offset of that zero run to the address.\n- **skip max-0 run Improved** slightly improves on that by also removing the well-known ff:fe marker at bytes 11..12 that hints that the IID of the address was generated from a MAC48 address, if it is available and toggling the respective bit in the most significant byte of the IID. Since only 266/271889 addresses in our datasets contain this marker, the advantage is not very pronounced.\n\nApart from it perfoming slightly better, we think keeping it in the binary domain with **skip max-0 run** makes more sense for the constrained use case as it can be done without any dependencies, such as IPv6 text representation, base17, or bigint requirements.",
          "createdAt": "2025-05-20T12:03:38Z",
          "updatedAt": "2025-05-20T12:03:38Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Thanks for the analysis @miri64! Yeah this seems reasonable. Given that MAC48 is a privacy leak, and we're working with privacy-focused projects, my preference would be to not do anything in the compression that incentivizes usage of MAC48; it sounds like this matches your preference.",
          "createdAt": "2025-05-25T08:27:24Z",
          "updatedAt": "2025-05-25T08:27:24Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "#10 is now merged and will be part of -14, which allows for extensions of the IP address representation.",
          "createdAt": "2025-07-07T20:29:29Z",
          "updatedAt": "2025-07-07T20:29:51Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOIM0M7M7QId38",
      "title": "Zone files",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/12",
      "state": "OPEN",
      "author": "JeremyRand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi again. We're interested in using this spec for encoding zone files as CBOR. I am aware of C-DNS; the use cases we're working with involve heavily constrained storage and very small zone files (for some environments, we're working with a hard limit of 520 bytes per zone file). This is not far off from the network constraints that your draft is aimed to handle, and my understanding of C-DNS and its overhead is that it is not suitable for such small pieces of data (if you disagree with this assessment, please let me know; it's possible that I'm misunderstanding how C-DNS works).\n\nAs far as I can tell, it should not be very difficult to adapt your spec to handle zone files. I would expect the encoding to look very similar to an array of resource records per Sec 3.2. The main difference I see is in the eliding of resource record entries:\n\n* If the name is elided, it can't be inferred from a question since there is no question for a zone file. I would suggest inferring it from the previous resource record, as is done with standard zone files.\n* If the record type or record class is elided, same issue as above; I would suggest inferring `AAAA` and `IN` as is specified in Sec. 3.3.\n* Eliding the TTL seems useful, as is done with standard zone files; an elided TTL would be inferred to match a previously specified default.\n* I'm not certain of the optimal precedence for eliding things, but in our use cases, the TTL and class would generally be elided a lot more often than the name or the record type. Thoughts?\n* Specifying the default TTL would have to be done... somehow? I'm not sure of the best way to mimic a `$TTL` directive in CBOR. Thoughts?\n\nDo the elision thoughts above make sense? Do you see other tweaks that would be needed to support zone files? Curious what your thoughts are here.",
      "createdAt": "2025-10-07T15:03:29Z",
      "updatedAt": "2026-01-17T19:54:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "> I'm not certain of the optimal precedence for eliding things, but in our use cases, the TTL and class would generally be elided a lot more often than the name or the record type. Thoughts?\n\nPondering this a bit more, the name should always be unambiguous since it's a string, so no precedence rules are necessary for that. Of the other three entries, in our use cases, I'd expect the class to be elided most often, followed by the TTL, with the record type being elided least often.",
          "createdAt": "2025-10-07T15:14:10Z",
          "updatedAt": "2025-10-07T15:14:10Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Not 100% clear, if you mean to provide an alternative route for zone files or want to also change the format for the sent data. In my response, I assume the latter.\n  \n> * If the name is elided, it can't be inferred from a question since there is no question for a zone file. I would suggest inferring it from the previous resource record, as is done with standard zone files.\n\nNot sure this is desirable for sent responses.\n\n> * If the record type or record class is elided, same issue as above; I would suggest inferring `AAAA` and `IN` as is specified in Sec. 3.3.\n\nNeed to think about this some more. Having the elision based on the question makes any RR response smaller (which in general is desirable) while focusing on `AAAA` and `IN` only only provides this advantage only for those records (which by their nature are already quite small and might get also other advantages, see #9).\n\n> * Eliding the TTL seems useful, as is done with standard zone files; an elided TTL would be inferred to match a previously specified default.\n> * I'm not certain of the optimal precedence for eliding things, but in our use cases, the TTL and class would generally be elided a lot more often than the name or the record type. Thoughts?\n> * Specifying the default TTL would have to be done... somehow? I'm not sure of the best way to mimic a $TTL directive in CBOR. Thoughts?\n> [...]\n> Pondering this a bit more, the name should always be unambiguous since it's a string, so no precedence rules are necessary for that. Of the other three entries, in our use cases, I'd expect the class to be elided most often, followed by the TTL, with the record type being elided least often.\n\nThat only seems sensible for zone files to me. Have you looked into storing the zone files using packed in general? This would basically allow for a compression of the TTL and define a \u201edefault\u201c in the packing table.\n\nIn any case, there was some desire to integrate zone files into the format in the past by @TheEnbyperor. Are you both, @JeremyRand and @TheEnbyperor, present in Montreal? Maybe we can discuss this there.",
          "createdAt": "2025-10-08T15:17:26Z",
          "updatedAt": "2025-10-08T15:17:48Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "> Not 100% clear, if you mean to provide an alternative route for zone files or want to also change the format for the sent data. In my response, I assume the latter.\n\nSorry for the confusion, I meant the former, i.e. a different set of elision rules depending on whether the resource records are in the context of a zone file or a sent response.\n\n> In any case, there was some desire to integrate zone files into the format in the past by [@TheEnbyperor](https://github.com/TheEnbyperor). Are you both, [@JeremyRand](https://github.com/JeremyRand) and [@TheEnbyperor](https://github.com/TheEnbyperor), present in Montreal? Maybe we can discuss this there.\n\n@TheEnbyperor and I are colleagues. I'm not able to be in Montreal unfortunately (not sure about Q). If you might be at 39C3 (and if waiting until December is suitable), I'd be happy to meet up there (I think Q will be there too).",
          "createdAt": "2025-10-08T20:09:39Z",
          "updatedAt": "2025-10-08T20:09:39Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> If you might be at 39C3 (and if waiting until December is suitable), I'd be happy to meet up there (I think Q will be there too).\n\nI'm planning to, but as always one can only really say \u201dyes, I will be there\u201c if you have the ticket in your hand :grin:. Then let's try to meet up there.",
          "createdAt": "2025-10-09T05:42:08Z",
          "updatedAt": "2025-10-09T05:42:08Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Hi @JeremyRand, this ticket was mentioned in today's DNS+cbor-packed meeting. While for today zone files questions compression were deferred as there is no format for them defined yet, I have to clarify some points and tell about other work in IETF CBOR WG existing. The main thing here is that there is another CBOR packing proposal exists for a year, not yet in ietf-draft form, but it's main driver to change from simple scheme to something more (in Feb-Mar) was exactly DNS-CBOR needs non-optimal fit in cbor-packed.\n\nThat proposal is called CBAR/CBAPT (and more general CBOR-TPL as language with goals like XSLT, see [non-packing example](https://mailarchive.ietf.org/arch/msg/cbor/q9Mkm89rJi-Q8IHtbnnKowkDHoo/) of it), you may want to look at it - while in early [draft-of-draft/brainstorming mindstream](https://github.com/nuclight/musctp/blob/main/cbar.txt), it potentially allows better ratio than cbor-packed. Some references:\n* https://mailarchive.ietf.org/arch/msg/cbor/GxC5yusExISSUS9tKtrRyeYCTy4/ first sketch\n* [22 Jan 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-02/materials/slides-interim-2025-cbor-02-sessa-vadims-cbar-slides-00.pdf) presentation\n* [2 Apr 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-06/materials/slides-interim-2025-cbor-06-sessa-vadims-cbarcbapt-slides-00) presentation\n* [30 Apr 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-08/materials/slides-interim-2025-cbor-08-sessa-vadims-slides-on-packed-00) presentation\n* [14 May 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-09/materials/slides-interim-2025-cbor-09-sessa-vadims-slides-on-dnspacked-00) DNS-packed presentation\n\nHere, I need to explain different focus of cbor-packed (and consequently DNS-CBOR in it's current form) and CBAPT. While both can both serve constrained implementations and general ones, they have different focus. First, a \"constrained implementation\" is usually from IoT world with parameters needed, in order:\n1) very limited memory, 10 Kb of RAM was a luxury 10 years ago, typically you have, say, 1 Kb\n2) very limited ROM, which means implementation must be not so big in terms of lines of C code\n3) only then you have small packet sizes of data.\n\nDue to this, cbor-packed (and CBAR subset of CBAPT) focuses on the decoding side on constrained device:\na) data must be accessible _in-place_ **without unpacking via intermediate memory buffers**\nb) it must be relatively simple to implement\n\nThis sacrifices compression effectiveness - cbor-packed (and DNS-CBOR after simple values) consumes more space than it could. And DNS-CBOR name compression is another algorithm, not of generic cbor-packed - we try to marry them together right now to achieve better ratio.\n\nThis means, for you working at Tor which is supposed to run on unconstrained implementations - i.e. no restrictions 1 and 2, no \"MUST\" for (a) and (b) also just wish, only 3 (size) matters but matters very much - current cbor-packed may be not the best fit, so better to look at alternatives, especially when it comes to design of new part of protocol (zone files). Note that CBAPT is more flexible and also comes from censorship-circumventing background (I need it for my muSCTP protocol and apps based on it), it allows for different combinations, e.g. new subformats or two-phase compression - first eliminate redundancy in message, then do `gzip` on it, to not pollute `deflate`'s limited window.\n\nOne of other things I want to add CBOR is tag for tables, which are \"like SQL\" and supposed to be generalization of features of [cbor-records](https://github.com/kriszyp/cbor-records) (you can [see size comparisons](https://gist.github.com/kriszyp/b623b85d2dc25ac9e3b07d8f39df9307) from author), cbor-packed's defaults for maps and [map-like data e.g. duplicated map keys](https://www.ietf.org/archive/id/draft-bormann-cbor-cddl-map-like-data-01.html). See the last part of https://mailarchive.ietf.org/arch/msg/cbor/HSGTVAsoq7xV7rkuG0NkLf1RYOM/ and https://mailarchive.ietf.org/arch/msg/cbor/qGknHigujyj4LTxwJpMfGVXUSUY/\n\nI am talking about this because your suggestion clearly mimics BIND's text zone file format when repeated parts are omitted, but the same approach seems to be generalizable and useful in other table-like data areas (column-oriented DBs are first to remember, while they are far from CBOR by itself, some techniques probably could be borrowed). So we can invent these things here and later augment DNS-CBOR with different \"backend\" for packing beyond built-in name compression, where cbor-packed is currently the only one (one can note that DNS-CBOR is not very tied to cbor-packed, it just uses it's registered tags but self-contained otherwise). For example, I did a [try for IPv6 addresses compression](https://mailarchive.ietf.org/arch/msg/cbor/LJrOjmmE8h0RQeoLZ6vPZ06ctkg/) in CBAR for cases like zero and in the middle, which cbor-packed does not handle well.",
          "createdAt": "2026-01-15T22:47:44Z",
          "updatedAt": "2026-01-15T22:47:44Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Reading about [C-DNS](https://datatracker.ietf.org/doc/html/rfc8618), yes, it is not assumed to be used on such small data. However, some of it's techniques can be utilized for small zone files, like referencing tables or IP prefixes. However, this is not much different from cbor-packed), so yet to be thought. Let's begin from a preprocessing step after which usual name compression applied (and possibly cbor-packed or CBAPT).\n\nGiven that zone file is table with just few fixed columns, we can apply column-oriented to part of it wit run-length encoding:\n* class and TTL columns are taken out from individual RRs entirely\n* zone data is prepended with `[ ? $ORIGIN, [classes], [TTLs]]`\n   - `$ORIGIN`, if present, serves to ensure this label always gets low number in _V_ table so would be referenced by one byte, just as `@` in traditional text format\n* Both `classes` and `TTLs` arrays have run-length encoding of corresponding column:\n   - uint: number itself\n   - negative integer: minus how many times previous field was repeated\n   - truncated array mean repeating last element as many times as necessary\n\nFor example, in fragment like\n```\n...   3600  IN  ...\n...   3600  IN  ...\n...   3600  IN  ...\n...   3600  IN  ...\n...     60  IN  ...\n...   3600  IN  ...\n...   3600  IN  ...\n...   3600  CH  ...\n...   3600  HS  ...\n...   3600  IN  ...\n...    600  IN  ...\n...    600  IN  ...\n```\nthese can be `[3600, -3, 60, 3600, -4, 600], [1, -6, 3, 4, 1]`.\n\nNote that RR type is problematic to such technique because it introduces ambiguity in some cases: in\n`[\"foo\", \"bar\", \"ns2\", simple(4)]`\nwhere NAME stops and DATA begins? Human can deduce from \"ns2\" that it is probably\n`foo.bar   IN NS  ns2.example.com`\nbut what to do in algorithm?..\nOf course name could be always FQDN so ending with `simple(N)` of `6(N)` reference, but that would not utilize relative names possible even in a text zone file, and will spend a byte anyway.",
          "createdAt": "2026-01-17T19:54:33Z",
          "updatedAt": "2026-01-17T19:54:33Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOIM0M7M7dtFED",
      "title": "Change nesting of 113 and TBD28259 to avoid need of tag content equivalence",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/13",
      "state": "OPEN",
      "author": "mguetschow",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Figure 17 currently reads\n\n```\n   TBD113(\n     TBD28259(\n       [\n         [\"org\", 42],\n         [\n           \"www\", \"example\", simple(5) / expands to \"org\" /,\n           [\"svc\", simple(0) / expands to \"www\", \"example\", \"org\" /],\n           simple(5),  / expands to \"org\" /\n           simple(1),  / expands to \"www\", \"example\", \"org\" /\n           simple(6),  / expands to 42 /\n           simple(3),  / expands to \"svc\", \"www\", \"example\", \"org\" /\n           simple(6)   / expands to 42 /\n         ]\n       ]\n     )\n   )\n```\n\nI think it should rather be\n\n```\n   TBD113(\n     [\n       [\"org\", 42],\n       TBD28259(\n         [\n           \"www\", \"example\", simple(5) / expands to \"org\" /,\n           [\"svc\", simple(0) / expands to \"www\", \"example\", \"org\" /],\n           simple(5),  / expands to \"org\" /\n           simple(1),  / expands to \"www\", \"example\", \"org\" /\n           simple(6),  / expands to 42 /\n           simple(3),  / expands to \"svc\", \"www\", \"example\", \"org\" /\n           simple(6)   / expands to 42 /\n         ]\n       )\n     ]\n   )\n```\n\nThis would avoid the need for defining [tag equivalence](https://www.ietf.org/archive/id/draft-ietf-cbor-packed-17.html#name-tag-equivalence) of TBD28259 (in some circumstances) with the 2-element array expected by 113, or a change to the semantics of 113.\n\nThe overall number of bytes is unchanged, but some explanatory wording is needed, especially when TBD28259 is implicitly injected by the media type (\"as enclosing the rump of the outer-most item which should be tag 113\").",
      "createdAt": "2025-12-11T14:14:35Z",
      "updatedAt": "2026-01-16T17:05:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "As discussed in today's meeting, we probably should change the definition of TBD28259 and/or register yet another tag when nesting is allowed, so that for the common case tag TBD113 is not needed at all and thus reason for this ticket's problem is eliminated. This is also justified by today's conclusion of changing the common case working from prepending _V_ table to appending it to \"normal\" -packed's table. When later another level of nesting is added (possible solution for #12 zone files which format is not yet invented), another tag can accomodate this.\n\nThat is depicted below by `TBDnc()` and `TBDnc2()`, roughly corresponding to `?packed=1` and possible `?packed=2` media types.\n\n---\nAdapted meeting's shared notes:\n\nUse case:\n    \n* constrained device is consumer of DNS _response_\n\t* DNS+cbor _requests_ do not allow use packing level 1 (only simple name compression)\n* Nice-to-have: also make responses useful for high-performance applications\n\t* zone files may be interesting for Tor, see https://github.com/cbor-wg/cbor-dns/issues/12\n\n(Note that in the constrained use case, the DNS *server* may be a high-performance application, but does have the resources to accept more complexity)\n\nMulti-pass approaches are complicated and consume more resources (in the constrained use case, the more constrained side is the consumer)\n- we want single-pass decoder on constrained side (Goal: do not require multiple passes in the consumer)\n- so constrain embedded table setup inside the region governed by implicit table setup (which, using tag 113/1113, would use prepending again) -- use case: zone files transported via RR\n\n*Appending* table entries in the implicit phase keeps the reference numbers stable during implicit table building\n\nAny nested table-building tags in the input to the implicit table building creates complexity.\nDo we need that complexity?\n\nIdea: pruning by bitmap of unused references to bring back to single-byte `simple(0..15)` from fat `6(N)` references\nAssumption: Pruning takes more space than just leaving the entry in (a sequence of unused entries might expand a reference by one byte)\n\n**Slide 4**:\n<img width=\"1250\" height=\"618\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/3f19431e-e679-4f78-80ed-85411ae99fd1\" />\nRR from example large number of labels (Amazon):\n\n         TTL (60), RRtype CNAME (5), name\n         name, TTL (60), RRtype CNAME (5), name\n         name, TTL (9), RRtype A (1), IP address\n         name, TTL (403), RRtype NS (2), name\n\n(maybe add some EDN extension for DNS+CBOR RRtypes)\n\n**Slide 3**: \"unresolved references\" is about table entries not yet known at the time they would need to be processed in a single-pass (linear) processor.\nWe want to avoid that.\n(Example: Slide 2, `simple(5)` is not yet defined at the  time that `simple(5)` is first encountered)\n\n```\npacked=0:\n    [just rump] // implies TBDnc tag\n\npacked=1: // implies TBNnc within 113\n    [ / implies use of 113 /\n        setup,\n        rump  // implies TBDnc tag, no nested 113/1113 allowed\n    ]\n\npacked=2:\nTBDnc2([  # name compression setup tag\n    [\"prepended\" /becomes simple(0)/, \"table\" /becomes simple(1)/],\n    [ / rump: Here we now we are appending, starting at simple(2) /\n    ...,\n      113([[table entries prepended to outer\n            prepend table followed by implicitly\n            added entries \u2794 build inner table], [rump]), / optional - for zones /\n    ]\n    ])\n```\n\n`packed=1` could disallow this nesting\nactually, `TBDnc` could disallow nested table setup tags\n\n(`packed=2` might allow that nesting; need to define the use case first)\n\nDiscussion in issue #12 \n\n[We need a registry for packed= values.  We use 0 and 1 now.]\n\n\u2794 Go for appending implicitly derived reference entries\n\u2794 Do not allow setup tags nested into the implicit setup, for packed=0/packed=1 (open to be defined in packed\u22652)",
          "createdAt": "2026-01-15T21:57:42Z",
          "updatedAt": "2026-01-15T21:57:42Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> As discussed in today's meeting, we probably should change the definition of TBD28259 and/or register yet another tag when nesting is allowed, so that for the common case tag TBD113 is not needed at all and thus reason for this ticket's problem is eliminated.\n\nI think there is a slight confusion here: The goal of this ticket is fixing the order of the (implicit, aka not-sent-on-the-wire) TBD28259 and TBD113 in case `packed=1`. So TBD113 is \"needed\" as an (implicit) outer table setup.\n\nBut we indeed discussed disallowing nested (_inner_, and thereby explicit) occurrences of TBD113/TBD1113 inside TBD28259.",
          "createdAt": "2026-01-16T09:31:57Z",
          "updatedAt": "2026-01-16T09:31:57Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> I think there is a slight confusion here: The goal of this ticket is fixing the order of the (implicit, aka not-sent-on-the-wire) TBD28259 and TBD113 in case `packed=1`. So TBD113 is \"needed\" as an (implicit) outer table setup.\n\nReally? I thought Figure 17 was about using combination of tags in explicit form... Implicit in `packed=1` should be different Figure, then - because implicit form can go further beyond simple \"tag stripped\" and potentially re-arrange data.\n\n> But we indeed discussed disallowing nested (_inner_, and thereby explicit) occurrences of TBD113/TBD1113 inside TBD28259.\n\nI think we discussed changing TBD28259 in a way that it (under `packed=1`) don't need TBD113/TBD1113 now (taking it's functions to itself) due to \"appending vs prepending\" issue.",
          "createdAt": "2026-01-16T17:05:06Z",
          "updatedAt": "2026-01-16T17:05:06Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOIM0M7M5XhDHB",
      "title": "Housekeeping",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/1",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-09T09:42:28Z",
      "updatedAt": "2023-08-09T15:46:09Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "6cb47d2b12a94d796511ad6f6bf4307a97af763b",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "housekeeping",
      "headRefOid": "36641398835e9837e8e5b77505dc30315414a8ba",
      "closedAt": "2023-08-09T15:46:01Z",
      "mergedAt": "2023-08-09T15:46:01Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "644f574a21471839d731eb87b596c8cb6542615d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M5dk3pl",
          "commit": {
            "abbreviatedOid": "3664139"
          },
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2023-08-09T15:45:46Z",
          "updatedAt": "2023-08-09T15:45:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOIM0M7M5co-6G",
      "title": "Create comparison table",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/4",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In https://mailarchive.ietf.org/arch/msg/cbor/KzRTl9QqtCiyMb4wYG_U542hjV0/ a comparison table was requested. This is a first draft for that.",
      "createdAt": "2023-10-12T14:20:44Z",
      "updatedAt": "2024-06-28T12:26:21Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "69b762130904ca9448679640a46f26f5d3c0781a",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "comparison-table",
      "headRefOid": "e2f6053399243ac2a99b83e7c35f727cecef427d",
      "closedAt": "2024-06-28T12:26:14Z",
      "mergedAt": "2024-06-28T12:26:14Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "b1a8e7557d6f1037094bec82f2baead42f227cd9"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I reworked the table according to an offline proposal by @cabo. Currently, I use an XML-table, since it does not seem to be possible with kramdown to have a two row header with row span, e.g., like this \r\n\r\n```markdown\r\n|----------|-----------------------------------------------|\r\n| Item     | RFC 1035 | application/dns+cbor [bytes]       |\r\n|          | format   | best    | realistic  | theoretical |\r\n|          | [bytes]  |         | worst      | worst       |\r\n|----------|---------:|--------:|-----------:|------------:|\r\n| Header   | 4        | 1       | 4          | 4           |\r\n|----------|----------|---------|------------|-------------|\r\n```\r\n\r\nIt renders somewhat correct but the table head rows are rendered incorrect:\r\n\r\n![image](https://github.com/anr-bmbf-pivot/draft-lenders-dns-cbor/assets/675644/61dd4e62-e252-459f-843c-c92547541444)\r\n\r\nbut I would interpret the kramdown doc differently\r\n\r\n> The first separator line after at least one table row is treated specially, namely as header separator line. It is used to demarcate header rows from normal table rows and/or to set column alignments. All table rows above the header separator line are considered to be header rows.\r\n\r\n(though this could be a local problem, as the Arch Linux kramdown package [wasn't updated in ages](https://archlinux.org/packages/extra/any/ruby-kramdown/), though there seems to be finally movement [in staging](https://archlinux.org/packages/extra-staging/any/ruby-kramdown/))",
          "createdAt": "2024-06-17T15:04:33Z",
          "updatedAt": "2024-06-17T15:04:33Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And yet another iteration. This time, I put the key for the CBOR format configuration into a separate table. I think this is the most readable version so far.",
          "createdAt": "2024-06-26T16:15:17Z",
          "updatedAt": "2024-06-26T16:15:17Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For reference: https://anr-bmbf-pivot.github.io/draft-lenders-dns-cbor/comparison-table/draft-lenders-dns-cbor.html#name-comparison-to-wire-format",
          "createdAt": "2024-06-26T16:16:39Z",
          "updatedAt": "2024-06-26T16:16:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOIM0M7M5v4eY-",
      "title": "Various changes from cabo for -07",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/5",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-19T08:47:45Z",
      "updatedAt": "2024-05-19T09:29:25Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "5454047df2e957cf9c47ae222c980be68d7509a8",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "cabo-07",
      "headRefOid": "964b1bc072385190075b10d0a0c4193322767479",
      "closedAt": "2024-05-19T09:29:12Z",
      "mergedAt": "2024-05-19T09:29:12Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "9fe12b3e5430cd3dfa9d8a4abbb312654960228a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M57Fe9F",
          "commit": {
            "abbreviatedOid": "964b1bc"
          },
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-19T09:29:04Z",
          "updatedAt": "2024-05-19T09:29:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOIM0M7M6BK_Fj",
      "title": "Add capability to summarize rrsets",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/6",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The capability to summarize resource records set was discussed in the past, but I stayed away from it so far, as it adds additional overhead. Well, we add overhead already, so lets add more overhead (but less that the overhead than duplicating TTL and type ;-)) to maybe still have it. This is my proposal to how to optionally provide summarized resource record sets.\r\n\r\nMaybe the CDDL can be streamlined, but at the moment, I don't see how.",
      "createdAt": "2024-11-07T11:05:10Z",
      "updatedAt": "2025-07-07T20:08:58Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "8e7957afb85235f33056f94db03e9eae655760a1",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "rrsets",
      "headRefOid": "5e8db6e1f7d4ec269f1dc26f758ae39a79701afc",
      "closedAt": "2025-07-07T20:08:51Z",
      "mergedAt": "2025-07-07T20:08:51Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "a2e5700fdab8017d9be8088f57c615de8270146f"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe the CDDL can be streamlined, but at the moment, I don't see how.\r\n\r\n@cabo any idea? Currently, even the CDDL checking tool is not even able to parse this properly, the offending line is https://github.com/cbor-wg/cbor-dns/blob/d0705dbe935cd7d7f628218ef6a149e30aa22e39/draft-lenders-dns-cbor.md?plain=1#L335",
          "createdAt": "2025-07-07T11:32:41Z",
          "updatedAt": "2025-07-07T11:32:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOIM0M7M6BVOlO",
      "title": "Make name compression be based on CBOR-packed",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/7",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During IETF 121 the idea came up to bring name compression to CBOR-packed after all by providing a special table setup tag. This is the work to that.",
      "createdAt": "2024-11-08T14:52:03Z",
      "updatedAt": "2025-04-16T11:42:01Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "e82c5a3e5780d34bf78640c3a4ccab2c550e230f",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "name-comp-packed",
      "headRefOid": "ebe36d0bcce6732b153586fd2090a7401fe004c5",
      "closedAt": "2025-04-16T07:00:02Z",
      "mergedAt": "2025-04-16T07:00:02Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "8942b3613df00c4f380dfe432966e52f7939fe62"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed...",
          "createdAt": "2025-04-16T06:39:04Z",
          "updatedAt": "2025-04-16T06:39:04Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "`s/level of packedness/packed value/g`",
          "createdAt": "2025-04-16T06:47:31Z",
          "updatedAt": "2025-04-16T06:47:31Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Huh? Somehow, I messed this up when force pushing...",
          "createdAt": "2025-04-16T06:49:05Z",
          "updatedAt": "2025-04-16T06:49:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> `s/level of packedness/packed value/g`\r\n\r\nThis was meant to reference https://github.com/cbor-wg/cbor-dns/compare/25006971e1f4cb8210e400bc7b439e9bf34748e1..ccf2a04b19c65ddadb716dd8b469d1a7ffb823d4",
          "createdAt": "2025-04-16T06:50:19Z",
          "updatedAt": "2025-04-16T06:50:19Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "`s/CBOR-packed/Packed CBOR/`",
          "createdAt": "2025-04-16T06:55:13Z",
          "updatedAt": "2025-04-16T06:55:13Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "And rebased.",
          "createdAt": "2025-04-16T06:59:10Z",
          "updatedAt": "2025-04-16T06:59:10Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo gave his blessing to merge this offline but has not time to review this.",
          "createdAt": "2025-04-16T06:59:54Z",
          "updatedAt": "2025-04-16T06:59:54Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> @cabo gave his blessing to merge this offline but has not time to review this.\r\n\r\nDon't have time to review right now either, but did we came to a conclusion about the right tag order regarding table prependment?",
          "createdAt": "2025-04-16T10:26:01Z",
          "updatedAt": "2025-04-16T10:26:01Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> did we came to a conclusion about the right tag order regarding table prependment?\r\n\r\nYes, see https://github.com/cbor-wg/cbor-dns/pull/7#discussion_r1888278854",
          "createdAt": "2025-04-16T11:22:08Z",
          "updatedAt": "2025-04-16T11:22:08Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nYes, correct. I've always phrased it as \"the inner tag prepends to the outer tag\", but that's the same statement.\r\n\r\n",
          "createdAt": "2025-04-16T11:41:07Z",
          "updatedAt": "2025-04-16T11:41:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M6Qe9sY",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Some content-related and several editorial suggestions and comments :)",
          "createdAt": "2024-11-08T15:00:57Z",
          "updatedAt": "2024-11-08T15:25:19Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nThis implicit (i.e. not explicitly represented) table _V_ is constructed as follows:\r\n```",
              "createdAt": "2024-11-08T15:00:58Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 151,
              "body": "```suggestion\r\nAny coherent sequence of text strings encountered within the rump of tag TBD28259, as well as any of its non-empty suffixes, are added to the table as arrays in depth-first order.\r\n```",
              "createdAt": "2024-11-08T15:05:13Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 151,
              "body": "Also, what exactly does \"coherent sequence\" mean? Is that a standing term?",
              "createdAt": "2024-11-08T15:05:57Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 159,
              "body": "I personally find it confusing that `packed=0` still means there is packing involved. Could we find a different naming?",
              "createdAt": "2024-11-08T15:09:37Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nIt provides an implicit text string suffix sequence table for shared items _V_ which is prepended to the existing table for shared items that apply to the content of tag TBD28259 (by default empty table).\r\n```\r\n?",
              "createdAt": "2024-11-08T15:10:54Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nTake the following CBOR object _o_ (note that this is intentionally not legal \"application/dns+cbor\" to illustrate generality).\r\n```\r\n\r\nor any other name, just to be able to reference it later.",
              "createdAt": "2024-11-08T15:12:35Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\n    [\"svc\", simple(0)],\r\n```\r\n\r\nis it not?",
              "createdAt": "2024-11-08T15:13:32Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\nNote that the sequence \"org\", \"example\", \"org\" is added at index 4 with leading \"org\", instead of referencing index 2 + index 1 (`simple(2), simple(1)`), as it is its own distinct suffix sequence.\r\n```",
              "createdAt": "2024-11-08T15:14:42Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nThe packed representation of _o_ would thus be:\r\n```",
              "createdAt": "2024-11-08T15:14:51Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\nWith, e.g., table setup tag 113, further packing can be achieved via nesting table packing.\r\n```",
              "createdAt": "2024-11-08T15:16:55Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 210,
              "body": "```suggestion\r\n113(\r\n  TBD28259(\r\n```\r\n\r\notherwise prepending the table from 113 would shift the TBD28259 ones.",
              "createdAt": "2024-11-08T15:18:35Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 225,
              "body": "Could we get rid of this extra rule with by switching the tag order?",
              "createdAt": "2024-11-08T15:21:18Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 259,
              "body": "everything except `tag`, `array` and `map` wouldn't make sense, right?",
              "createdAt": "2024-11-08T15:23:11Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 210,
              "body": "Which clashes with the requirement that we want to elude TBD28259 for dns+cbor, hum...",
              "createdAt": "2024-11-08T15:24:53Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf83K",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:30:30Z",
          "updatedAt": "2024-11-08T16:30:30Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "\u201eCBOR sequence\u201c is a standing term. Cohererent is meant wrt text strings, so a (sub) sequence that only contains text strings.",
              "createdAt": "2024-11-08T16:30:30Z",
              "updatedAt": "2024-11-08T16:30:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf9cx",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:31:40Z",
          "updatedAt": "2024-11-08T16:31:41Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "The idea is that `packed` might also provide other contexts later. Don't read it as boolean, more as, e.g., a level.",
              "createdAt": "2024-11-08T16:31:41Z",
              "updatedAt": "2024-11-08T16:31:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf-3W",
          "commit": {
            "abbreviatedOid": "cfeb452"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:34:30Z",
          "updatedAt": "2024-11-08T16:40:11Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Since it is implicit, this is arbitrary. I thought it might be more helpful to the reader, if we show the full sequences here.",
              "createdAt": "2024-11-08T16:34:30Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 210,
              "body": "> otherwise prepending the table from 113 would shift the TBD28259 ones.\r\n\r\nHuh? From how I read my definition (and the definition for 113), the tables of the outer tag are prepended to the tables of the inner tag. I want the TBD28259 table _V_ to be the \u201cstart\u201d of the shared item table. \r\n\r\n",
              "createdAt": "2024-11-08T16:37:21Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 225,
              "body": "Then the indices for name compression would be larger than the 113 ones... Which would increase the risk of names having larger references (but as they are more common in DNS messages they should be smaller).",
              "createdAt": "2024-11-08T16:39:04Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 259,
              "body": "That would be the same for 113 or 1113. Nevertheless, they have any as data item as well.",
              "createdAt": "2024-11-08T16:39:42Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgvXO",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:33:27Z",
          "updatedAt": "2024-11-08T17:33:27Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Then maybe \"any CBOR sequence consisting of only text strings\"? Maybe it's also just a personal English-word problem with \"coherent\".",
              "createdAt": "2024-11-08T17:33:27Z",
              "updatedAt": "2024-11-08T17:33:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgyJD",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:36:11Z",
          "updatedAt": "2024-11-08T17:36:11Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "At least for 113, it is definitely the other way around. I guess the rationale is that you enable shorter references within smaller contexts (inside the rump of an inner tag).",
              "createdAt": "2024-11-08T17:36:11Z",
              "updatedAt": "2024-11-08T17:36:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgyVJ",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:36:40Z",
          "updatedAt": "2024-11-08T17:36:40Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "see above.",
              "createdAt": "2024-11-08T17:36:40Z",
              "updatedAt": "2024-11-08T17:36:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qg023",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:41:32Z",
          "updatedAt": "2024-11-08T17:41:32Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I think this illustrates the implicit table setup algorithm better.",
              "createdAt": "2024-11-08T17:41:32Z",
              "updatedAt": "2024-11-08T17:41:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QrMdW",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-11T13:03:39Z",
          "updatedAt": "2024-11-11T13:03:39Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Are you sure? Maybe @cabo can help to alleviate the confusion? Does the outer setup tag prepend its table(s) to the inner tag's table(s) or the inner tag to its outer tag's?",
              "createdAt": "2024-11-11T13:03:39Z",
              "updatedAt": "2024-11-11T13:03:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VJhxH",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-13T13:29:48Z",
          "updatedAt": "2024-12-13T13:29:48Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "The main argument is really composability.  A CBOR data item that uses cbor-packed should still work when it is embedded in some other table setup.",
              "createdAt": "2024-12-13T13:29:48Z",
              "updatedAt": "2024-12-13T13:29:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VJjsv",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-13T13:33:43Z",
          "updatedAt": "2024-12-13T13:33:43Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "This is a note, there is no extra rule.\r\nIf the rest of the text doesn't say that, it needs to be fixed.",
              "createdAt": "2024-12-13T13:33:43Z",
              "updatedAt": "2024-12-13T13:33:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VhE9j",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T10:29:10Z",
          "updatedAt": "2024-12-17T10:29:10Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nE.g., taking the example\r\n\r\n```\r\n113(\r\n  TBD28259(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(5)],\r\n        [\"svc\", simple(0)],\r\n        simple(5), simple(1), simple(6),\r\n        simple(3), simple(6)\r\n      ]\r\n    ]\r\n  )\r\n)\r\n```\r\n\r\nwould still work with\r\n\r\n```\r\n  TBD28259(\r\n    [\r\n        [\"www\", \"example\", \"org\"],\r\n        [\"svc\", simple(0)],\r\n        \"org\", simple(1), 42,\r\n        simple(3), 42\r\n    ]\r\n  )\r\n```\r\n\r\nwhile the other way around \r\n\r\n```\r\nTBD28259(\r\n  113(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(5)],\r\n        [\"svc\", simple(0)],\r\n        simple(5), simple(1), simple(6),\r\n        simple(3), simple(6)\r\n      ]\r\n    ]\r\n  )\r\n)\r\n```\r\n\r\nwould completely need to rewrite the `simple(i)` references (and not just the new ones) for `113(...)` if `TBD28259(...)` is taken away to make sense.\r\n\r\n```\r\n  113(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(0)],\r\n        [\"svc\", \"www\", \"example\", simple(0)],\r\n        simple(0), \"example\", simple(0), sample(1),\r\n        \"svc\", \"www\", \"example\", \"org\", sample(1)\r\n      ]\r\n    ]\r\n  )\r\n```\r\n\r\nThis makes sense to me. Will fix (and try to find a better wording to make the table setup clearer).",
              "createdAt": "2024-12-17T10:29:10Z",
              "updatedAt": "2024-12-17T10:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Vibek",
          "commit": {
            "abbreviatedOid": "034b61a"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T13:04:09Z",
          "updatedAt": "2024-12-17T13:04:17Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "I am not set on the term \u201clevel of packedness\u201d. In fact, I would love to get some alternative terms.",
              "createdAt": "2024-12-17T13:04:09Z",
              "updatedAt": "2024-12-17T13:04:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6lPHvA",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T11:42:01Z",
          "updatedAt": "2025-04-16T11:42:01Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "> Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nThat is a funny way to say \"prepend tables built from inner tags to those inherited from an outer table building tag\", but it definitely is what has worked well so far.\r\n(An on-the-fly implementation could start at the node with the reference, go up until it finds the next table building tag, use what it finds there if the reference is covered, or subtract the size of the table from a reference index that goes beyond that table and continue upwards.)",
              "createdAt": "2025-04-16T11:42:01Z",
              "updatedAt": "2025-04-16T11:42:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOIM0M7M6WuEp8",
      "title": "Provide extension point for IP addresses",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/10",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #9.",
      "createdAt": "2025-05-19T12:56:38Z",
      "updatedAt": "2025-07-07T20:24:07Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "a2e5700fdab8017d9be8088f57c615de8270146f",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "ip-addr-ext-point",
      "headRefOid": "1628b99be3e48603d6887477e8303473f0e63e3d",
      "closedAt": "2025-07-07T20:24:03Z",
      "mergedAt": "2025-07-07T20:24:03Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "9a14dc87693b2615888773c7b6ff57cabc48e831"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOIM0M7M6dzlOt",
      "title": "Fix CDDL for PR#6 (groups vs. types)",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/11",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-07T18:13:25Z",
      "updatedAt": "2025-07-07T18:24:25Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "rrsets",
      "baseRefOid": "d0705dbe935cd7d7f628218ef6a149e30aa22e39",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "fix-cddl-6",
      "headRefOid": "d4234648d6d3dc7466e98e832666828b4fe73b06",
      "closedAt": "2025-07-07T18:24:25Z",
      "mergedAt": "2025-07-07T18:24:25Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "5e8db6e1f7d4ec269f1dc26f758ae39a79701afc"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Ahh, thanks!",
          "createdAt": "2025-07-07T18:24:15Z",
          "updatedAt": "2025-07-07T18:24:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOIM0M7M6-B8ST",
      "title": "Provide dns-rrt, dns-cls, dns-opt, and dns-svp EDN literals",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/14",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This provides a (draft for now) for an EDN app-specific extension for DNS+CBOR. So far, I only introduced resource record types, classes, EDNS(0) option codes and SVCB SvcParamKeb but even Header Flags including Rcodes could be a point of extension. But let's discuss by example first, if this is in scope. If so, I will also provide an ABNF.",
      "createdAt": "2026-01-19T15:11:57Z",
      "updatedAt": "2026-01-23T23:56:23Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "dc6fa1b7571473e41106327eca9f0b13ee83b088",
      "headRepository": "miri64/cbor-dns",
      "headRefName": "edn-literals",
      "headRefOid": "d51d93b8fc73857a97659e222eb794c539dc01fa",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "As the new title implies: I now added a few more literals.",
          "createdAt": "2026-01-23T16:03:00Z",
          "updatedAt": "2026-01-23T16:03:00Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Gah. Of course people won't use such long literals for such short substrings. What people do expect is familiar syntax:\r\n```\r\ndns-rr'example.org  3600 IN A 192.0.0.2'\r\n```\r\ntranslating to entire RR array. Or sequence to be inside array... because actually, from data model point of view, every item should have explicit tag on it, e.g.\r\n`TBDrr([\"example\", \"org\", 3600, 5, \"ns1\", \"example\", \"org\"])`\r\nIt is just that we omit such tags for the compactness of wire representation, but in application data structures implementers will have data types more explicit - RR, name, type, class, ...\r\n\r\nUPD: ...Yes, I think it should expand to CBOR sequence: for allowing things like\r\n`[dns-rr'example.com 4800 A', ip'192.0.0.2']`\r\nor actually, for better specifying bstr-s as RRDATA unknown to (current version of) parser, or - for example - to `dns-opt''` and `dns-svp''`.\r\nSo it will expand to only those things explicitly listed inside quotes, allowing to specify more precisely what goes to array. And paying attention to dot at end to produce empty string, thus allowing to support zone files also, but `$ORIGIN` suggestion etc. is better to discuss in #12 \r\n\r\nTo summarize, `dns-rrt`, `dns-rrc` and `dns-cls` are not needed, unified `dns-rr` should be used instead. As for `dns-opt''` and `dns-svp''`, these are fine.",
          "createdAt": "2026-01-23T23:19:27Z",
          "updatedAt": "2026-01-23T23:56:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M7bSZxK",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-19T17:07:09Z",
          "updatedAt": "2026-01-19T17:21:18Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\nThe application-extension identifier \"dns-rt\" is used to notate a DNS resource record type (RRTYPE) literal.\n```\n\nmaybe? Just fearing that `rt` might be useful for something else in the future. See https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-6.1",
              "createdAt": "2026-01-19T17:07:09Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 50,
              "body": "hum, what do you mean with byte string here? are there DNS RRTYPE that are not ASCII?",
              "createdAt": "2026-01-19T17:09:12Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 51,
              "body": "I'm not sure I understand. Why would some mnemonic not be part of the IANA registry?",
              "createdAt": "2026-01-19T17:12:12Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\nIf the literal matches `[0-9][0-9]*` its value is decimal value of the number matching\n```\n\nWouldn't that also work and be more concise? I'd assume there can be no RRTypes containing numbers?",
              "createdAt": "2026-01-19T17:13:51Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 54,
              "body": "also \n\n\n```suggestion\nIf the literal matches `TYPE[0-9][0-9]*` its value is the decimal value of the number matching\n```",
              "createdAt": "2026-01-19T17:14:21Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 56,
              "body": "You say this twice, or am I overlooking something?",
              "createdAt": "2026-01-19T17:15:17Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\nThe application-extension identifier \"dns-rc\" is used to notate a DNS resource record class (RR CLASS) literal.\n```\n\nSame as above",
              "createdAt": "2026-01-19T17:18:16Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\nOtherwise it must be a mnemonic that is assigned in the paranthesis of the \"Name\" column in the \"DNS\n```",
              "createdAt": "2026-01-19T17:18:31Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 135,
              "body": "much nicer-looking examples!",
              "createdAt": "2026-01-19T17:19:16Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxdqE",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:10:07Z",
          "updatedAt": "2026-01-21T13:10:07Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "> Just fearing that `rt` might be useful for something else in the future. See https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-6.1\r\n\r\nI leave that decision to the experts of that IANA registry. I was actually taking inspiration from the initial set there and I think a short(er) identifier would motivate usage more. To me, if the identifier is longer than the content (dns-rt'A') or the actual value (1), I already see people using intransparent shorthands (like a/d+c for this format e.g.).",
              "createdAt": "2026-01-21T13:10:07Z",
              "updatedAt": "2026-01-21T13:10:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxhhN",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:13:53Z",
          "updatedAt": "2026-01-21T13:13:53Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "This wording was taken verbatim from EDN. E.g. for `ip''` [its draft says](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-3.2-2):\r\n\r\n> The content of the literal is a single IPv4address or IPv6address as per [Section 3.2.2](https://rfc-editor.org/rfc/rfc3986#section-3.2.2) of [[RFC3986](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#RFC3986)], as **a text or byte string**.\r\n\r\nAnd actually, given that in EDN [byte strings are notated with `''`](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-2.5.3), all examples out there (even the pure ASCII ones) are using byte strings. So your question should rather be \"why allow text strings ([which exclusively use `\"\"`](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#name-text-string-literals))?\" ;-)",
              "createdAt": "2026-01-21T13:13:53Z",
              "updatedAt": "2026-01-21T13:14:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxldX",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:17:42Z",
          "updatedAt": "2026-01-21T13:17:43Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Because a draft author might not have it registered yet. See in this draft e.g. TBD28259 for tag 28259. Having `TYPE1234` or `CLASS5678` gives draft authors (and also just example authors a nice way to distinguish between type and class (which in raw CBOR would both be just unsigned integers) when there is no mnemonic for that number (yet).",
              "createdAt": "2026-01-21T13:17:42Z",
              "updatedAt": "2026-01-21T13:17:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxsqh",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:24:44Z",
          "updatedAt": "2026-01-21T13:24:45Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "> Wouldn't that also work and be more concise? I'd assume there can be no RRTypes containing numbers?\r\n\r\nEDN isn't and shouldn't be about conciseness, but readability and familiarity. When using just numbers I can also just use the unsigned integer outright (yes there is the EDN identifier 'rt' marking it as a type, but that can easily be overlooked) and using `TYPE1234` or `CLASS5678` is something already used within the DNS community for generic types and classes (see [RFC3597, section 5](https://datatracker.ietf.org/doc/html/rfc3597#section-5)).",
              "createdAt": "2026-01-21T13:24:44Z",
              "updatedAt": "2026-01-21T13:24:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxvCN",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:26:43Z",
          "updatedAt": "2026-01-21T13:26:44Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Can you point me to the other mention please? I only see [the definition that the mnemonic \"ANY\" is a legal content of `rt`](https://github.com/cbor-wg/cbor-dns/pull/14/changes#diff-c1ee54122d8c0f166af4524c64e92b0795cd43782536a16364a57a948d8cc838R959). Here I state, that that mnemonic \"ANY\" evaluates to the value 255.",
              "createdAt": "2026-01-21T13:26:43Z",
              "updatedAt": "2026-01-21T13:27:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxwiH",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:28:11Z",
          "updatedAt": "2026-01-21T13:28:11Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "And my answer is the same as in https://github.com/cbor-wg/cbor-dns/pull/14/changes#r2712512085",
              "createdAt": "2026-01-21T13:28:11Z",
              "updatedAt": "2026-01-21T13:28:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxyii",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:30:13Z",
          "updatedAt": "2026-01-21T13:30:13Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Would it still be nice if it were `[[\"example\", \"org\", dns-rt'255', dns-rc'255']]`? ;-)",
              "createdAt": "2026-01-21T13:30:13Z",
              "updatedAt": "2026-01-21T13:30:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7b2ypl",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T17:44:38Z",
          "updatedAt": "2026-01-21T17:44:39Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "@cabo do you maybe have an opinion on the matter?",
              "createdAt": "2026-01-21T17:44:38Z",
              "updatedAt": "2026-01-21T17:44:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI8CK",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:18:27Z",
          "updatedAt": "2026-01-22T16:18:27Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Ah so both `rt'XXX'` and `rt\"XXX\"` would be valid and equivalent? Not sure I like that design decision of allowing both, especially if we already know we would only ever use ASCII strings here.",
              "createdAt": "2026-01-22T16:18:27Z",
              "updatedAt": "2026-01-22T16:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI8hQ",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:18:56Z",
          "updatedAt": "2026-01-22T16:18:57Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Hum okay, I see. Maybe make that intention explicit?",
              "createdAt": "2026-01-22T16:18:57Z",
              "updatedAt": "2026-01-22T16:18:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI9Lw",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:19:33Z",
          "updatedAt": "2026-01-22T16:19:34Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Convincing, especially now that I understood what `TYPEXXX` is meant for :)",
              "createdAt": "2026-01-22T16:19:33Z",
              "updatedAt": "2026-01-22T16:19:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI_As",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:20:55Z",
          "updatedAt": "2026-01-22T16:20:55Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> [\u2026] especially if we already know we would only ever use ASCII strings here.\r\n\r\nNot sure where this ASCII constraint is coming from, btw... Text strings in CBOR are UTF-8. And binary strings do not carry any encoding AFAIK.",
              "createdAt": "2026-01-22T16:20:55Z",
              "updatedAt": "2026-01-22T16:20:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI_E2",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:20:59Z",
          "updatedAt": "2026-01-22T16:20:59Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "No, but it would if it were `[[\"example\", \"org\", dns-rt'ANY', dns-rc'ANY']]`!",
              "createdAt": "2026-01-22T16:20:59Z",
              "updatedAt": "2026-01-22T16:20:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cJAca",
          "commit": {
            "abbreviatedOid": "61a175b"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:22:18Z",
          "updatedAt": "2026-01-22T16:22:18Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "True, my bad.",
              "createdAt": "2026-01-22T16:22:18Z",
              "updatedAt": "2026-01-22T16:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cOJV_",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T21:35:54Z",
          "updatedAt": "2026-01-22T21:35:54Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "See 96b48f30e20fe82b1f3cf21ee",
              "createdAt": "2026-01-22T21:35:54Z",
              "updatedAt": "2026-01-22T21:35:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVhL6",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:37:27Z",
          "updatedAt": "2026-01-23T09:37:27Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Good point, then I'd rephrase the above as\r\n\r\n> Ah so both `rt'XXX'` and `rt\"XXX\"` would be valid and equivalent? Not sure I like that design decision of allowing both, especially if we already know we would only ever use UTF-8 strings here.\r\n\r\n(I highly doubt RTYPE or RCLASS would have names that are not UTF-8 at some point, which would be an argument for allowing byte strings, but maybe I'm wrong?)\r\n\r\n",
              "createdAt": "2026-01-23T09:37:27Z",
              "updatedAt": "2026-01-23T09:37:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYQRj",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T12:52:44Z",
          "updatedAt": "2026-01-23T12:52:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Again, I just copied verbatim from the EDN draft. See https://github.com/cbor-wg/cbor-dns/pull/14#discussion_r2712525828. `dt` has the same wording as `ip`\r\n\r\n> The content of the literal is a single Standard Date/Time String as per Section [3.4.1](https://rfc-editor.org/rfc/rfc8949#section-3.4.1) of RFC 8949 [[STD94](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#STD94)], as a *text or byte string*.\r\n\r\n`hash` only says \"string\" and does not specify and `cri` does not mention strings at all:\r\n\r\n> The content of the literal is a single Standard Date/Time String as per Section [3.4.1](https://rfc-editor.org/rfc/rfc8949#section-3.4.1) of RFC 8949 [[STD94](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#STD94)], as a text or byte string.\r\n\r\nGiven that `dt` and `ip` are the only ones that explicitly mention text and byte strings and from their semantic `rt` and `rc` are closer to them, why should they only allow byte strings while `dt` and `ip` also allow text strings. Not sure what this extra restriction would achieve.\r\n\r\n> > Ah so both `rt'XXX'` and `rt\"XXX\"` would be valid and equivalent? Not sure I like that design decision of allowing both, especially if we already know we would only ever use UTF-8 strings here.\r\n> \r\n> (I highly doubt RTYPE or RCLASS would have names that are not UTF-8 at some point, which would be an argument for allowing byte strings, but maybe I'm wrong?)\r\n\r\nYes, the definition of the mnemonics makes it clear that they are only ASCII (only upper case letters and digits, in fact) and it will be part of the ABNF once the format somewhat settles. But I am not sure what you expect from me here? I already refer to the definition and there is no dedicated type for ASCII strings in CBOR.",
              "createdAt": "2026-01-23T12:52:44Z",
              "updatedAt": "2026-01-23T12:52:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYvIW",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:26:49Z",
          "updatedAt": "2026-01-23T13:26:49Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I'm challenging the design decision in EDN that now trickled down into this draft of allowing both `ip'xxx'` and `ip\"xxx\"` even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.",
              "createdAt": "2026-01-23T13:26:49Z",
              "updatedAt": "2026-01-23T13:26:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cY1bi",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:33:48Z",
          "updatedAt": "2026-01-23T13:33:48Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> I'm challenging the design decision in EDN that now trickled down into this draft of allowing both ip'xxx' and ip\"xxx\" even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.\r\n\r\nBut what has the major type of the content to do with wether it is non-UTF8 or not? Both byte strings and text strings are allowed to carry UTF-8 in EDN. The only difference between them in [raw] EDN is the type of quotation marks and some differring rules on escaping (when necessary) as far as I understand.",
              "createdAt": "2026-01-23T13:33:48Z",
              "updatedAt": "2026-01-23T13:34:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cZFCe",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:47:41Z",
          "updatedAt": "2026-01-23T13:47:42Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> I'm challenging the design decision in EDN that now trickled down into this draft of allowing both `ip'xxx'` and `ip\"xxx\"` even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.\r\n\r\nCan you explain that decision some more?\r\n\r\nAs far as I can see, the grammar only allows\r\n\r\n```abnf\r\napp-string      = app-prefix sqstr\r\n```\r\n(where sqstr is a single-quoted string.)\r\n\r\nWe may need to add some text on the equivalence of ext'foo' and ext<<\"foo\">>, is that what you are criticizing?",
              "createdAt": "2026-01-23T13:47:41Z",
              "updatedAt": "2026-01-23T13:47:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cZJDy",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:51:05Z",
          "updatedAt": "2026-01-23T13:51:06Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) and rc'', but could this also be addressed with e''?\r\ne'' is really what was designed to address these cases.",
              "createdAt": "2026-01-23T13:51:06Z",
              "updatedAt": "2026-01-23T13:51:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7caOWm",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:41:37Z",
          "updatedAt": "2026-01-23T14:41:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> > I'm challenging the design decision in EDN that now trickled down into this draft of allowing both `ip'xxx'` and `ip\"xxx\"` even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.\r\n> \r\n> Can you explain that decision some more?\r\n> \r\n> As far as I can see, the grammar only allows\r\n> \r\n> ```abnf\r\n> app-string      = app-prefix sqstr\r\n> ```\r\n> \r\n> (where sqstr is a single-quoted string.)\r\n\r\nMh, did not see that ABNF, but this discussion was purely based on the wording in https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-3.1-2 and https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-3.2-2 where it explicitly mentions text strings (double quoted as per https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-2.5.1) and byte strings (single quoted as per https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-2.5.1).\r\n\r\n> We may need to add some text on the equivalence of ext'foo' and ext<<\"foo\">>, is that what you are criticizing?\r\n\r\nAt least I understand this equivalent and pretty sure @mguetschow does, too. As far as I understand, @mguetschow is concerned about a pure ASCII string being able to be expressible in two data types (but that's then where I am not sure what the actual problem is).",
              "createdAt": "2026-01-23T14:41:37Z",
              "updatedAt": "2026-01-23T14:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7caUo1",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:46:39Z",
          "updatedAt": "2026-01-23T14:46:40Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) and rc'', but could this also be addressed with e''?\r\n> e'' is really what was designed to address these cases.\r\n\r\nYou mean https://www.ietf.org/archive/id/draft-ietf-cbor-edn-e-ref-02.html? Only learned about this draft now, but from what I can gather: Yes, it could fit, but due to its temporary nature (as far as I understand this is meant for drafts) would probably mean continuous updating of the `e''` constants to stay in sync with the IANA tables later on. So having something fixed that can be used in more official documents (or even parsers/sniffers/...) would be great, IMHO.",
              "createdAt": "2026-01-23T14:46:39Z",
              "updatedAt": "2026-01-23T14:46:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7calWf",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:59:17Z",
          "updatedAt": "2026-01-23T14:59:17Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> > As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) and rc'', but could this also be addressed with e''?\r\n> > e'' is really what was designed to address these cases.\r\n> \r\n> You mean https://www.ietf.org/archive/id/draft-ietf-cbor-edn-e-ref-02.html? Only learned about this draft now, but from what I can gather: Yes, it could fit, but due to its temporary nature (as far as I understand this is meant for drafts) would probably mean continuous updating of the `e''` constants to stay in sync with the IANA tables later on. So having something fixed that can be used in more official documents (or even parsers/sniffers/...) would be great, IMHO.\r\n\r\nI dimly remember some work (I think it was even yours, @cabo) to import a IANA registry into _something_..., I couldn't find it that quickly in the datatracker (since I am unsure about the \"something\" I am not even sure where to search) but if the \"something\" was EDN, that would help more!",
              "createdAt": "2026-01-23T14:59:17Z",
              "updatedAt": "2026-01-23T14:59:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cbMo0",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T15:27:16Z",
          "updatedAt": "2026-01-23T15:27:17Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) [...]\r\n\r\nOk, conceding to a 2:1 vote then and changed the names to `dns-rrt` (DNS resource record type) and `dns-cls` (DNS class) in 0cf0f06",
              "createdAt": "2026-01-23T15:27:16Z",
              "updatedAt": "2026-01-23T15:27:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7ci4Ju",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T23:48:15Z",
          "updatedAt": "2026-01-23T23:48:15Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "`e''` and `ref''` extensions are good (though I don't remember their discussion in m.list right now), but are solving slightly different task: if all your data are described by authoritative primary source being CBOR-oriented, currently meaning CDDL.\r\nBut for DNS data such source is outside of us, and people are already accustomed for decades to textual form from RFC 1035. So I've put a top-level comment below about that we should take it different way...",
              "createdAt": "2026-01-23T23:48:15Z",
              "updatedAt": "2026-01-23T23:48:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7ci44T",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T23:49:57Z",
          "updatedAt": "2026-01-23T23:49:57Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "As per https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3792984448, the\r\n`[[dns-rr'example.org ANY ANY']]`\r\nis looking much more better!",
              "createdAt": "2026-01-23T23:49:57Z",
              "updatedAt": "2026-01-23T23:49:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOIM0M7M6-CFs7",
      "title": "Make options a list again",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/15",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TBD28259 (see section Name Compression) put the final death nail into the idea of the EDNS(0) options being a map.",
      "createdAt": "2026-01-19T15:24:11Z",
      "updatedAt": "2026-01-23T23:40:05Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "dc6fa1b7571473e41106327eca9f0b13ee83b088",
      "headRepository": "miri64/cbor-dns",
      "headRefName": "opt-list",
      "headRefOid": "df6d2d160528af0db1c82c412d2647d9f3c9d0b3",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "In the interest of consistency it probably makes sense to encode the list of options in the same manner as we do SvcParams (a flat list with interleaving optnum-optval-pairs). We do that their, because SvcParams MUST have a predetermined order, but does not hurt to do it here as well. Will do!",
          "createdAt": "2026-01-21T15:49:13Z",
          "updatedAt": "2026-01-21T15:50:14Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "I support making it array (so that *everything* structured is array which allows for subset coding in CBAPT, but this I'll write more detailed later in #12), however did not quite understand why name compression was that nail.\r\n\r\nThe only possible thing I may be suggesting here is to add a phrase that order of key-value pairs is, like in original DNS, not important (behaves like map) - for those fearless who could try to add determinism here in future...",
          "createdAt": "2026-01-23T23:40:05Z",
          "updatedAt": "2026-01-23T23:40:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M7bSjnk",
          "commit": {
            "abbreviatedOid": "4815fc5"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-19T17:23:00Z",
          "updatedAt": "2026-01-19T17:25:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\nThe next element is a array of tuples of the options, with the option code (unsigned integer) being the first tuple element and the option data (byte string) being the second tuple element.\n```\n\nDoes that match what you are trying to say?",
              "createdAt": "2026-01-19T17:23:00Z",
              "updatedAt": "2026-01-19T17:25:31Z"
            },
            {
              "originalPosition": 6,
              "body": "Mmmmh, doesn't this add 1B unnecessarily per tuple, also compared to the map encoding?\n\nMaybe this part also warrants a note on why you would not use maps instead of describing maps-semantics based on an array (-> ordering).\n\nBtw, would these options be ordered in any form, e.g., by option number?",
              "createdAt": "2026-01-19T17:25:14Z",
              "updatedAt": "2026-01-19T17:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bx0Sj",
          "commit": {
            "abbreviatedOid": "4815fc5"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:31:47Z",
          "updatedAt": "2026-01-21T13:31:47Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I actually wanted to include as well, that the tuple has exactly 2 elements.... but maybe this can be done with\r\n\r\n```suggestion\r\nThe next element is a array of 2-tuples of the options, with the option code (unsigned integer) being the first tuple element and the option data (byte string) being the second tuple.\r\n```\r\n?",
              "createdAt": "2026-01-21T13:31:47Z",
              "updatedAt": "2026-01-21T13:31:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7byBR_",
          "commit": {
            "abbreviatedOid": "4815fc5"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:43:24Z",
          "updatedAt": "2026-01-21T13:43:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Mmmmh, doesn't this add 1B unnecessarily per tuple, also compared to the map encoding?\r\n>\r\n> Maybe this part also warrants a note on why you would not use maps instead of describing maps-semantics based on an array (-> ordering).\r\n\r\nSo you think we rather should put the lexicographic ordering encoding constrained from [from draft-ietf-cbor-serialization](https://www.ietf.org/archive/id/draft-ietf-cbor-serialization-01.html#section-4.1) here? Could be tricky to just get that out of there, since the draft does not define that independently as `draft-ietf-cbor-cde` did (while \"ordinary serialization\" is preferred, I don't think it should be a requirement). Maybe an incentive for the working group to have this defined independently? However ...\r\n\r\n> Btw, would these options be ordered in any form, e.g., by option number?\r\n\r\nSee [RFC 6891, section 6.1.2](https://datatracker.ietf.org/doc/html/rfc6891#section-6.1.2):\r\n\r\n>    The order of appearance of option tuples is not defined.  If one\r\n>    option modifies the behaviour of another or multiple options are\r\n>    related to one another in some way, they have the same effect\r\n>    regardless of ordering in the RDATA wire encoding.\r\n\r\nSo no. But continuing my parenthesis from above ... However, I think it is better to not put any requirement on the order of options on an encoder. This might come directly from another server. Putting then work into reordering the options seems like a waste to me and I have the hunch that it does not really help us with our problem for name compression here...",
              "createdAt": "2026-01-21T13:43:24Z",
              "updatedAt": "2026-01-21T13:43:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOIM0M7M6-y9dm",
      "title": "Pass on name compression",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/16",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This reworks the name compression as discussed during the last few meetings we had.\r\n\r\nNamely:\r\n\r\n- TBD28259 now appends, rather than prepends to existing packing tables to allow for single pass decoders with minimum state.\r\n-  Consequently, disallow inner table setup tags to TBD28259, as that would increase complexity of both decoders and encoders\r\n- Clarify implicit nature with `packed`\r\n- Use actual DNS examples\r\n- Add example decoder as pseudo-code\r\n- Additionally, add some considerations on maps within TBD28259 (see also #15)",
      "createdAt": "2026-01-22T21:30:42Z",
      "updatedAt": "2026-01-24T13:42:34Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "dc6fa1b7571473e41106327eca9f0b13ee83b088",
      "headRepository": "miri64/cbor-dns",
      "headRefName": "tbd28259-order",
      "headRefOid": "55ed1d88c9e4d098e60a21c16b580ce02e782d70",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M7cUr0s",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thanks, this is a huge step forward. Some nits and a few major points below.",
          "createdAt": "2026-01-23T08:46:08Z",
          "updatedAt": "2026-01-23T09:30:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd argue that the order of adding the sequence and its suffixes could be more explicit. Maybe\n\n\n```suggestion\nAny coherent sequence of text strings encountered within the rump of tag TBD28259 when reading it depth-first, as well as any of its non-empty suffixes, ordered by sequence length, are added to the table as arrays marked with the splice integration tag 1115 (see {{-cbor-packed, Section 5.1}}).\n```",
              "createdAt": "2026-01-23T08:46:08Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 14,
              "body": "I think we could remove this sentence now that inner table setups are NOT RECOMMENDED (which is different to disallowed, as you state in the PR description, btw).",
              "createdAt": "2026-01-23T08:47:09Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\nIf a sequence for which a tagged array is already in _V_ is encountered, a shared item reference _i_ is added to the rump instead, splicing the content of the array within tag 1115 into the existing array (see {{-cbor-packed, Section 5.1}}) and that sequence as well as its non-empty suffixes is not added again to _V_.\n```",
              "createdAt": "2026-01-23T08:48:32Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 22,
              "body": "Do you mean future setup tags for dns+cbor? If so, I would explicitly say so.\n\nBut in any case I'd argue that this statement is not needed as it follows from the fact that table setup tags can define their semantics and (content) restrictions.",
              "createdAt": "2026-01-23T08:50:54Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\nDue to the order of strings being important, special care should be taken for the order of map (major type 5, {{-cbor}}) elements within tag TBD28259.\n```\n\nThis sentence could actually start a new paragraph.",
              "createdAt": "2026-01-23T08:51:54Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\nIf any other CBOR object than an object defined by `dns-message` in {{fig:dns-msg}} is compressed using TBD28259, map elements MUST be encoded in bytewise lexicographic order of their keys, as specified in {{Section 4.2.1 of -cbor}}, unless the definition of that particular object type provides a different predetermined order.\n```",
              "createdAt": "2026-01-23T08:53:16Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\nIf the decoder encounters an object marked with \"application/dns+cbor;packed=0\" that is tagged TBD28259, it MUST NOT discard it and treat the tag as explicit.\n```\n\nor is there a reason not to capitalize it?",
              "createdAt": "2026-01-23T08:54:11Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\nOtherwise, it might incur an additional message to be sent and media type negotiation might fail unnecessarily.\n```",
              "createdAt": "2026-01-23T08:55:49Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 34,
              "body": "Also, what does \"treat the tag as explicit\" mean? I'd rather say it the other way around, i.e. \"treat the content of the tag as the object, i.e., ignoring the explicit tag\".",
              "createdAt": "2026-01-23T08:57:00Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 37,
              "body": "Why \"only within _V_\"? Why couldn't I (for some reason) add a 1115-tagged array in my outer setup table provided to 113?",
              "createdAt": "2026-01-23T08:58:10Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\nAlso note that, e.g., the sequence \"www\", \"example\", \"org\" (appears as index 0) is not referenced as `simple(0)` within index 3 as this is how _V_ would be read given {{fig:name-compression-example-unpacked}}.\n```",
              "createdAt": "2026-01-23T09:00:47Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\nNote that the sequence \"org\", \"example\", \"org\" is added at index 4 with leading \"org\", instead of referencing index 2 + index 1 (`simple(2), simple(1)`), as it is its own distinct suffix sequence.\nIts suffix \"example\", \"org\" is however not added to the table again, as it is already present at index 2.\n```\n\nJust to make it more explicit.",
              "createdAt": "2026-01-23T09:01:51Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 283,
              "body": "```suggestion\n(see {{Section 3.1 of -cbor-packed}}) compressing the name-compressed response as rump.\n```",
              "createdAt": "2026-01-23T09:05:09Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 299,
              "body": "```suggestion\nPacked-Text-String-Suffix-Sequence-Packed-CBOR = #6.113(\n```\n\n(typo :P)",
              "createdAt": "2026-01-23T09:05:51Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 311,
              "body": "So this means sending tag 113 explicitly is _not_ allowed, while sending tag TBDnc for `packed=0` MUST be accepted? But sending TBDnc explicitly within `packed=1` is again disallowed? Why this difference?\n\nAs argued offline, I'd rather prohibit the explicit tag TBDnc for `packed=0` as well, as I see no benefit of allowing it, but might lead to confusion of the reader of the document and potential encoder implementation that introduce 3B of overhead in every response. But if we allow it for `packed=0`, we should also for `packed=1`, and for both tags.",
              "createdAt": "2026-01-23T09:12:17Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 314,
              "body": "Okay, this was a bit surprising for me. Maybe make it more explicit that `packed=0` can be used for both queries and responses above.",
              "createdAt": "2026-01-23T09:13:31Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 371,
              "body": "```suggestion\nNote, that the encoder needs to rewrite the references from {{fig:name-compression-example-unpacked}} as the implicit table _V_ is appended to the shared argument table `[\"org\", 600]`.\n```\n\nwhy confusing the reader by describing it the other way round here?",
              "createdAt": "2026-01-23T09:15:39Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 481,
              "body": "Thanks for the pseudocode! I would move it to the appendix, though.",
              "createdAt": "2026-01-23T09:16:45Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 501,
              "body": "This is invalid according to https://github.com/cbor-wg/cbor-dns/pull/16/changes#r2720352516",
              "createdAt": "2026-01-23T09:17:47Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 543,
              "body": "This could be misinterpreted to get the reference to the tag 1115.\n\nI think what you mean is storing the index of the last start of a consecutive string sequence, right? Maybe it's clearer if you get the index here...",
              "createdAt": "2026-01-23T09:25:28Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 552,
              "body": "... and iterate from that index here (and below)",
              "createdAt": "2026-01-23T09:25:40Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 567,
              "body": "I fear this could break if for some reason \"example\" would have been part of the outer 113-packing table in our running example. Maybe worth going through step-by-step again to double-check.",
              "createdAt": "2026-01-23T09:27:44Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 580,
              "body": "```suggestion\n          /* not part of a name anymore, so close local name reference */\n```",
              "createdAt": "2026-01-23T09:28:20Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 588,
              "body": "```suggestion\n              result.append(Tag(elem.value, _rec_unpack_names(elem.content, unpacker)))\n```",
              "createdAt": "2026-01-23T09:29:23Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVhyX",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:37:57Z",
          "updatedAt": "2026-01-23T09:37:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "It's not ordered by sequence length. Its ordered by appearance in the rump (which coincides of course with the length for a sequence of strings; but ordered by length could make this make misunderstandable). I think \"ordered by appearance\" just duplicates the first half of the sentence, but if it helps getting a better idea, I can add it.",
              "createdAt": "2026-01-23T09:37:57Z",
              "updatedAt": "2026-01-23T09:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVqyl",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:45:47Z",
          "updatedAt": "2026-01-23T09:45:48Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "> This could be misinterpreted to get the reference to the tag 1115.\r\n\r\nI'm confused... I _want_ (an array of) references to whatever is in the packing table here, so yes to tag 1115. That's why I use `table_entry.`_`content`_ to append the string to all table rows down in l1014 which in my pseudo-code accesses the content of a tag.\r\n\r\n> I think what you mean is storing the index of the last start of a consecutive string sequence, right? Maybe it's clearer if you get the index here... \r\n\r\nNo, I want a reference to the last few string sequence_s_, including all the suffixes that came before, so I can append the current string to _all_",
              "createdAt": "2026-01-23T09:45:48Z",
              "updatedAt": "2026-01-23T09:45:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVrW1",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:46:20Z",
          "updatedAt": "2026-01-23T09:46:20Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "Not sure, how to help here. The comments already describe what I was saying.",
              "createdAt": "2026-01-23T09:46:20Z",
              "updatedAt": "2026-01-23T09:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVsfs",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:47:27Z",
          "updatedAt": "2026-01-23T09:47:28Z",
          "comments": [
            {
              "originalPosition": 552,
              "body": "mhh... if it really helps, I can use indexes. Maybe indeed more useful from a C perspective, too.",
              "createdAt": "2026-01-23T09:47:27Z",
              "updatedAt": "2026-01-23T09:47:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVt0t",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:48:50Z",
          "updatedAt": "2026-01-23T09:48:50Z",
          "comments": [
            {
              "originalPosition": 567,
              "body": "??!? the outer packing table should not be touched here, as it is before the reference that the _local variable_ `name_ref` carries.",
              "createdAt": "2026-01-23T09:48:50Z",
              "updatedAt": "2026-01-23T09:48:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cV3Kc",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:57:35Z",
          "updatedAt": "2026-01-23T09:57:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm referring to the order of the suffixes. Going by your description, I would have `1115([\"www\"]), 1115([\"www\", \"example\"]), 1115([\"www\", \"example\", \"org\"])` as my first three packing table entries, as \"www\" appears first in the rump.\r\n\r\nSo the idea is: Identify coherent sequences of text strings. For each of them, in order of appearance in the rump, you add the sequence and all its non-empty suffixes starting from the longest suffix.\r\n\r\nNot sure how to phrase that in an easily understandable way. Maybe breaking the sentence into several parts.",
              "createdAt": "2026-01-23T09:57:35Z",
              "updatedAt": "2026-01-23T09:57:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cV-zP",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:03:21Z",
          "updatedAt": "2026-01-23T10:03:21Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "> I'm confused... I _want_ (an array of) references to whatever is in the packing table here, so yes to tag 1115.\r\n\r\nBut if you get a reference to tag 1115, then you get the reference only to this one entry, and not to the subsequent ones?\r\n\r\n> No, I want a reference to the last few string sequence_s_, including all the suffixes that came before, so I can append the current string to _all_\r\n\r\nbefore the current string, but after the tag 1115 that is stored in `name_ref` right? This is where it is confusing for me, when you store `name_ref`, it is at the end of the packing table, and these suffixes are only added afterwards. That's why I think indexes are much clearer.",
              "createdAt": "2026-01-23T10:03:21Z",
              "updatedAt": "2026-01-23T10:03:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWAZx",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:04:57Z",
          "updatedAt": "2026-01-23T10:04:57Z",
          "comments": [
            {
              "originalPosition": 567,
              "body": "Sure, but we are decoding, we have (for some reason) `[\"example\"]` as our 113 packing table, and we encounter `\"www\", simple(0), \"org\"`.",
              "createdAt": "2026-01-23T10:04:57Z",
              "updatedAt": "2026-01-23T10:04:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWM9x",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:18:15Z",
          "updatedAt": "2026-01-23T10:18:15Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "The outer setup table is not part of the TBD28259 table setup and comes with its own sets of rules. But I guess this point became moot since there are no inner table setups with TBD28259, and https://datatracker.ietf.org/doc/html/draft-ietf-cbor-packed#section-5-2 makes it clear that integration tags are only allowed in reference tables.",
              "createdAt": "2026-01-23T10:18:15Z",
              "updatedAt": "2026-01-23T10:18:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWQjU",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:22:16Z",
          "updatedAt": "2026-01-23T10:22:16Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "> So this means sending tag 113 explicitly is _not_ allowed, while sending tag TBDnc for `packed=0` MUST be accepted? But sending TBDnc explicitly within `packed=1` is again disallowed? Why this difference?\n\nBecause our argument confused me now \ud83d\ude05. Of course tag 113 is also allowed explicitly. Should I put it into the rule again or just mention it here.",
              "createdAt": "2026-01-23T10:22:16Z",
              "updatedAt": "2026-01-23T10:25:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWRKu",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:23:00Z",
          "updatedAt": "2026-01-23T10:23:01Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "This has _always_ been the case for `packed=1`, so I am a bit confused how this surprised you.",
              "createdAt": "2026-01-23T10:23:00Z",
              "updatedAt": "2026-01-23T10:23:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWSBG",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:24:01Z",
          "updatedAt": "2026-01-23T10:24:01Z",
          "comments": [
            {
              "originalPosition": 481,
              "body": "Agreed, but let's keep it here for the review first.",
              "createdAt": "2026-01-23T10:24:01Z",
              "updatedAt": "2026-01-23T10:24:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWTUy",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:25:31Z",
          "updatedAt": "2026-01-23T10:25:31Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "See https://github.com/cbor-wg/cbor-dns/pull/16/changes#r2720612202",
              "createdAt": "2026-01-23T10:25:31Z",
              "updatedAt": "2026-01-23T10:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWXPd",
          "commit": {
            "abbreviatedOid": "0b62f08"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:29:10Z",
          "updatedAt": "2026-01-23T10:29:10Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "> Maybe make it more explicit that `packed=0` can be used for both queries and responses above.\n\nhttps://github.com/cbor-wg/cbor-dns/pull/16/changes#diff-c1ee54122d8c0f166af4524c64e92b0795cd43782536a16364a57a948d8cc838R600 isn't explicit enough?",
              "createdAt": "2026-01-23T10:29:10Z",
              "updatedAt": "2026-01-23T10:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cXqDx",
          "commit": {
            "abbreviatedOid": "0b62f08"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T12:04:30Z",
          "updatedAt": "2026-01-23T12:04:40Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "Ah, true I meant `[-1:]` instead of `[:-1]` \ud83d\ude05 will go for indexes, then it should be clearer.",
              "createdAt": "2026-01-23T12:04:30Z",
              "updatedAt": "2026-01-23T12:04:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cXxyz",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T12:14:10Z",
          "updatedAt": "2026-01-23T12:14:10Z",
          "comments": [
            {
              "originalPosition": 567,
              "body": "Ah, right, those would need to be resolved first.",
              "createdAt": "2026-01-23T12:14:10Z",
              "updatedAt": "2026-01-23T12:14:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYfHR",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:10:21Z",
          "updatedAt": "2026-01-23T13:10:21Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "No, don't put the rule in again, that will make it more confusing. As stated before, I'd ideally have a sentence mirroring what is said above about TBDnc but for 113.\r\n\r\nEDIT: seen, you've already added that.",
              "createdAt": "2026-01-23T13:10:21Z",
              "updatedAt": "2026-01-23T13:21:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYf_k",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:11:20Z",
          "updatedAt": "2026-01-23T13:11:21Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "Yes, thats enough, thanks for making it explicit.",
              "createdAt": "2026-01-23T13:11:20Z",
              "updatedAt": "2026-01-23T13:15:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYjEL",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:14:38Z",
          "updatedAt": "2026-01-23T13:14:39Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Minor: something in this sentence is off grammatically. Maybe missing a \"for\".\n\nBut I'd also argue that the whole sentence is mood as in why would I expect another integration tag to be used, if it was not defined to be used above?",
              "createdAt": "2026-01-23T13:14:39Z",
              "updatedAt": "2026-01-23T13:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cY5S9",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:37:35Z",
          "updatedAt": "2026-01-23T13:37:35Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> But I'd also argue that the whole sentence is mood as in why would I expect another integration tag to be used, if it was not defined to be used above?\r\n\r\nThe sentence is required by `-packed`:\r\n\r\n> Application protocol specifications need to be **explicit about which integration tags are in use** [...]\r\n\r\nThe rest I will look into, once I have a physical keyboard under my fingers again. ",
              "createdAt": "2026-01-23T13:37:35Z",
              "updatedAt": "2026-01-23T13:37:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7caRBO",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:43:44Z",
          "updatedAt": "2026-01-23T14:43:44Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Fun, well, good point indeed.",
              "createdAt": "2026-01-23T14:43:44Z",
              "updatedAt": "2026-01-23T14:43:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cjGNq",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2026-01-24T00:20:21Z",
          "updatedAt": "2026-01-24T13:42:34Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Why had it lost `simple(0)` ? Constrained implementations probably will want to save some memory as table _V_ already grows fast.\r\n\r\nUPD: I see a paragraph about it below at line 720 but phrasing is not clear to me.",
              "createdAt": "2026-01-24T00:20:21Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 509,
              "body": "What does `register()`  method of unpacker do?",
              "createdAt": "2026-01-24T13:21:50Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 545,
              "body": "This pseudocode looks more like some existing language which may be unfamiliar to significant part of readers. The pseudocode should be more similar to English prose, prog.language-independent. While `if` and `for` are ubiquitous, `match`/`type_match` are not so.\r\nAlso, it's better to use CBOR types - what is `None` when mapped to CBOR? Is it `null` or `undef`? Probably this line should look like:\r\n`idx: Int or null = null`\r\n\r\nAnd also we call it `map` in CBOR instead of JavaScript's `Object`.",
              "createdAt": "2026-01-24T13:29:10Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 560,
              "body": "What is `content` here?",
              "createdAt": "2026-01-24T13:30:57Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 559,
              "body": "`range` may be different in different programming languages. In pseudocode it is better (less ambiguously) written as:\r\n\r\n`for i := idx to unpacker.packing_table.length inclusive {`\r\n\r\nbecause off-by-one errors are too common.",
              "createdAt": "2026-01-24T13:32:28Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 502,
              "body": "`value` and `content` sound too synonymous. I think better names would be `tag_number` and `tag_content`.",
              "createdAt": "2026-01-24T13:39:12Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 585,
              "body": "What does `extend()` method do?",
              "createdAt": "2026-01-24T13:40:27Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 481,
              "body": "I was unable to grok algorithm in 5 minutes. I'll try again and return if it should be made more \"pseudo\".",
              "createdAt": "2026-01-24T13:42:25Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            }
          ]
        }
      ]
    }
  ]
}
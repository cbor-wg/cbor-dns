{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-02-05T01:11:46.678673+00:00",
  "repo": "cbor-wg/cbor-dns",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOIM0M7M5t8SLz",
      "title": "Represent names as their compontents",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/2",
      "state": "CLOSED",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "During the [mailing list discussions of `-03`](https://mailarchive.ietf.org/arch/msg/cbor/JOHCCBOzC46PrSq-61MMev--mpU/), @chrysn proposed to represent names as their components instead of `tstr`, similar to how it is done in [draft-ietf-core-href](https://datatracker.ietf.org/doc/draft-ietf-core-href/):\r\n\r\n>     host-name   = (*text) ; lowercase, NFC labels\r\n>\r\n>   That is, rather than expressing some.hostname.example.com as `\"some.hostname.example.com\"`, it goes for `\"some\",  \"hostname\", \"example\", \"com\"`\r\n\r\nThere are several advantages to that representation:\r\n\r\n- If not put in their own array, but just verbatim into the arrays already used in the spec, we safe the list specifier, i.e, one byte at least\r\n- Dots (\".\") can be expressed as part of a name component without extra encoding (I don't think that is legal in DNS domain names; @chrysn says they can occur in DNS-SD service names though)\r\n- It would be more in line with how DNS encodes names (delimiter identifies the length of the following name component)\r\n   - This would have the additional advantage that we could use a DNS-like name compression (i.e. an int to refer to an offset in the CBOR binary). The only thing we need to do to make names also encodeable as `uint`s is to swap ttl in RR. This way, the first int in a CBOR array that potentially could contain names always would be identifiable as the name (questions always contain a name, so the first `uint` would just be the name).\r\n\r\nThe only disadvantage we found so far is that there is no straightforward way to use the value or inverted references for names with this... But maybe, if we have DNS-like name compression, this wouldn't be needed anyways.",
      "createdAt": "2023-08-10T06:43:08Z",
      "updatedAt": "2024-11-07T13:25:14Z",
      "closedAt": "2024-11-07T13:25:14Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "MEMBER",
          "body": "> I don't think that is legal in DNS domain names\n\nAIU it is perfectly legal in DNS, it's just that URIs can not (due to their interesting escaping rules) express that dot, not even with percent encoding (maybe punycode though?) -- so it works only where DNS names are never put into a URI.\n",
          "createdAt": "2023-08-10T07:09:28Z",
          "updatedAt": "2023-08-10T07:09:28Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is legal, but strongly discouraged: https://datatracker.ietf.org/doc/html/rfc1035#section-2.3.1",
          "createdAt": "2023-08-10T13:09:20Z",
          "updatedAt": "2023-08-10T13:09:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in the two most recent versions",
          "createdAt": "2024-11-07T13:25:14Z",
          "updatedAt": "2024-11-07T13:25:14Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOIM0M7M5t8Uu5",
      "title": "Pre-populated packing tables",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/3",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@chrysn wrote on the [CBOR mailing list](https://mailarchive.ietf.org/arch/msg/cbor/JOHCCBOzC46PrSq-61MMev--mpU/):\r\n\r\n> Are the packing tables pre-populated with any values? (\"_coap._udp.\"\r\n> and \".com\" would come to mind). If so, is the 1 in `;packed=1`\r\n> intended to serve as an extension point that dispatches the values of\r\n> the table?\r\n\r\nI really like this idea! However, some details need to be ironed out as this could go several (somewhat disjunct) routes:\r\n1. Are these extension points pre-defined tables?\r\n2. Do we use CRIs/URIs to identify and find tables (see e.g. https://datatracker.ietf.org/doc/draft-amsuess-cbor-packed-by-reference/)?\r\n3. Should the extension point be used in a similar manner as SCHC rule IDs, i.e., identify some pre-shared tables?\r\n\r\n1. and 3. don't necessarily contradict each other, as we could reserve number ranges for either pre-defined tables or pre-shared tables? 2. could also be integrated, e.g. with a dedicated number.",
      "createdAt": "2023-08-10T06:51:14Z",
      "updatedAt": "2023-08-10T06:51:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOIM0M7M6i7Am6",
      "title": "hex/EDN examples",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/8",
      "state": "OPEN",
      "author": "chrysn",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From today's interim:\r\n\r\n> @or13: Would be nice to see hex / EDN examples in this section: https://www.ietf.org/archive/id/draft-lenders-dns-cbor-10.html#name-dns-representation-in-cbor-",
      "createdAt": "2024-12-11T16:05:01Z",
      "updatedAt": "2025-10-16T05:33:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Examples are, due to previous decisions made, in [Appendix A](https://www.ietf.org/archive/id/draft-lenders-dns-cbor-14.html#name-examples). There are EDN examples. So, would it suffice to just add hex dumps there as well?",
          "createdAt": "2025-10-15T13:19:43Z",
          "updatedAt": "2025-10-15T13:19:43Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Added binary examples in https://github.com/cbor-wg/cbor-dns/commit/39ee3f7b8b00a75e749a4afa2bd66ad2aa18e007",
          "createdAt": "2025-10-16T05:33:44Z",
          "updatedAt": "2025-10-16T05:33:44Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOIM0M7M6y_aZu",
      "title": "`AAAA` record compression",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/9",
      "state": "OPEN",
      "author": "JeremyRand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello; I'm working with Tor Project on compact DNS zone files for usage in onion service descriptors. This spec caught our attention as potentially relevant. I have a question about how IPv6 addresses are represented.\n\nThe spec mentions:\n\n> Especially IPv6 addresses, e.g., in AAAA resource records can benefit from straight referencing to compress common address prefixes.\n\nHowever, this doesn't (unless I'm misreading) cover compression of individual IPv6 addresses. The example address used in the draft, `2001:db8::1`, uses 16 bytes, but it quite clearly has less entropy than this, as evidenced by the fact that its ASCII notation (certainly not optimal) is only 11 bytes long.\n\nWould there be interest in compression of IPv6 addresses? I did some experiments with real-world zone files, and found that the following algorithm worked pretty well:\n\n1. Convert IPv6 address to ASCII notation.\n2. Remove any redundant colons.\n3. Parse as base17.\n\nMaybe there's a better approach, I'm not sure. Curious what your thoughts are on whether IPv6 address compression is a reasonable thing to include within the scope of CBOR-DNS.\n\nBest regards.",
      "createdAt": "2025-04-17T16:34:16Z",
      "updatedAt": "2025-07-07T20:29:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting!\n\nThe assumption here was that \"hole\"-ey IPv6 addresses (with runs of zeros) mostly occur in manually constructed examples and that real-world IPv6 addresses are mostly filled with entropy.\n\nIs there a way you can provide some example data sets for us to look at?\n\nCBOR-Packed has a few tricks up its sleeve that we might want to use here, but then it does not focus on compression of the content of individual (atomic) data items.",
          "createdAt": "2025-04-17T16:43:23Z",
          "updatedAt": "2025-04-17T16:43:23Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Hi!\n\n> Is there a way you can provide some example data sets for us to look at?\n\nI *think* I can provide the dataset that I was given, but let me double-check to make sure it's OK for me to share it.",
          "createdAt": "2025-04-17T16:50:22Z",
          "updatedAt": "2025-04-17T16:50:22Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "That would be really interesting! I did some cursory analysis back when I was thinking about that, but came to the same conclusion @cabo was mentioning: runs of zeros do not appear as often so that a string conversion\u2014which more than doubles the number of required bytes compared to the binary representation before we even can think about removing stuff\u2014would bring any benefit.",
          "createdAt": "2025-04-22T10:14:17Z",
          "updatedAt": "2025-04-22T10:14:17Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "@JeremyRand: We will have the next CBOR meeting on Wednesday this week, so having some real data that we could chew on and present would help us forward.\n",
          "createdAt": "2025-05-11T16:54:35Z",
          "updatedAt": "2025-05-11T16:54:35Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "I've just emailed you the zone files I was given (please let me know if they failed to arrive). Apologies for the delay.\n\nBased on this dataset, my findings were that the base17 approach I described above yielded a smaller size than the DNS wire format in all but two of the `AAAA` records in the dataset. Which would suggest that a potentially valid approach would be to define the format as \"If the `AAAA` data found in the CBOR is 16 bytes, treat it as DNS wire format, if it's less than 16 bytes, treat it as base17.\"\n\n(The savings aren't exactly massive, but they are significant for space-constrained systems like what we're working with.)",
          "createdAt": "2025-05-12T00:00:18Z",
          "updatedAt": "2025-05-12T00:00:18Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you.  The samples I find are highly skewed towards interface identifiers where only the lowest byte is non-zero; only some 3 % of the AAAA records have more bytes in use.  I don't think that is very typical, but it would be worth looking at this for a larger sample set.\n\nBesides the 97 % with a :: run of 7 bytes, there also may be some advantage from eliding leading zero nibbles in the hexlets -- normally the colon overhead would eat this advantage; but in the sample, 40 % of the hexlets don't have full quads (one would expect maybe 1 out of 16), and the average number of hex digits per quad is 2.92, with 30 % single-digit, so the colon conversion does help -- I'd consider this rather atypical as well.\n\nSo identifying a single run of zero bytes might be a near optimal solution that makes good use of the quirks of your sample data set.\nThis can be given as the start position of the run (0..15, and maybe 16 for no such run), and the length of the run can be derived as 16 minus the number of bytes remaining after removing the run.\nIn your sample, you would save almost 7 out of 16 bytes, minus paying a byte or so for the start position; a whopping 36 %.\n",
          "createdAt": "2025-05-12T04:20:09Z",
          "updatedAt": "2025-05-12T04:20:09Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Thanks for the analysis @cabo!\n\nOf the `AAAA` records in my dataset that exhibit the quirks you noted (I am not sure how typical that is, would indeed be useful to get a larger / more diverse sample), the base17 approach I described yields a compressed size ranging from 7 to 10 bytes, with a mean compressed size of 8.41 bytes, which would be a mean of 47.4% savings for such `AAAA` records.\n\nI'm not purporting that the base17 approach is optimal, but so far I haven't managed to find anything that compresses better for this data.",
          "createdAt": "2025-05-14T06:05:48Z",
          "updatedAt": "2025-05-14T06:05:48Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Starting end of the week I will have some time to run this algorithm over my datasets. \n\n> 2\\. Remove any redundant colons.\n\nJust one question: What exactly do you mean by that? For instance, will `2001:db8::1` become `2001db8::1`, `2001db8:1`, `2001db81`, or something else?",
          "createdAt": "2025-05-14T07:59:07Z",
          "updatedAt": "2025-05-14T07:59:07Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "> > 2. Remove any redundant colons.\n> \n> Just one question: What exactly do you mean by that? For instance, will `2001:db8::1` become `2001db8::1`, `2001db8:1`, `2001db81`, or something else?\n\n@miri64 Remove any colon that immediately follows 4 hex digits (since any such colon is just there for formatting convenience and can be inferred unambiguously). So, for example, `1234::5678:9abc:deff:0:0` becomes `1234:56789abcdeff0:0`. (I didn't carefully think about whether a colon at the start of the string could also be inferred unambiguously, e.g. `::1` becoming `:1`, but that might be workable.)",
          "createdAt": "2025-05-14T08:33:11Z",
          "updatedAt": "2025-05-14T08:33:11Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting! With this transformation, and assuming after conversion the base17-string is stored as a (big) integer we only loose 2 bytes in the worst case (i.e., non of the quad-bytes within the hex representation start with a `0` nibble):\n\n![Results of using AAAA record compression for our datasets](https://github.com/user-attachments/assets/a46aed23-9031-47e6-a200-1f7a0f01c7bb)\n\nI used the IPv6 data from two datasets (both provided as PCAPS), namely the AAAA records and the IPv6hint from SVCB/HTTPS records:\n\n- **IoT:** traces from 3 publically available studies that were conducted in Testbeds with consumer-grade off-the-shelf IoT devices (see e.g. https://github.com/anr-bmbf-pivot/Artifacts-CoNEXT23-DoC/tree/main/03-dns-empirical/collect#scan_iot_datapy for details)\n- **Public:** Queried the names from the [Tranco list](https://tranco-list.eu/) from 3 public resolvers (1.1.1.1, 8.8.8.8, 9.9.9.9; there was no IPv6 available at the site we constructed this list from).\n\nI used this function to convert the IPv6 addresses (provided as full hex strings) to a CBOR integer:\n\n```py\ndef to_base17(addr):\n    addr = ipaddress.IPv6Address(bytes.fromhex(addr)).compressed\n    base17_str = re.sub(\"([0-9a-f]{4}):\", r\"\\1\", addr).replace(\":\", \"a\")\n    return cbor2.dumps(int(base17_str, base=17))\n```\n\nThe reference for the comparsion was the address as CBOR binary string (i.e. to length 17). So byte savings _b_ is\n\n$b = 17 - \\mathbf{length}(\\mathtt{to\\\\_base17}(\\mathtt{addr})))$\n\nand gain _g_ is\n\n$g = \\frac{b}{17}$\n\nThe idea case of this compression is in terms of DNS byte savings of 8 at the moment, when an address just about compresses to an 8-byte integer (9 byte in CBOR). The maximum in our dataset is a byte saving of 14 bytes for the address `::1`, i.e., the loopback address which should not really show up in DNS data. But it does apparently at some public resolver. It converts to the 2-byte integer 3061 (3 byte in CBOR). All other addresses compress to big integers.\n\nAs @cabo already confirmed: Your dataset somewhat skews to the ideal case with byte savings 8:\n\n![Results of using AAAA record compression for Jeremy's dataset](https://github.com/user-attachments/assets/a1a831b9-2e98-4de2-9127-f79dbce35e06)\n\nBut overall I'd say this compression is something that we should think about, but maybe only optionally. This might be even something that could be used generally, especially if the kink with the conversion of `::1` could be ironed out (I think it is as easy as adding the step \"If string starts with colon, remove it\" to the \"remove redundant colons\" step, but did not test if that is easily reversable).",
          "createdAt": "2025-05-19T12:44:14Z",
          "updatedAt": "2025-05-19T12:45:07Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> But overall I'd say this compression is something that we should think about, but maybe only optionally.\n\nSee https://github.com/cbor-wg/cbor-dns/pull/10 for an easy, unintrusive start.",
          "createdAt": "2025-05-19T12:57:08Z",
          "updatedAt": "2025-05-19T12:57:08Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Carsten asked me to provide some additional evaluation. Find them below with both for our datasets.\n\n![Image](https://github.com/user-attachments/assets/9bcaf62a-0828-428f-8267-8cd344957ef7)\n\n- **base17** is the same result as [above](https://github.com/cbor-wg/cbor-dns/issues/9#issuecomment-2890876490),\n- **base17 Improved** additionally removes the colon before the last hex-quad if it is complete and strips the front-colon if the string starts with one\n- **skip max-0 run** finds the longest run of 0-bytes that is longer than 2 bytes within an address, removes it and prepends the offset of that zero run to the address.\n- **skip max-0 run Improved** slightly improves on that by also removing the well-known ff:fe marker at bytes 11..12 that hints that the IID of the address was generated from a MAC48 address, if it is available and toggling the respective bit in the most significant byte of the IID. Since only 266/271889 addresses in our datasets contain this marker, the advantage is not very pronounced.\n\nApart from it perfoming slightly better, we think keeping it in the binary domain with **skip max-0 run** makes more sense for the constrained use case as it can be done without any dependencies, such as IPv6 text representation, base17, or bigint requirements.",
          "createdAt": "2025-05-20T12:03:38Z",
          "updatedAt": "2025-05-20T12:03:38Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Thanks for the analysis @miri64! Yeah this seems reasonable. Given that MAC48 is a privacy leak, and we're working with privacy-focused projects, my preference would be to not do anything in the compression that incentivizes usage of MAC48; it sounds like this matches your preference.",
          "createdAt": "2025-05-25T08:27:24Z",
          "updatedAt": "2025-05-25T08:27:24Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "#10 is now merged and will be part of -14, which allows for extensions of the IP address representation.",
          "createdAt": "2025-07-07T20:29:29Z",
          "updatedAt": "2025-07-07T20:29:51Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOIM0M7M7QId38",
      "title": "Zone files",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/12",
      "state": "OPEN",
      "author": "JeremyRand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi again. We're interested in using this spec for encoding zone files as CBOR. I am aware of C-DNS; the use cases we're working with involve heavily constrained storage and very small zone files (for some environments, we're working with a hard limit of 520 bytes per zone file). This is not far off from the network constraints that your draft is aimed to handle, and my understanding of C-DNS and its overhead is that it is not suitable for such small pieces of data (if you disagree with this assessment, please let me know; it's possible that I'm misunderstanding how C-DNS works).\n\nAs far as I can tell, it should not be very difficult to adapt your spec to handle zone files. I would expect the encoding to look very similar to an array of resource records per Sec 3.2. The main difference I see is in the eliding of resource record entries:\n\n* If the name is elided, it can't be inferred from a question since there is no question for a zone file. I would suggest inferring it from the previous resource record, as is done with standard zone files.\n* If the record type or record class is elided, same issue as above; I would suggest inferring `AAAA` and `IN` as is specified in Sec. 3.3.\n* Eliding the TTL seems useful, as is done with standard zone files; an elided TTL would be inferred to match a previously specified default.\n* I'm not certain of the optimal precedence for eliding things, but in our use cases, the TTL and class would generally be elided a lot more often than the name or the record type. Thoughts?\n* Specifying the default TTL would have to be done... somehow? I'm not sure of the best way to mimic a `$TTL` directive in CBOR. Thoughts?\n\nDo the elision thoughts above make sense? Do you see other tweaks that would be needed to support zone files? Curious what your thoughts are here.",
      "createdAt": "2025-10-07T15:03:29Z",
      "updatedAt": "2026-01-25T01:16:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "> I'm not certain of the optimal precedence for eliding things, but in our use cases, the TTL and class would generally be elided a lot more often than the name or the record type. Thoughts?\n\nPondering this a bit more, the name should always be unambiguous since it's a string, so no precedence rules are necessary for that. Of the other three entries, in our use cases, I'd expect the class to be elided most often, followed by the TTL, with the record type being elided least often.",
          "createdAt": "2025-10-07T15:14:10Z",
          "updatedAt": "2025-10-07T15:14:10Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Not 100% clear, if you mean to provide an alternative route for zone files or want to also change the format for the sent data. In my response, I assume the latter.\n  \n> * If the name is elided, it can't be inferred from a question since there is no question for a zone file. I would suggest inferring it from the previous resource record, as is done with standard zone files.\n\nNot sure this is desirable for sent responses.\n\n> * If the record type or record class is elided, same issue as above; I would suggest inferring `AAAA` and `IN` as is specified in Sec. 3.3.\n\nNeed to think about this some more. Having the elision based on the question makes any RR response smaller (which in general is desirable) while focusing on `AAAA` and `IN` only only provides this advantage only for those records (which by their nature are already quite small and might get also other advantages, see #9).\n\n> * Eliding the TTL seems useful, as is done with standard zone files; an elided TTL would be inferred to match a previously specified default.\n> * I'm not certain of the optimal precedence for eliding things, but in our use cases, the TTL and class would generally be elided a lot more often than the name or the record type. Thoughts?\n> * Specifying the default TTL would have to be done... somehow? I'm not sure of the best way to mimic a $TTL directive in CBOR. Thoughts?\n> [...]\n> Pondering this a bit more, the name should always be unambiguous since it's a string, so no precedence rules are necessary for that. Of the other three entries, in our use cases, I'd expect the class to be elided most often, followed by the TTL, with the record type being elided least often.\n\nThat only seems sensible for zone files to me. Have you looked into storing the zone files using packed in general? This would basically allow for a compression of the TTL and define a \u201edefault\u201c in the packing table.\n\nIn any case, there was some desire to integrate zone files into the format in the past by @TheEnbyperor. Are you both, @JeremyRand and @TheEnbyperor, present in Montreal? Maybe we can discuss this there.",
          "createdAt": "2025-10-08T15:17:26Z",
          "updatedAt": "2025-10-08T15:17:48Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "> Not 100% clear, if you mean to provide an alternative route for zone files or want to also change the format for the sent data. In my response, I assume the latter.\n\nSorry for the confusion, I meant the former, i.e. a different set of elision rules depending on whether the resource records are in the context of a zone file or a sent response.\n\n> In any case, there was some desire to integrate zone files into the format in the past by [@TheEnbyperor](https://github.com/TheEnbyperor). Are you both, [@JeremyRand](https://github.com/JeremyRand) and [@TheEnbyperor](https://github.com/TheEnbyperor), present in Montreal? Maybe we can discuss this there.\n\n@TheEnbyperor and I are colleagues. I'm not able to be in Montreal unfortunately (not sure about Q). If you might be at 39C3 (and if waiting until December is suitable), I'd be happy to meet up there (I think Q will be there too).",
          "createdAt": "2025-10-08T20:09:39Z",
          "updatedAt": "2025-10-08T20:09:39Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> If you might be at 39C3 (and if waiting until December is suitable), I'd be happy to meet up there (I think Q will be there too).\n\nI'm planning to, but as always one can only really say \u201dyes, I will be there\u201c if you have the ticket in your hand :grin:. Then let's try to meet up there.",
          "createdAt": "2025-10-09T05:42:08Z",
          "updatedAt": "2025-10-09T05:42:08Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Hi @JeremyRand, this ticket was mentioned in today's DNS+cbor-packed meeting. While for today zone files questions compression were deferred as there is no format for them defined yet, I have to clarify some points and tell about other work in IETF CBOR WG existing. The main thing here is that there is another CBOR packing proposal exists for a year, not yet in ietf-draft form, but it's main driver to change from simple scheme to something more (in Feb-Mar) was exactly DNS-CBOR needs non-optimal fit in cbor-packed.\n\nThat proposal is called CBAR/CBAPT (and more general CBOR-TPL as language with goals like XSLT, see [non-packing example](https://mailarchive.ietf.org/arch/msg/cbor/q9Mkm89rJi-Q8IHtbnnKowkDHoo/) of it), you may want to look at it - while in early [draft-of-draft/brainstorming mindstream](https://github.com/nuclight/musctp/blob/main/cbar.txt), it potentially allows better ratio than cbor-packed. Some references:\n* https://mailarchive.ietf.org/arch/msg/cbor/GxC5yusExISSUS9tKtrRyeYCTy4/ first sketch\n* [22 Jan 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-02/materials/slides-interim-2025-cbor-02-sessa-vadims-cbar-slides-00.pdf) presentation\n* [2 Apr 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-06/materials/slides-interim-2025-cbor-06-sessa-vadims-cbarcbapt-slides-00) presentation\n* [30 Apr 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-08/materials/slides-interim-2025-cbor-08-sessa-vadims-slides-on-packed-00) presentation\n* [14 May 2025](https://datatracker.ietf.org/meeting/interim-2025-cbor-09/materials/slides-interim-2025-cbor-09-sessa-vadims-slides-on-dnspacked-00) DNS-packed presentation\n\nHere, I need to explain different focus of cbor-packed (and consequently DNS-CBOR in it's current form) and CBAPT. While both can both serve constrained implementations and general ones, they have different focus. First, a \"constrained implementation\" is usually from IoT world with parameters needed, in order:\n1) very limited memory, 10 Kb of RAM was a luxury 10 years ago, typically you have, say, 1 Kb\n2) very limited ROM, which means implementation must be not so big in terms of lines of C code\n3) only then you have small packet sizes of data.\n\nDue to this, cbor-packed (and CBAR subset of CBAPT) focuses on the decoding side on constrained device:\na) data must be accessible _in-place_ **without unpacking via intermediate memory buffers**\nb) it must be relatively simple to implement\n\nThis sacrifices compression effectiveness - cbor-packed (and DNS-CBOR after simple values) consumes more space than it could. And DNS-CBOR name compression is another algorithm, not of generic cbor-packed - we try to marry them together right now to achieve better ratio.\n\nThis means, for you working at Tor which is supposed to run on unconstrained implementations - i.e. no restrictions 1 and 2, no \"MUST\" for (a) and (b) also just wish, only 3 (size) matters but matters very much - current cbor-packed may be not the best fit, so better to look at alternatives, especially when it comes to design of new part of protocol (zone files). Note that CBAPT is more flexible and also comes from censorship-circumventing background (I need it for my muSCTP protocol and apps based on it), it allows for different combinations, e.g. new subformats or two-phase compression - first eliminate redundancy in message, then do `gzip` on it, to not pollute `deflate`'s limited window.\n\nOne of other things I want to add CBOR is tag for tables, which are \"like SQL\" and supposed to be generalization of features of [cbor-records](https://github.com/kriszyp/cbor-records) (you can [see size comparisons](https://gist.github.com/kriszyp/b623b85d2dc25ac9e3b07d8f39df9307) from author), cbor-packed's defaults for maps and [map-like data e.g. duplicated map keys](https://www.ietf.org/archive/id/draft-bormann-cbor-cddl-map-like-data-01.html). See the last part of https://mailarchive.ietf.org/arch/msg/cbor/HSGTVAsoq7xV7rkuG0NkLf1RYOM/ and https://mailarchive.ietf.org/arch/msg/cbor/qGknHigujyj4LTxwJpMfGVXUSUY/\n\nI am talking about this because your suggestion clearly mimics BIND's text zone file format when repeated parts are omitted, but the same approach seems to be generalizable and useful in other table-like data areas (column-oriented DBs are first to remember, while they are far from CBOR by itself, some techniques probably could be borrowed). So we can invent these things here and later augment DNS-CBOR with different \"backend\" for packing beyond built-in name compression, where cbor-packed is currently the only one (one can note that DNS-CBOR is not very tied to cbor-packed, it just uses it's registered tags but self-contained otherwise). For example, I did a [try for IPv6 addresses compression](https://mailarchive.ietf.org/arch/msg/cbor/LJrOjmmE8h0RQeoLZ6vPZ06ctkg/) in CBAR for cases like zero and in the middle, which cbor-packed does not handle well.",
          "createdAt": "2026-01-15T22:47:44Z",
          "updatedAt": "2026-01-15T22:47:44Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Reading about [C-DNS](https://datatracker.ietf.org/doc/html/rfc8618), yes, it is not assumed to be used on such small data. However, some of it's techniques can be utilized for small zone files, like referencing tables or IP prefixes. However, this is not much different from cbor-packed), so yet to be thought. Let's begin from a preprocessing step after which usual name compression applied (and possibly cbor-packed or CBAPT).\n\nGiven that zone file is table with just few fixed columns, we can apply column-oriented to part of it wit run-length encoding:\n* class and TTL columns are taken out from individual RRs entirely\n* zone data is prepended with `[ ? $ORIGIN, [classes], [TTLs]]`\n   - `$ORIGIN`, if present, serves to ensure this label always gets low number in _V_ table so would be referenced by one byte, just as `@` in traditional text format\n* Both `classes` and `TTLs` arrays have run-length encoding of corresponding column:\n   - uint: number itself\n   - negative integer: minus how many times previous field was repeated\n   - truncated array mean repeating last element as many times as necessary\n\nFor example, in fragment like\n```\n...   3600  IN  ...\n...   3600  IN  ...\n...   3600  IN  ...\n...   3600  IN  ...\n...     60  IN  ...\n...   3600  IN  ...\n...   3600  IN  ...\n...   3600  CH  ...\n...   3600  HS  ...\n...   3600  IN  ...\n...    600  IN  ...\n...    600  IN  ...\n```\nthese can be `[3600, -3, 60, 3600, -4, 600], [1, -6, 3, 4, 1]`.\n\nNote that RR type is problematic to such technique because it introduces ambiguity in some cases: in\n`[\"foo\", \"bar\", \"ns2\", simple(4)]`\nwhere NAME stops and DATA begins? Human can deduce from \"ns2\" that it is probably\n`foo.bar   IN NS  ns2.example.com`\nbut what to do in algorithm?..\nOf course name could be always FQDN so ending with `simple(N)` of `6(N)` reference, but that would not utilize relative names possible even in a text zone file, and will spend a byte anyway.",
          "createdAt": "2026-01-17T19:54:33Z",
          "updatedAt": "2026-01-17T19:54:33Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "I'd record here some other ideas came to me for the week passed.\n\nFirst, about `$ORIGIN` and `$TTL`. Note that current DNS-CBOR format describes root label as empty string but omits it it for compactness. While someone can say it is non-conformant, actually this could be used for zone files: we just declare that by default `$ORIGIN` is `\"\"` and elided, that is, current format is particular case, where all labels are added `$ORIGIN` at end (after expansion from _V_) becoming absolute names for typical queries/responses. And we augment format with:\n```\norigin-defttl = (\n   domain-name .default \"\",\n   ? ttl\n)\n```\nadding `? origin-defttl` between `? flags,` and `? question-section,`. Note that this also could be used not in zone files but usual responses where all names are under same domain - it will save one byte for `simple(N)` in each RR.\n\nThen, alternative compression encodings... observe that DNS-CBOR uses original binary format for RDATA  if it is shorter than CBOR version - that is, parser for original format must be included anyway even on constrained implementation. Also note that CBAR is just one bstr format in CBAPT, but others are possible and encouraged - so we can create modified format for original DNS format with e.g. bitmap of which fields are elided or shorter! And this can try achieve additional compactness\nbecause e.g. TTL in DNS-CBOR always has 1-byte overhead (0x18-0x1A).\n\nA small interlude with explanation of data models (much discussed in CBOR WG ML last months) must be said here. Observe that from \"purist\" CBOR view every data type must be explicit - i.e. register a tag for label, a tag for RR, a tag for RFC 1035's `<character-string>` (because e.g. `HINFO` uses them *not* as concatenation and was unobsoleted by Cloudflare), and so on. It is just we omit all that for the goal of compact representation, but implicitly - in application data structures - we have them anyway. This means, we can define alternative encodings for DNS-CBOR, better suited for your use cases, as long as we can provide lossless conversion to (and back from) CBOR. And CBAPT (CBOR-TPL) is all about such things.\n\nSo it could like e.g.\n`10(['nc', 'atom1', 'atom2', \"foo\", 3600, bstr-rump])`\nwith possibly tag and and function omitted by media type for your 520 bytes, and the bstring contains encodings better suited for DNS than CBOR (e.g. `\"awseb-e-t-awsebloa-9999999999\"` example from mentioned ticket is longer than 23 so has overhead, bstr can't be longer 64k), however made in a way that stream parser of it can return CBOR items to your API. \nSo our type byte must encode not only elision of type/class/TTL at record start, but other things also, including \"repeat  previous name/type/class/TTL\" (instead of `rrset=true)`,   and '[' and ']' and label start and may be even several 4-byte fields (for SOA) if we'll have enough codepoint space; need type for `<character-string>` (alas not set of: HINFO consists of exactly two distinct and unobsoleted by RFC 8482) and generic RDLENGTH/RDATA (as new types format is not always known), look if need hack for `OPT (#6.141)` or can go without it, and probably need escape to general CBOR item. Because we work on zone files, we can bring back some constructs from it also, such as `@`.\n\n```\n      0               \n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |0 0|LabelLength| as in classic DNS\n     +-+-+-+-+-+-+-+-+\n\n      0               \n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |0 1|0 0|0 0 0 0| '@' special label, literally \n     +-+-+-+-+-+-+-+-+\n\n      0               \n      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+\n     |0 1 0| ArrSize | repeat previous Name/Class/TTL here, instead of rrset=true\n     +-+-+-+-+-+-+-+-+\n```\nHere, codes 65-86 are the same as usual array open but denote it is RR with RDATA only, and it can be 1-22 items (not zero!) and 87 (0x57) is for \"indefinite-array start\".\n\nCodes 0x58-0x5f are for special \"compressed short bstr\", low bits denoting unpacked length:\n|val | bytes\n|---|---\n|  0 | 6\n|  1 | 8\n|  2 | 10\n|  3 | 12\n|  4 | 14\n|  5 | 16\n|  6 | 18\n|  7 | 20\n\n* 0x60-0x7f is treated as unsigned integer from CBOR (just shifted because label occupied 0x00-0x1f).\n* 0x80-0x8f is same as in CBOR - array.\n* 0xA0-0xBf: non-label bstr 0-29 bytes, 30=1 byte len, 31=2 bytes len\n* 0xC0-0xCF: sequence of 1 to 16 <character-string> follows\n* 0xD0-0xF3: Label Reference in _V_ 0..35\n* 0xF4-0xF7: false/true/null/undefined\n* 0xf8: 1 byte reference in _V_ follows,\n* 0xf9: 2 bytes reference in _V_ follows\n* 0xfA: 4 byte  reference in _V_ follows\n* 0xFB: escape to single CBOR item, possibly tagged and/or structural (e.g. map)\n* atoms as in CBAR\n* 0xff indefinite terminator as in CBOR\n\nImportant: we have **distinct** reference space here, one for _V_ and one for atoms. This eliminates problem with _V_ growing too fast for cbor-packed so references become fat too early.\n\nMost interesting here is special \"compressed short bstr\". It is intended as efficiency hack for 3 cases:\n1.  instead of `ttl, record-type, record-class` sequence\n2. compressing runs of zeroes in IPv6 addresses\n3. five integers in SOA record - a chance for less overhead when having label sequences\n\nWhen it terminates label sequence for `domain-name`, it is 6 or 8 bytes (in former case `record-class` is elided as in DNS-CBOR), like wire representation, but reordered to match DNS-CBOR: TTL then Type then Class. As before, it is used only if resulting representation is shorter.\n\nNow, how this compressed short string may be encoded? I have several variants. Don't know which is better - probably need tests against large sets of data.\n\nFirst is VarNibbles from muSCTP: chunks of nibbles in format:\n* bitmap nibble - 1 for RLE, 0 for just zero\n* non-zero nibbles are copied as-is\n* if nibble is zero, then next bit in bitmap is consulted - if it is 1, then after this zero nibble follows nibble with how many times to repeat that nibble\n\nFor example, let's encode OPT (untagged version) like it is in classic DNS (excerpts from RFC 6891 below), but in our format it is rearranged payload size is passed minus 512, i.e. 0 if it is 512 (because :\n\n```\n       | TYPE       | u_int16_t    | OPT (41)                     |\n       | CLASS      | u_int16_t    | requestor's UDP payload size |\n       | TTL        | u_int32_t    | extended RCODE and flags     |\n\nso with TTL being first and our rearrangement it is\n\n                  +0 (MSB)                            +1 (LSB)\n       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    0: |         EXTENDED-RCODE        |            VERSION            |\n       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    2: | DO|                           Z                               |\n       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    4: |                                                         2   9 | TYPE\n       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    6: |                               Z                               | CLASS\n       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n```\nSo with flag  DO=1 (and 41=0x29) we have nibbles (`<size>` denotes repeat):\n\n`\"\" 0x5a 0b1100 0 <4> 8 0 <5> 2 9 = 6 bytes total`\n\n(the cheat here to cut class as it is zeroes and pass 6 bytes instead of 8).\n\nThere is possible addition here: permutation before VarNibbles: first lowest nibbles of every int, then second low, third, and highest ones, so the tail likely will have many zeroes combined, but requires storing original size and same width for all integers. But this may have bad impact for IPv6 address so need a flag...\n\nYet another idea is Bitmap Ranges (muSCTP but simplified): view as bitstring and have:\n```\n      0                   0                   0               \n      0 1 2 3 4 5 6 7     0 1 2 3 4 5 6 7     0 1 2 3 4 5 6 7 \n     +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+\n     |0|   Bitmap    |   |1 0|   N 0's   |   |1 1|   N 1's   |\n     +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+\n```\nwhere \"bitmap\" are seven bits copied as-is if there are too many alternating, and other are RLE counts of long runs of 0's or 1's. Could be optimized to seven bits: just N<96 for zeroes and N-96 for up to 32 ones.\n\n---\nLastly, crazy idea of yet another overall compression format: have original DNS wire format and intersperse it with instruction bytes in LZ4/RLE style, taking Bitmap Ranges idea, but make two-bit for RLE: run of zero bytes, run of literal bytes, an atom (or several atoms in a row), a reference to table _V_ (how many in run of them? at most 2?), and a variant like \"0|Bitmap\" for just few of them alternating; atoms/references are VarUInt30 in the stream, and probably don't need to pull entire bitmap at start - just opcode byte as in LZ-family; like in C-DNS we can predefine common type/class combinations into _V_; Pyramint6 could be simplified to 0..51 and then in 16-units:\n```\n   110011 - 51\n   110100 - 64  = 4*16\n   110101 - 80  = 5*16\n   ...\n   111111 - 240 = 15 *16\n\nTBD how many codepoints for each\n```\nI'll finish it here now in not very explained form because GitHub interface becomes more and more slow while I typing it...",
          "createdAt": "2026-01-25T01:16:24Z",
          "updatedAt": "2026-01-25T01:16:24Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOIM0M7M7dtFED",
      "title": "Change nesting of 113 and TBD28259 to avoid need of tag content equivalence",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/13",
      "state": "OPEN",
      "author": "mguetschow",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Figure 17 currently reads\n\n```\n   TBD113(\n     TBD28259(\n       [\n         [\"org\", 42],\n         [\n           \"www\", \"example\", simple(5) / expands to \"org\" /,\n           [\"svc\", simple(0) / expands to \"www\", \"example\", \"org\" /],\n           simple(5),  / expands to \"org\" /\n           simple(1),  / expands to \"www\", \"example\", \"org\" /\n           simple(6),  / expands to 42 /\n           simple(3),  / expands to \"svc\", \"www\", \"example\", \"org\" /\n           simple(6)   / expands to 42 /\n         ]\n       ]\n     )\n   )\n```\n\nI think it should rather be\n\n```\n   TBD113(\n     [\n       [\"org\", 42],\n       TBD28259(\n         [\n           \"www\", \"example\", simple(5) / expands to \"org\" /,\n           [\"svc\", simple(0) / expands to \"www\", \"example\", \"org\" /],\n           simple(5),  / expands to \"org\" /\n           simple(1),  / expands to \"www\", \"example\", \"org\" /\n           simple(6),  / expands to 42 /\n           simple(3),  / expands to \"svc\", \"www\", \"example\", \"org\" /\n           simple(6)   / expands to 42 /\n         ]\n       )\n     ]\n   )\n```\n\nThis would avoid the need for defining [tag equivalence](https://www.ietf.org/archive/id/draft-ietf-cbor-packed-17.html#name-tag-equivalence) of TBD28259 (in some circumstances) with the 2-element array expected by 113, or a change to the semantics of 113.\n\nThe overall number of bytes is unchanged, but some explanatory wording is needed, especially when TBD28259 is implicitly injected by the media type (\"as enclosing the rump of the outer-most item which should be tag 113\").",
      "createdAt": "2025-12-11T14:14:35Z",
      "updatedAt": "2026-01-27T09:34:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "As discussed in today's meeting, we probably should change the definition of TBD28259 and/or register yet another tag when nesting is allowed, so that for the common case tag TBD113 is not needed at all and thus reason for this ticket's problem is eliminated. This is also justified by today's conclusion of changing the common case working from prepending _V_ table to appending it to \"normal\" -packed's table. When later another level of nesting is added (possible solution for #12 zone files which format is not yet invented), another tag can accomodate this.\n\nThat is depicted below by `TBDnc()` and `TBDnc2()`, roughly corresponding to `?packed=1` and possible `?packed=2` media types.\n\n---\nAdapted meeting's shared notes:\n\nUse case:\n    \n* constrained device is consumer of DNS _response_\n\t* DNS+cbor _requests_ do not allow use packing level 1 (only simple name compression)\n* Nice-to-have: also make responses useful for high-performance applications\n\t* zone files may be interesting for Tor, see https://github.com/cbor-wg/cbor-dns/issues/12\n\n(Note that in the constrained use case, the DNS *server* may be a high-performance application, but does have the resources to accept more complexity)\n\nMulti-pass approaches are complicated and consume more resources (in the constrained use case, the more constrained side is the consumer)\n- we want single-pass decoder on constrained side (Goal: do not require multiple passes in the consumer)\n- so constrain embedded table setup inside the region governed by implicit table setup (which, using tag 113/1113, would use prepending again) -- use case: zone files transported via RR\n\n*Appending* table entries in the implicit phase keeps the reference numbers stable during implicit table building\n\nAny nested table-building tags in the input to the implicit table building creates complexity.\nDo we need that complexity?\n\nIdea: pruning by bitmap of unused references to bring back to single-byte `simple(0..15)` from fat `6(N)` references\nAssumption: Pruning takes more space than just leaving the entry in (a sequence of unused entries might expand a reference by one byte)\n\n**Slide 4**:\n<img width=\"1250\" height=\"618\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/3f19431e-e679-4f78-80ed-85411ae99fd1\" />\nRR from example large number of labels (Amazon):\n\n         TTL (60), RRtype CNAME (5), name\n         name, TTL (60), RRtype CNAME (5), name\n         name, TTL (9), RRtype A (1), IP address\n         name, TTL (403), RRtype NS (2), name\n\n(maybe add some EDN extension for DNS+CBOR RRtypes)\n\n**Slide 3**: \"unresolved references\" is about table entries not yet known at the time they would need to be processed in a single-pass (linear) processor.\nWe want to avoid that.\n(Example: Slide 2, `simple(5)` is not yet defined at the  time that `simple(5)` is first encountered)\n\n```\npacked=0:\n    [just rump] // implies TBDnc tag\n\npacked=1: // implies TBNnc within 113\n    [ / implies use of 113 /\n        setup,\n        rump  // implies TBDnc tag, no nested 113/1113 allowed\n    ]\n\npacked=2:\nTBDnc2([  # name compression setup tag\n    [\"prepended\" /becomes simple(0)/, \"table\" /becomes simple(1)/],\n    [ / rump: Here we now we are appending, starting at simple(2) /\n    ...,\n      113([[table entries prepended to outer\n            prepend table followed by implicitly\n            added entries \u2794 build inner table], [rump]), / optional - for zones /\n    ]\n    ])\n```\n\n`packed=1` could disallow this nesting\nactually, `TBDnc` could disallow nested table setup tags\n\n(`packed=2` might allow that nesting; need to define the use case first)\n\nDiscussion in issue #12 \n\n[We need a registry for packed= values.  We use 0 and 1 now.]\n\n\u2794 Go for appending implicitly derived reference entries\n\u2794 Do not allow setup tags nested into the implicit setup, for packed=0/packed=1 (open to be defined in packed\u22652)",
          "createdAt": "2026-01-15T21:57:42Z",
          "updatedAt": "2026-01-15T21:57:42Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> As discussed in today's meeting, we probably should change the definition of TBD28259 and/or register yet another tag when nesting is allowed, so that for the common case tag TBD113 is not needed at all and thus reason for this ticket's problem is eliminated.\n\nI think there is a slight confusion here: The goal of this ticket is fixing the order of the (implicit, aka not-sent-on-the-wire) TBD28259 and TBD113 in case `packed=1`. So TBD113 is \"needed\" as an (implicit) outer table setup.\n\nBut we indeed discussed disallowing nested (_inner_, and thereby explicit) occurrences of TBD113/TBD1113 inside TBD28259.",
          "createdAt": "2026-01-16T09:31:57Z",
          "updatedAt": "2026-01-16T09:31:57Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> I think there is a slight confusion here: The goal of this ticket is fixing the order of the (implicit, aka not-sent-on-the-wire) TBD28259 and TBD113 in case `packed=1`. So TBD113 is \"needed\" as an (implicit) outer table setup.\n\nReally? I thought Figure 17 was about using combination of tags in explicit form... Implicit in `packed=1` should be different Figure, then - because implicit form can go further beyond simple \"tag stripped\" and potentially re-arrange data.\n\n> But we indeed discussed disallowing nested (_inner_, and thereby explicit) occurrences of TBD113/TBD1113 inside TBD28259.\n\nI think we discussed changing TBD28259 in a way that it (under `packed=1`) don't need TBD113/TBD1113 now (taking it's functions to itself) due to \"appending vs prepending\" issue.",
          "createdAt": "2026-01-16T17:05:06Z",
          "updatedAt": "2026-01-16T17:05:06Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "Is the description in https://github.com/cbor-wg/cbor-dns/pull/16/changes#diff-c1ee54122d8c0f166af4524c64e92b0795cd43782536a16364a57a948d8cc838R795-R823 clear enough? Merging that PR could then close this issue.",
          "createdAt": "2026-01-26T13:08:58Z",
          "updatedAt": "2026-01-26T13:08:58Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "I thought we discussed changing TBD28259 definition to be that _instead_ of using TBD113, so interaction between 113 and 28259 is not quite clearly depicted in that range of lines.\n\nBut yes, that merging PR (after changes) should close this issue.",
          "createdAt": "2026-01-26T19:16:09Z",
          "updatedAt": "2026-01-26T19:16:09Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> I thought we discussed changing TBD28259 definition to be that _instead_ of using TBD113\n\nYes, TBD113 (same as TBD28259) SHOULD be omitted on the wire. But @miri64 didn't want to disallow explicitly sending it even if it adds unnecessary byte overhead to avoid extra round-trips. That's why an encoder MUST NOT discard the payload for `packed=1` even if either or both of TBD28259 and TBD113 are explicitly present.",
          "createdAt": "2026-01-27T09:34:10Z",
          "updatedAt": "2026-01-27T09:34:10Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOIM0M7M7nJUtO",
      "title": "`$ORIGIN` and (non-)absolute names (also `$TTL`)",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/17",
      "state": "OPEN",
      "author": "nuclight",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In #12 there was expressed need in zone files support. While exact format for those may be out of scope for current version of document, it was discovered, especially while in discussion in #14 of possible new EDN app-literals, that current version is under-worked about absolute (FQDN) and relative labels - e.g. such difference could be represented by hypothetical `dns'some.label'` vs `dns'some.label.'` - note the dot at end. That is, Section 3.1 in -15 version of draft states\n> The root domain `\".\"` is represented as an empty string `\"\"`\n\nbut later root domain's label, which in standard DNS ends each name in queries and responses, is silently omitted without clarifications. While intent for saving 1 byte per RR is easily guessed, this is still not 100% correct.\n\nHowever, there is simple way to \"fix\" it by really not changing nothing in main apart and at the same time gain (at least some) support for zone files. The solution (sketched in #12) is to augment CDDL: we just declare that by default `$ORIGIN` is `\"\"` and elided, that is, current format is special/particular case, where all labels are added `$ORIGIN` at end (after expansion from _V_) becoming absolute names for typical queries/responses. And we augment format with:\n```\norigin-defttl = (\n   domain-name .default \"\",\n   ? ttl\n)\n```\nadding `? origin-defttl` between `? flags`, and `? question-section,` (so it is usable in question also, see below).\n\nImportant: this also could be used not in zone files but usual responses where all names are under same domain - it will save one byte for `simple(N)` in each RR; while origin's label are not occupying rows in _V_ at all.\n\nP.S. In principle, zone files may be represented as simple as \"answer\" with `AXFR` in question section, but may be such definition is premature...",
      "createdAt": "2026-01-31T00:36:04Z",
      "updatedAt": "2026-02-03T10:17:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "In general: I would say, if this is only important for zone files, we should wait until there is actually a format and if it will be the same as `rr` currently is.\n\n> but later root domain's label, which in standard DNS ends each name in queries and responses, is silently omitted without clarifications. While intent for saving 1 byte per RR is easily guessed, this is still not 100% correct.\n\nWhat do you mean by \"later\"? The root domain is AFAIK only important in RRs for special RRs such as OPT (where it is omitted) or SVCB (where there is [information on that](https://www.ietf.org/archive/id/draft-lenders-dns-cbor-15.html#section-3.2.1.4-4)). Can you please be specific? \n\n> adding `? origin-defttl` between `? flags`, and `? question-section,` (so it is usable in question also, see below).\n\nI am not quite sure I understand. This would put `origin-defttl` and thus a TTL on the main level, i.e. on the same level as the sections. The TTL, however, is part of a resource record or resource record set within those sections.\n\n```\n$$dns-rr = rr / #6.141(opt-rr) / bstr\n\n...\n\nrr = [\n  ? domain-name,\n  ttl: ttl,\n  type-spec-rdata,\n]\ntype-spec-rdata = (\n  ? type-spec,\n  rdata: bstr // ( $ip-addr ) // ( domain-name ) // ( rdata-set ),\n)\nrdata-set = ((\n  is-rrset: true,\n  rdata-set: [ +bstr ]\n) // (\n  is-rrset: true,\n  rdata-set: [ +[ domain-name ] ],\n))\n\n...\n\nanswer-section = [+ $$dns-rr]\nextra-sections = (\n  ? authority: [+ $$dns-rr],\n  additional: [+ $$dns-rr],\n)\n```\n\n> Important: this also could be used not in zone files but usual responses where all names are under same domain - it will save one byte for `simple(N)` in each RR; while origin's label are not occupying rows in _V_ at all.\n\nI'd argue eliding (i.e. not repeating)  the name in the question, which is potentially longer, is far more byte saving than eliding `\".\"` (2 bytes).",
          "createdAt": "2026-02-02T11:48:24Z",
          "updatedAt": "2026-02-02T11:48:24Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> In general: I would say, if this is only important for zone files, we should wait until there is actually a format and if it will be the same as `rr` currently is.\n> \n> > but later root domain's label, which in standard DNS ends each name in queries and responses, is silently omitted without clarifications. While intent for saving 1 byte per RR is easily guessed, this is still not 100% correct.\n> \n> What do you mean by \"later\"? \n\nLater by document text.\n\n> The root domain is AFAIK only important in RRs for special RRs such as OPT (where it is omitted) or SVCB (where there is [information on that](https://www.ietf.org/archive/id/draft-lenders-dns-cbor-15.html#section-3.2.1.4-4)). Can you please be specific?\n\nIn original DNS wire format, we always have root label to end sequence of domain-name labels. In zone master files, however, name could be absolute - with root's dot at end - or relative. When in some future we will support `dns'ns1.domain.com'` this makes ambiguity versus `dns'ns1.domain.com.'` - and people will find it confusing. But required presence of root label in wire format - and lack in DNS-CBOR - could be generalized for some benefits, see example below.\n\n> > adding `? origin-defttl` between `? flags`, and `? question-section,` (so it is usable in question also, see below).\n> \n> I am not quite sure I understand. This would put `origin-defttl` and thus a TTL on the main level, i.e. on the same level as the sections. The TTL, however, is part of a resource record or resource record set within those sections.\n\nThis is `$TTL` of master files, not RR's TTL. Well, we can omit it for now, just that I thought reserving this in CDDL for future use might be a good thing.\n\n> ```\n> ...\n> \n> answer-section = [+ $$dns-rr]\n> extra-sections = (\n>   ? authority: [+ $$dns-rr],\n>   additional: [+ $$dns-rr],\n> )\n> ```\n\nYep, it's only usable in responses, but better even before (repeated) question section.\n\n> > Important: this also could be used not in zone files but usual responses where all names are under same domain - it will save one byte for `simple(N)` in each RR; while origin's label are not occupying rows in _V_ at all.\n> \n> I'd argue eliding (i.e. not repeating) the name in the question, which is potentially longer, is far more byte saving than eliding `\".\"` (2 bytes).\n\nConsider the following example: client makes query for `hostel-a.campus.univ.edu.` and returned response contains several RRs which all will end in `campus.univ.edu.` - `mail`, `ns1`, `ns2`, `ns1.hostel-a`, `ns2.hostel-a`, `mail.hostel-a` and so on. Current form of name compression will:\n\n1) occupy three entries in _V_ for `campus.univ.edu.`\n2) every direct name under it will end in `simple(3)` - `\"mail\", simple(3)` and `\"ns1\", simple(3)` and `\"ns1\", simple(0)` etc.\n\nIf, instead, `campus.univ.edu.` would be specified on top level as `$ORIGIN`, then question would be just `[\"hostel-a\", dns'ANY']` and answer/authority could have just `\"mail\"` instead of `\"mail\", simple(3)` (`\"ns1\", simple(0)` unchanged) etc.\n*Just like every name was under root domain instead.*\nThis trick allows not only to support master files, but also to save several bytes in regular DNS responses consisting of multiple records under same subtree.",
          "createdAt": "2026-02-02T23:41:36Z",
          "updatedAt": "2026-02-02T23:41:36Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> In original DNS wire format, we always have root label to end sequence of domain-name labels.\n\nThat's one way to read the `\\0`. The other is that it is just a marker to end the sequence of name labels.\n\n> When in some future we will support `dns'ns1.domain.com'` this makes ambiguity versus `dns'ns1.domain.com.'` - and people will find it confusing.\n\nI think adding relative domain names to a format (DNS messages) that did not previously had it is confusing. So why should we support a relative `ns1.domain.com`?\n\nBTW, I welcome this discussion, because I had my doubts if it makes sense to integrate zone files into the format. This discussion (and potentially inner packing tables with `AXFR` records) seem to confirm my doubts.\n\n> [!NOTE]\n> > 2\\. every direct name under it will end in `simple(3)` - `\"mail\", simple(3)` and `\"ns1\", simple(3)` and `\"ns1\", simple(0)` etc.\n> \n> Not discussing the concept here, rather than your understanding of name compression (that's why I marked it as a Note annotation): why `simple(3)`? If the names appear in the order you lined out in\n> \n> > Consider the following example: client makes query for `hostel-a.campus.univ.edu.` and returned response contains several RRs which all will end in `campus.univ.edu.` - `mail`, `ns1`, `ns2`, `ns1.hostel-a`, `ns2.hostel-a`, `mail.hostel-a` and so on. \n> \n> _V_ will look like\n> \n> ```py\n> [\n>   /0:/ 1115([\"hostel-a\", \"campus\", \"univ\", \"edu\"]),\n>   /1:/ 1115([\"campus\", \"univ\", \"edu\"]),\n>   /2:/ 1115([\"univ\", \"edu\"]),\n>   /3:/ 1115([\"edu\"]),\n>   /4:/ 1115([\"mail\", single(1)]),\n>   /5:/ 1115([\"ns1\", single(1)]),\n>   /6:/ 1115([\"ns2\", single(1)]),\n>   /7:/ 1115([\"ns1\", single(0)]),\n>   /8:/ 1115([\"ns2\", single(0)]),\n>   /9:/ 1115([\"mail\", single(0)]),\n> ]\n> ```\n> \n> So it should be `simple(1)`. `simple(3)` would go to `edu.`.\n> ",
          "createdAt": "2026-02-03T10:17:48Z",
          "updatedAt": "2026-02-03T10:17:48Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOIM0M7M5XhDHB",
      "title": "Housekeeping",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/1",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-09T09:42:28Z",
      "updatedAt": "2023-08-09T15:46:09Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "6cb47d2b12a94d796511ad6f6bf4307a97af763b",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "housekeeping",
      "headRefOid": "36641398835e9837e8e5b77505dc30315414a8ba",
      "closedAt": "2023-08-09T15:46:01Z",
      "mergedAt": "2023-08-09T15:46:01Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "644f574a21471839d731eb87b596c8cb6542615d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M5dk3pl",
          "commit": {
            "abbreviatedOid": "3664139"
          },
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2023-08-09T15:45:46Z",
          "updatedAt": "2023-08-09T15:45:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOIM0M7M5co-6G",
      "title": "Create comparison table",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/4",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In https://mailarchive.ietf.org/arch/msg/cbor/KzRTl9QqtCiyMb4wYG_U542hjV0/ a comparison table was requested. This is a first draft for that.",
      "createdAt": "2023-10-12T14:20:44Z",
      "updatedAt": "2024-06-28T12:26:21Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "69b762130904ca9448679640a46f26f5d3c0781a",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "comparison-table",
      "headRefOid": "e2f6053399243ac2a99b83e7c35f727cecef427d",
      "closedAt": "2024-06-28T12:26:14Z",
      "mergedAt": "2024-06-28T12:26:14Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "b1a8e7557d6f1037094bec82f2baead42f227cd9"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I reworked the table according to an offline proposal by @cabo. Currently, I use an XML-table, since it does not seem to be possible with kramdown to have a two row header with row span, e.g., like this \r\n\r\n```markdown\r\n|----------|-----------------------------------------------|\r\n| Item     | RFC 1035 | application/dns+cbor [bytes]       |\r\n|          | format   | best    | realistic  | theoretical |\r\n|          | [bytes]  |         | worst      | worst       |\r\n|----------|---------:|--------:|-----------:|------------:|\r\n| Header   | 4        | 1       | 4          | 4           |\r\n|----------|----------|---------|------------|-------------|\r\n```\r\n\r\nIt renders somewhat correct but the table head rows are rendered incorrect:\r\n\r\n![image](https://github.com/anr-bmbf-pivot/draft-lenders-dns-cbor/assets/675644/61dd4e62-e252-459f-843c-c92547541444)\r\n\r\nbut I would interpret the kramdown doc differently\r\n\r\n> The first separator line after at least one table row is treated specially, namely as header separator line. It is used to demarcate header rows from normal table rows and/or to set column alignments. All table rows above the header separator line are considered to be header rows.\r\n\r\n(though this could be a local problem, as the Arch Linux kramdown package [wasn't updated in ages](https://archlinux.org/packages/extra/any/ruby-kramdown/), though there seems to be finally movement [in staging](https://archlinux.org/packages/extra-staging/any/ruby-kramdown/))",
          "createdAt": "2024-06-17T15:04:33Z",
          "updatedAt": "2024-06-17T15:04:33Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And yet another iteration. This time, I put the key for the CBOR format configuration into a separate table. I think this is the most readable version so far.",
          "createdAt": "2024-06-26T16:15:17Z",
          "updatedAt": "2024-06-26T16:15:17Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For reference: https://anr-bmbf-pivot.github.io/draft-lenders-dns-cbor/comparison-table/draft-lenders-dns-cbor.html#name-comparison-to-wire-format",
          "createdAt": "2024-06-26T16:16:39Z",
          "updatedAt": "2024-06-26T16:16:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOIM0M7M5v4eY-",
      "title": "Various changes from cabo for -07",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/5",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-19T08:47:45Z",
      "updatedAt": "2024-05-19T09:29:25Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "5454047df2e957cf9c47ae222c980be68d7509a8",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "cabo-07",
      "headRefOid": "964b1bc072385190075b10d0a0c4193322767479",
      "closedAt": "2024-05-19T09:29:12Z",
      "mergedAt": "2024-05-19T09:29:12Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "9fe12b3e5430cd3dfa9d8a4abbb312654960228a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M57Fe9F",
          "commit": {
            "abbreviatedOid": "964b1bc"
          },
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-19T09:29:04Z",
          "updatedAt": "2024-05-19T09:29:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOIM0M7M6BK_Fj",
      "title": "Add capability to summarize rrsets",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/6",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The capability to summarize resource records set was discussed in the past, but I stayed away from it so far, as it adds additional overhead. Well, we add overhead already, so lets add more overhead (but less that the overhead than duplicating TTL and type ;-)) to maybe still have it. This is my proposal to how to optionally provide summarized resource record sets.\r\n\r\nMaybe the CDDL can be streamlined, but at the moment, I don't see how.",
      "createdAt": "2024-11-07T11:05:10Z",
      "updatedAt": "2025-07-07T20:08:58Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "8e7957afb85235f33056f94db03e9eae655760a1",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "rrsets",
      "headRefOid": "5e8db6e1f7d4ec269f1dc26f758ae39a79701afc",
      "closedAt": "2025-07-07T20:08:51Z",
      "mergedAt": "2025-07-07T20:08:51Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "a2e5700fdab8017d9be8088f57c615de8270146f"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe the CDDL can be streamlined, but at the moment, I don't see how.\r\n\r\n@cabo any idea? Currently, even the CDDL checking tool is not even able to parse this properly, the offending line is https://github.com/cbor-wg/cbor-dns/blob/d0705dbe935cd7d7f628218ef6a149e30aa22e39/draft-lenders-dns-cbor.md?plain=1#L335",
          "createdAt": "2025-07-07T11:32:41Z",
          "updatedAt": "2025-07-07T11:32:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOIM0M7M6BVOlO",
      "title": "Make name compression be based on CBOR-packed",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/7",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During IETF 121 the idea came up to bring name compression to CBOR-packed after all by providing a special table setup tag. This is the work to that.",
      "createdAt": "2024-11-08T14:52:03Z",
      "updatedAt": "2025-04-16T11:42:01Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "e82c5a3e5780d34bf78640c3a4ccab2c550e230f",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "name-comp-packed",
      "headRefOid": "ebe36d0bcce6732b153586fd2090a7401fe004c5",
      "closedAt": "2025-04-16T07:00:02Z",
      "mergedAt": "2025-04-16T07:00:02Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "8942b3613df00c4f380dfe432966e52f7939fe62"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed...",
          "createdAt": "2025-04-16T06:39:04Z",
          "updatedAt": "2025-04-16T06:39:04Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "`s/level of packedness/packed value/g`",
          "createdAt": "2025-04-16T06:47:31Z",
          "updatedAt": "2025-04-16T06:47:31Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Huh? Somehow, I messed this up when force pushing...",
          "createdAt": "2025-04-16T06:49:05Z",
          "updatedAt": "2025-04-16T06:49:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> `s/level of packedness/packed value/g`\r\n\r\nThis was meant to reference https://github.com/cbor-wg/cbor-dns/compare/25006971e1f4cb8210e400bc7b439e9bf34748e1..ccf2a04b19c65ddadb716dd8b469d1a7ffb823d4",
          "createdAt": "2025-04-16T06:50:19Z",
          "updatedAt": "2025-04-16T06:50:19Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "`s/CBOR-packed/Packed CBOR/`",
          "createdAt": "2025-04-16T06:55:13Z",
          "updatedAt": "2025-04-16T06:55:13Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "And rebased.",
          "createdAt": "2025-04-16T06:59:10Z",
          "updatedAt": "2025-04-16T06:59:10Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo gave his blessing to merge this offline but has not time to review this.",
          "createdAt": "2025-04-16T06:59:54Z",
          "updatedAt": "2025-04-16T06:59:54Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> @cabo gave his blessing to merge this offline but has not time to review this.\r\n\r\nDon't have time to review right now either, but did we came to a conclusion about the right tag order regarding table prependment?",
          "createdAt": "2025-04-16T10:26:01Z",
          "updatedAt": "2025-04-16T10:26:01Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> did we came to a conclusion about the right tag order regarding table prependment?\r\n\r\nYes, see https://github.com/cbor-wg/cbor-dns/pull/7#discussion_r1888278854",
          "createdAt": "2025-04-16T11:22:08Z",
          "updatedAt": "2025-04-16T11:22:08Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nYes, correct. I've always phrased it as \"the inner tag prepends to the outer tag\", but that's the same statement.\r\n\r\n",
          "createdAt": "2025-04-16T11:41:07Z",
          "updatedAt": "2025-04-16T11:41:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M6Qe9sY",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Some content-related and several editorial suggestions and comments :)",
          "createdAt": "2024-11-08T15:00:57Z",
          "updatedAt": "2024-11-08T15:25:19Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nThis implicit (i.e. not explicitly represented) table _V_ is constructed as follows:\r\n```",
              "createdAt": "2024-11-08T15:00:58Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 151,
              "body": "```suggestion\r\nAny coherent sequence of text strings encountered within the rump of tag TBD28259, as well as any of its non-empty suffixes, are added to the table as arrays in depth-first order.\r\n```",
              "createdAt": "2024-11-08T15:05:13Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 151,
              "body": "Also, what exactly does \"coherent sequence\" mean? Is that a standing term?",
              "createdAt": "2024-11-08T15:05:57Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 159,
              "body": "I personally find it confusing that `packed=0` still means there is packing involved. Could we find a different naming?",
              "createdAt": "2024-11-08T15:09:37Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nIt provides an implicit text string suffix sequence table for shared items _V_ which is prepended to the existing table for shared items that apply to the content of tag TBD28259 (by default empty table).\r\n```\r\n?",
              "createdAt": "2024-11-08T15:10:54Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nTake the following CBOR object _o_ (note that this is intentionally not legal \"application/dns+cbor\" to illustrate generality).\r\n```\r\n\r\nor any other name, just to be able to reference it later.",
              "createdAt": "2024-11-08T15:12:35Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\n    [\"svc\", simple(0)],\r\n```\r\n\r\nis it not?",
              "createdAt": "2024-11-08T15:13:32Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\nNote that the sequence \"org\", \"example\", \"org\" is added at index 4 with leading \"org\", instead of referencing index 2 + index 1 (`simple(2), simple(1)`), as it is its own distinct suffix sequence.\r\n```",
              "createdAt": "2024-11-08T15:14:42Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nThe packed representation of _o_ would thus be:\r\n```",
              "createdAt": "2024-11-08T15:14:51Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\nWith, e.g., table setup tag 113, further packing can be achieved via nesting table packing.\r\n```",
              "createdAt": "2024-11-08T15:16:55Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 210,
              "body": "```suggestion\r\n113(\r\n  TBD28259(\r\n```\r\n\r\notherwise prepending the table from 113 would shift the TBD28259 ones.",
              "createdAt": "2024-11-08T15:18:35Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 225,
              "body": "Could we get rid of this extra rule with by switching the tag order?",
              "createdAt": "2024-11-08T15:21:18Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 259,
              "body": "everything except `tag`, `array` and `map` wouldn't make sense, right?",
              "createdAt": "2024-11-08T15:23:11Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 210,
              "body": "Which clashes with the requirement that we want to elude TBD28259 for dns+cbor, hum...",
              "createdAt": "2024-11-08T15:24:53Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf83K",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:30:30Z",
          "updatedAt": "2024-11-08T16:30:30Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "\u201eCBOR sequence\u201c is a standing term. Cohererent is meant wrt text strings, so a (sub) sequence that only contains text strings.",
              "createdAt": "2024-11-08T16:30:30Z",
              "updatedAt": "2024-11-08T16:30:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf9cx",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:31:40Z",
          "updatedAt": "2024-11-08T16:31:41Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "The idea is that `packed` might also provide other contexts later. Don't read it as boolean, more as, e.g., a level.",
              "createdAt": "2024-11-08T16:31:41Z",
              "updatedAt": "2024-11-08T16:31:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf-3W",
          "commit": {
            "abbreviatedOid": "cfeb452"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:34:30Z",
          "updatedAt": "2024-11-08T16:40:11Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Since it is implicit, this is arbitrary. I thought it might be more helpful to the reader, if we show the full sequences here.",
              "createdAt": "2024-11-08T16:34:30Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 210,
              "body": "> otherwise prepending the table from 113 would shift the TBD28259 ones.\r\n\r\nHuh? From how I read my definition (and the definition for 113), the tables of the outer tag are prepended to the tables of the inner tag. I want the TBD28259 table _V_ to be the \u201cstart\u201d of the shared item table. \r\n\r\n",
              "createdAt": "2024-11-08T16:37:21Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 225,
              "body": "Then the indices for name compression would be larger than the 113 ones... Which would increase the risk of names having larger references (but as they are more common in DNS messages they should be smaller).",
              "createdAt": "2024-11-08T16:39:04Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 259,
              "body": "That would be the same for 113 or 1113. Nevertheless, they have any as data item as well.",
              "createdAt": "2024-11-08T16:39:42Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgvXO",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:33:27Z",
          "updatedAt": "2024-11-08T17:33:27Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Then maybe \"any CBOR sequence consisting of only text strings\"? Maybe it's also just a personal English-word problem with \"coherent\".",
              "createdAt": "2024-11-08T17:33:27Z",
              "updatedAt": "2024-11-08T17:33:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgyJD",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:36:11Z",
          "updatedAt": "2024-11-08T17:36:11Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "At least for 113, it is definitely the other way around. I guess the rationale is that you enable shorter references within smaller contexts (inside the rump of an inner tag).",
              "createdAt": "2024-11-08T17:36:11Z",
              "updatedAt": "2024-11-08T17:36:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgyVJ",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:36:40Z",
          "updatedAt": "2024-11-08T17:36:40Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "see above.",
              "createdAt": "2024-11-08T17:36:40Z",
              "updatedAt": "2024-11-08T17:36:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qg023",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:41:32Z",
          "updatedAt": "2024-11-08T17:41:32Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I think this illustrates the implicit table setup algorithm better.",
              "createdAt": "2024-11-08T17:41:32Z",
              "updatedAt": "2024-11-08T17:41:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QrMdW",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-11T13:03:39Z",
          "updatedAt": "2024-11-11T13:03:39Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Are you sure? Maybe @cabo can help to alleviate the confusion? Does the outer setup tag prepend its table(s) to the inner tag's table(s) or the inner tag to its outer tag's?",
              "createdAt": "2024-11-11T13:03:39Z",
              "updatedAt": "2024-11-11T13:03:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VJhxH",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-13T13:29:48Z",
          "updatedAt": "2024-12-13T13:29:48Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "The main argument is really composability.  A CBOR data item that uses cbor-packed should still work when it is embedded in some other table setup.",
              "createdAt": "2024-12-13T13:29:48Z",
              "updatedAt": "2024-12-13T13:29:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VJjsv",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-13T13:33:43Z",
          "updatedAt": "2024-12-13T13:33:43Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "This is a note, there is no extra rule.\r\nIf the rest of the text doesn't say that, it needs to be fixed.",
              "createdAt": "2024-12-13T13:33:43Z",
              "updatedAt": "2024-12-13T13:33:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VhE9j",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T10:29:10Z",
          "updatedAt": "2024-12-17T10:29:10Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nE.g., taking the example\r\n\r\n```\r\n113(\r\n  TBD28259(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(5)],\r\n        [\"svc\", simple(0)],\r\n        simple(5), simple(1), simple(6),\r\n        simple(3), simple(6)\r\n      ]\r\n    ]\r\n  )\r\n)\r\n```\r\n\r\nwould still work with\r\n\r\n```\r\n  TBD28259(\r\n    [\r\n        [\"www\", \"example\", \"org\"],\r\n        [\"svc\", simple(0)],\r\n        \"org\", simple(1), 42,\r\n        simple(3), 42\r\n    ]\r\n  )\r\n```\r\n\r\nwhile the other way around \r\n\r\n```\r\nTBD28259(\r\n  113(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(5)],\r\n        [\"svc\", simple(0)],\r\n        simple(5), simple(1), simple(6),\r\n        simple(3), simple(6)\r\n      ]\r\n    ]\r\n  )\r\n)\r\n```\r\n\r\nwould completely need to rewrite the `simple(i)` references (and not just the new ones) for `113(...)` if `TBD28259(...)` is taken away to make sense.\r\n\r\n```\r\n  113(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(0)],\r\n        [\"svc\", \"www\", \"example\", simple(0)],\r\n        simple(0), \"example\", simple(0), sample(1),\r\n        \"svc\", \"www\", \"example\", \"org\", sample(1)\r\n      ]\r\n    ]\r\n  )\r\n```\r\n\r\nThis makes sense to me. Will fix (and try to find a better wording to make the table setup clearer).",
              "createdAt": "2024-12-17T10:29:10Z",
              "updatedAt": "2024-12-17T10:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Vibek",
          "commit": {
            "abbreviatedOid": "034b61a"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T13:04:09Z",
          "updatedAt": "2024-12-17T13:04:17Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "I am not set on the term \u201clevel of packedness\u201d. In fact, I would love to get some alternative terms.",
              "createdAt": "2024-12-17T13:04:09Z",
              "updatedAt": "2024-12-17T13:04:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6lPHvA",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T11:42:01Z",
          "updatedAt": "2025-04-16T11:42:01Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "> Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nThat is a funny way to say \"prepend tables built from inner tags to those inherited from an outer table building tag\", but it definitely is what has worked well so far.\r\n(An on-the-fly implementation could start at the node with the reference, go up until it finds the next table building tag, use what it finds there if the reference is covered, or subtract the size of the table from a reference index that goes beyond that table and continue upwards.)",
              "createdAt": "2025-04-16T11:42:01Z",
              "updatedAt": "2025-04-16T11:42:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOIM0M7M6WuEp8",
      "title": "Provide extension point for IP addresses",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/10",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See #9.",
      "createdAt": "2025-05-19T12:56:38Z",
      "updatedAt": "2025-07-07T20:24:07Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "a2e5700fdab8017d9be8088f57c615de8270146f",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "ip-addr-ext-point",
      "headRefOid": "1628b99be3e48603d6887477e8303473f0e63e3d",
      "closedAt": "2025-07-07T20:24:03Z",
      "mergedAt": "2025-07-07T20:24:03Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "9a14dc87693b2615888773c7b6ff57cabc48e831"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOIM0M7M6dzlOt",
      "title": "Fix CDDL for PR#6 (groups vs. types)",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/11",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-07T18:13:25Z",
      "updatedAt": "2025-07-07T18:24:25Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "rrsets",
      "baseRefOid": "d0705dbe935cd7d7f628218ef6a149e30aa22e39",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "fix-cddl-6",
      "headRefOid": "d4234648d6d3dc7466e98e832666828b4fe73b06",
      "closedAt": "2025-07-07T18:24:25Z",
      "mergedAt": "2025-07-07T18:24:25Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "5e8db6e1f7d4ec269f1dc26f758ae39a79701afc"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Ahh, thanks!",
          "createdAt": "2025-07-07T18:24:15Z",
          "updatedAt": "2025-07-07T18:24:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOIM0M7M6-B8ST",
      "title": "Use e'' application extension in examples",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/14",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "~~This provides a (draft for now) for an EDN app-specific extension for DNS+CBOR. So far, I only introduced resource record types, classes, EDNS(0) option codes and SVCB SvcParamKeb but even Header Flags including Rcodes could be a point of extension. But let's discuss by example first, if this is in scope. If so, I will also provide an ABNF.~~\r\n\r\n[updated after extensive discussions about a more involved format]\r\n\r\nThis provides definitions for and uses the `e''` application extension to enhance the readability of RR types and classes in the examples.\r\n",
      "createdAt": "2026-01-19T15:11:57Z",
      "updatedAt": "2026-02-04T11:46:43Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "59df39331efb6d25453e5d6fb50c579ae789db60",
      "headRepository": "miri64/cbor-dns",
      "headRefName": "edn-literals",
      "headRefOid": "f4aaebee8da236c5fc4e4d74324dfbe1fd123be4",
      "closedAt": "2026-02-04T11:46:43Z",
      "mergedAt": "2026-02-04T11:46:43Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "522aa6c432e7337edb27607a88edf305cd3d0b12"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "As the new title implies: I now added a few more literals.",
          "createdAt": "2026-01-23T16:03:00Z",
          "updatedAt": "2026-01-23T16:03:00Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Gah. Of course people won't use such long literals for such short substrings. What people do expect is familiar syntax:\r\n```\r\ndns-rr'example.org  3600 IN A 192.0.0.2'\r\n```\r\ntranslating to entire RR array. Or sequence to be inside array... because actually, from data model point of view, every item should have explicit tag on it, e.g.\r\n`TBDrr([\"example\", \"org\", 3600, 5, \"ns1\", \"example\", \"org\"])`\r\nIt is just that we omit such tags for the compactness of wire representation, but in application data structures implementers will have data types more explicit - RR, name, type, class, ...\r\n\r\nUPD: ...Yes, I think it should expand to CBOR sequence: for allowing things like\r\n`[dns-rr'example.com 4800 A', ip'192.0.0.2']`\r\nor actually, for better specifying bstr-s as RRDATA unknown to (current version of) parser, or - for example - to `dns-opt''` and `dns-svp''`.\r\nSo it will expand to only those things explicitly listed inside quotes, allowing to specify more precisely what goes to array. And paying attention to dot at end to produce empty string, thus allowing to support zone files also, but `$ORIGIN` suggestion etc. is better to discuss in #12 \r\n\r\nTo summarize, `dns-rrt`, `dns-rrc` and `dns-cls` are not needed, unified `dns-rr` should be used instead. As for `dns-opt''` and `dns-svp''`, these are fine.",
          "createdAt": "2026-01-23T23:19:27Z",
          "updatedAt": "2026-01-23T23:56:23Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "While I like the idea, I am not sure how practical it is: What about elided fields? When using your proposal, these elisions would be hidden from the reader. This could have advantages, e.g. when reading a dump of a DNS+CBOR object, but it also comes with the usual pitfalls when hiding information from the reader... Case end point: you also elide the IN class already in your example. Maybe a compromise which would not follow the text representation format of DNS 100% would be something like:\r\n\r\n```\r\n[dns-rr'4800 example.com (IN) (AAAA)', ip'2001:db8::1']\r\n```\r\n\r\nWhere `()` signifies that the field was elided. Given the prevalence of `IN` it could be elided in EDN as well...\r\n\r\n> To summarize, `dns-rrt`, `dns-rrc` and `dns-cls` are not needed, unified `dns-rr` should be used instead. As for `dns-opt''` and `dns-svp''`, these are fine.\r\n\r\n\"not needed\" I wouldn't say, I still see some potential use when classes or types are represented on their own somehow. But granted, I have no example for that.\r\n\r\n`dns-opt` and `dns-svp` should work then similar to your `dns-rr` proposal, IMHO.\r\n\r\n`dns-opt` somewhat inspired by the expired [draft-peltan-edns-presentation-format](https://datatracker.ietf.org/doc/draft-peltan-edns-presentation-format/03/)\r\n\r\n```\r\n[dns-rr'4800 example.com (IN) OPT', dns-opt'COOKIE: 36714f2e8805a93d,4654b4ed3279001b OPT1234: 000004d2']\r\n```\r\n\r\nand `dns-svcb` just following the text representation specified in [RFC 9460](https://datatracker.ietf.org/doc/html/rfc9460):\r\n\r\n```\r\n[dns-rr'4800 _dns.example.com (IN) SVCB', dns-svcb'1 dns.example.org alpn=co,docpath']\r\n[dns-rr'4800 example.com (IN) HTTPS', dns-svcb'1 . alpn=h3']\r\n```\r\n\r\n_Edit:_ fixed some syntax errors and brought the `dns-svcb` examples more in line with RFC9460 text representation.",
          "createdAt": "2026-01-26T13:51:58Z",
          "updatedAt": "2026-01-26T13:57:22Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> `[dns-rr'4800 example.com (IN) (AAAA)', ip'2001:db8::1']`\r\n\r\n(took the liberty to put the TTL first, differing from your example. This way it is more in line with the textual format used in zone files and also the order of values used in DNS+CBOR)",
          "createdAt": "2026-01-26T13:59:24Z",
          "updatedAt": "2026-01-26T13:59:24Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "No, there is no problem with elision: see, the EDN means \"diagnostic\" so it primarily should fit display purposes of data - which could be not valid - not only due to bugs but e.g. in unit tests etc. So the mapping back and forth must be 1-to-1 to be unambiguous what is sent/received (yes, you are right, not 100% follow the text representation format of DNS, because that will make you to write **much more** code, especially if you parse every RDATA inside `dns-rr` instead of separate app-strings for each type... ok, if someone in future want to implement full parser, we can be pedantic and for now call it `dns-rrh` for \"head\"). That is, elision happens on layer upper to particular RR, and parser do not have to have complications about guessing elisions or supporting parentheses - i.e.\r\n\r\n```\r\n[dns-rr'example.com 4800 A', ip'192.0.0.2']  <=> [\"example\", \"com\", 4800, 1, ip'192.0.0.2']\r\n\r\n[dns-rr'example.com 4800 IN NS', ip'192.0.0.2']  <=> [\"example\", \"com\", 4800, 2, 1, ip'192.0.0.2']\r\n\r\n[dns-rr'example.com 4800', ip'192.0.0.2']  <=> [\"example\", \"com\", 4800, ip'192.0.0.2']\r\n```\r\n\r\nNote that latter is invalid from the point of view of zone files syntax, which always requires record type, but we can pay this price for elisions - this is not full zone file to DNS-CBOR converter, but just part of it to make human life easy 80/20 (BTW I don't remember if EDN supports expansion of single-quote `app''` string to CBOR sequence; if not, should be fixed in EDN, not us here).\r\n\r\n> \"not needed\" I wouldn't say, I still see some potential use when classes or types are represented on their own somehow. But granted, I have no example for that.\r\n\r\nIn a form which I propose, we just use same `dns-rr''` for single field - e.g.\r\n`dns-rr'4800', ip'192.0.0.2']  <=> [4800, ip'192.0.0.2']`\r\nfor just TTL [*], or `dns-rr'CNAME'` for just `5`. Again, such reduced syntax is not valid for zone files, but we are not obliged to have 100% conformance here, e.g. even parentheses and comments are not needed because EDN has it's own. Should support \\DDD escape sequences, though.\r\n\r\n> dns-opt and dns-svp should work then similar to your dns-rr proposal, IMHO.\r\n> \r\n> dns-opt somewhat inspired by the expired [draft-peltan-edns-presentation-format](https://datatracker.ietf.org/doc/draft-peltan-edns-presentation-format/03/)\r\n> \r\n> [dns-rr'4800 example.com (IN) OPT', dns-opt'COOKIE: 36714f2e8805a93d,4654b4ed3279001b OPT1234: 000004d2']\r\n> \r\n> and dns-svcb just following the text representation specified in [RFC 9460](https://datatracker.ietf.org/doc/html/rfc9460):\r\n> \r\n> [dns-rr'4800 _dns.example.com (IN) SVCB', dns-svcb'1 dns.example.org alpn=co,docpath']\r\n> [dns-rr'4800 example.com (IN) HTTPS', dns-svcb'1 . alpn=h3']\r\n\r\nDid not read that draft yet, but I like your examples.\r\n\r\n[*] *Edit:* That probably should be `dns-rr' 4800'` with blank to distinguish from generating `\"4800\"` label, see next comment...",
          "createdAt": "2026-01-26T19:44:32Z",
          "updatedAt": "2026-01-26T20:14:59Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> > `[dns-rr'4800 example.com (IN) (AAAA)', ip'2001:db8::1']`\r\n> \r\n> (took the liberty to put the TTL first, differing from your example. This way it is more in line with the textual format used in zone files and also the order of values used in DNS+CBOR)\r\n\r\nNo, TTL first is invalid in zone files, and DNS-CBOR also has label before TTL when not elided (to make decoder know that label ended). [RFC 1035](https://www.rfc-editor.org/rfc/rfc1035) describes syntax on pages 34-36:\r\n```\r\n    <domain-name><rr> [<comment>]\r\n\r\n    <blank><rr> [<comment>]\r\n...\r\n<rr> contents take one of the following forms:\r\n\r\n    [<TTL>] [<class>] <type> <RDATA>\r\n\r\n    [<class>] [<TTL>] <type> <RDATA>\r\n\r\n@               A free standing @ is used to denote the current origin.\r\n\r\n\\X              where X is any character other than a digit (0-9), is\r\n                used to quote that character so that its special meaning\r\n                does not apply.  For example, \"\\.\" can be used to place\r\n                a dot character in a label.\r\n\r\n\\DDD            where each D is a digit is the octet corresponding to\r\n                the decimal number described by DDD.  The resulting\r\n                octet is assumed to be text and is not checked for\r\n                special meaning.\r\n\r\n( )             Parentheses are used to group data that crosses a line\r\n                boundary.  In effect, line terminations are not\r\n                recognized within parentheses.\r\n\r\n;               Semicolon is used to start a comment; the remainder of\r\n                the line is ignored.\r\n```\r\nSo parentheses in `(AAAA)` will be with unexpected meaning for those accustomed to 1035 zone files. But as I've said in earlier comment, we can just omit them; and 1035 syntax even allows that except for record type, which we can also relax here, because we provide EDN description for one RR in isolation, and full 1035 requires parser with state between lines, which would unnecessarily complicate EDN.\r\n\r\n**N.B.:** that original 1035 just prohibited labels starting from numbers to distinguish from TTL in parser, but now these are allowed, so we have to think about EDN parser here in case of elisions. May be a blank before TTL?..\r\n",
          "createdAt": "2026-01-26T19:52:57Z",
          "updatedAt": "2026-01-26T19:56:16Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> No, TTL first is invalid in zone files, and DNS-CBOR also has label before TTL when not elided (to make decoder know that label ended). [RFC 1035](https://www.rfc-editor.org/rfc/rfc1035) describes syntax on pages 34-36:\r\n\r\nOh, you are right! I thought I saw a reference where the TTL was written first, but can't find it anymore and RFC 1035 is the more trustworthy source. And not sure where I got he idea for DNS+CBOR from...",
          "createdAt": "2026-01-27T09:31:22Z",
          "updatedAt": "2026-01-27T09:31:22Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand the goal of matching a well-known visual representation for humans, for example when inspecting actual dns+cbor data. But I honestly dislike the idea of using that in the EDN representations in this draft, as it hides the actual array structure, which the examples are meant to showcase.",
          "createdAt": "2026-01-27T09:42:39Z",
          "updatedAt": "2026-01-27T09:42:39Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> So parentheses in `(AAAA)` will be with unexpected meaning for those accustomed to 1035 zone files.\r\n\r\nWe always could use something else (e.g., `[]` which are widely used for optional values). Especially considering elision of names and when using name compression, I think this can have value, e.g. see the following query:\r\n\r\n```\r\n[\r\n   [dns-rr'example.org [A]'],  # question => [\"example\", \"org\"]\r\n   [  # answer\r\n      [dns-rr'[example.org] 3600 CNAME', \"iot\", \"example\", \"org\"]  # => [3600, 5, \"example\", \"org\"]\r\n   ] ,\r\n   [\r\n     [dns-rr'iot[.example.org] 3600 [AAAA]', ip'2001:db8::1']   # => [\"iot\", simple(0), 3600, ip'2001:db8::1']\r\n   ]\r\n]\r\n```\r\n\r\nI think this would be much better readable for an uninitiated reader (these markings, as illustrated with my omission of `[IN]` could still be purely optional).\r\n\r\nMaybe it is best to have a separate marking for name compression? Otherwise, there could be ambiguity when resolving `[example.org] 3600` which either could be `[simple(x), 3600]` (or `[6(y), 3600]` for that matter) or `[3600]`.\r\n\r\n> Did not read that draft yet, but I like your examples.\r\n\r\nDid not update the draft yet, just making discussion proposals ;-).",
          "createdAt": "2026-01-27T09:45:06Z",
          "updatedAt": "2026-01-27T09:45:06Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> I understand the goal of matching a well-known visual representation for humans, for example when inspecting actual dns+cbor data. But I honestly dislike the idea of using that in the EDN representations in this draft, as it hides the actual array structure, which the examples are meant to showcase.\r\n\r\nConsidering my musings on ambiguity in https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3804161321, I think I tend to agree now. But maybe let's put this up for discussion in ~~tomorrow's~~ Thursday's meeting.",
          "createdAt": "2026-01-27T09:46:11Z",
          "updatedAt": "2026-01-27T09:49:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "I also talked to @waehlisch now. He doesn't like the `dns-rr''` format either. Besides potentially confusing CBOR people by hiding structure, as @mguetschow pointed out, we also risk confusing DNS people. Yes, they are familiar with zone file formatting, but \r\n\r\n1. This familiarity and the unfamiliarity with EDN may become a problem (\"What, those people want to put zone file data into DNS messages??!?\")\r\n2. The fact that we omit/notate things like RRTYPE from that notation on elision might lead to further confusion (\"What, those people want to change the zone file format??!?\")\r\n\r\nSo I think we are coming to a conclusion, that the `dns-rr` proposal is more confusing than helpful for the uninitiated reader, while with something like `[\"example\", \"com\", dns-rrt'A', ip'192.0.2.1']` it is much clearer _for this draft_ what DNS+CBOR wants to achieve.",
          "createdAt": "2026-01-27T16:18:59Z",
          "updatedAt": "2026-01-27T16:18:59Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> I understand the goal of matching a well-known visual representation for humans, for example when inspecting actual dns+cbor data. But I honestly dislike the idea of using that in the EDN representations in this draft, as it hides the actual array structure, which the examples are meant to showcase.\r\n\r\nWell, we can move it to appendix with mark \"it is not normative yet, subject to future changes in EDN\" and describe it fully in next RFC together with zone files. BTW, I'd want to include `$ORIGIN` (and may be even `$TTL` adding to _V_ even without `packed=1`) in this version, because labels are not absolute now, though full zone files should be postponed to separate document.",
          "createdAt": "2026-01-27T20:10:15Z",
          "updatedAt": "2026-01-27T20:10:15Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> > So parentheses in `(AAAA)` will be with unexpected meaning for those accustomed to 1035 zone files.\r\n> \r\n> We always could use something else (e.g., `[]` which are widely used for optional values). Especially considering elision of names and when using name compression, I think this can have value, e.g. see the following query:\r\n> \r\n> ```\r\n> [\r\n>    [dns-rr'example.org [A]'],  # question => [\"example\", \"org\"]\r\n>    [  # answer\r\n>       [dns-rr'[example.org] 3600 CNAME', \"iot\", \"example\", \"org\"]  # => [3600, 5, \"example\", \"org\"]\r\n>    ] ,\r\n>    [\r\n>      [dns-rr'iot[.example.org] 3600 [AAAA]', ip'2001:db8::1']   # => [\"iot\", simple(0), 3600, ip'2001:db8::1']\r\n>    ]\r\n> ]\r\n> ```\r\n> \r\n> I think this would be much better readable for an uninitiated reader (these markings, as illustrated with my omission of `[IN]` could still be purely optional).\r\n\r\nWon't this need more complicated parser as now you are not passed just contents of app-string bit have to process whole message deducing it should be exactly `simple(0)` and not some other reference?.. Too complex, I think.\r\n\r\n> Maybe it is best to have a separate marking for name compression? Otherwise, there could be ambiguity when resolving `[example.org] 3600` which either could be `[simple(x), 3600]` (or `[6(y), 3600]` for that matter) or `[3600]`.\r\n\r\nThis could be something like `dns-rr'iot.{0} 3600 [AAAA]'` to denote index 0 in _V_ but now this complicates syntax even more for human reader...",
          "createdAt": "2026-01-27T20:17:52Z",
          "updatedAt": "2026-01-27T20:17:52Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> I also talked to @waehlisch now. He doesn't like the `dns-rr''` format either. Besides potentially confusing CBOR people by hiding structure, as @mguetschow pointed out, we also risk confusing DNS people. Yes, they are familiar with zone file formatting, but\r\n> \r\n>     1. This familiarity and the unfamiliarity with EDN may become a problem (\"What, those people want to put zone file data into DNS messages??!?\")\r\n\r\nWell, this is simply not true. The 1035's format is used not only in zone files but also in utilities exactly for DNS messages. Two examples (this is `drill` from `unbound` because on my local machine, but it modeled after more popular `dig` from BIND):\r\n\r\n```\r\n$ drill ANY github.com \r\n;; ->>HEADER<<- opcode: QUERY, rcode: NOERROR, id: 38158\r\n;; flags: qr rd ra ; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 \r\n;; QUESTION SECTION:\r\n;; github.com.  IN      ANY\r\n\r\n;; ANSWER SECTION:\r\ngithub.com.     3600    IN      HINFO   \"RFC8482\" \"\"\r\n\r\n;; AUTHORITY SECTION:\r\n\r\n;; ADDITIONAL SECTION:\r\n\r\n;; Query time: 159 msec\r\n;; SERVER: 127.0.0.1\r\n;; WHEN: Tue Jan 27 21:47:16 2026\r\n;; MSG SIZE  rcvd: 49\r\n$ drill github.com     \r\n;; ->>HEADER<<- opcode: QUERY, rcode: NOERROR, id: 1835\r\n;; flags: qr rd ra ; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 \r\n;; QUESTION SECTION:\r\n;; github.com.  IN      A\r\n\r\n;; ANSWER SECTION:\r\ngithub.com.     60      IN      A       140.82.121.3\r\n\r\n;; AUTHORITY SECTION:\r\n\r\n;; ADDITIONAL SECTION:\r\n\r\n;; Query time: 47 msec\r\n;; SERVER: 127.0.0.1\r\n;; WHEN: Tue Jan 27 21:50:50 2026\r\n;; MSG SIZE  rcvd: 44\r\n```\r\n\r\nBTW this output suggests us to provide also EDN for flags/opcode/rcode.\r\n\r\n>     2. The fact that we omit/notate things like RRTYPE from that notation on elision might lead to further confusion (\"What, those people want to change the zone file format??!?\")\r\n> \r\n> So I think we are coming to a conclusion, that the `dns-rr` proposal is more confusing than helpful for the uninitiated reader, while with something like `[\"example\", \"com\", dns-rrt'A', ip'192.0.2.1']` it is much clearer _for this draft_ what DNS+CBOR wants to achieve.\r\n\r\nOK, point 2 is more serious, but alternative with\r\n`[\"example\", \"com\", dns-rrt'A', dns-cls'IN', ip'192.0.2.1']`\r\nstill looks ugly (lengthy, too much punctuation) and I doubt people will like it - because it would be more simple and readable to just use comments:\r\n`[\"example\", \"com\", 5 /CNAME/, 1 /IN/, ip'192.0.2.1']`\r\n\r\nGiven that main usage in RR head is for constants if types/classes, I think we can make following compromise:\r\n* name it `dns''` - as short as possible (`dns-svcb` and like are not affected)\r\n* when presenting from CBOR, tools ALWAYS generate EDN without hiding structure, on individual fields: `dns'A', dns'IN'` and only for type & class\r\n* human MAY write combined `dns'example.com 3000 IN NS'` for machine to parse for non-complicated cases - e.g. it would require distinct `[dns'iot.subdomain', simple(0), dns'CNAME IN', ...]` to not invent much syntax.\r\n\r\nThat is, being used mostly for constants and labels with dots, as single `[\"www\", ...]` is shorter/readable than `[dns'www', ...]` - and described in text as used for constants, with phrasing which can't give impression \"this is a new zone file syntax\". Just helpers.",
          "createdAt": "2026-01-27T20:42:10Z",
          "updatedAt": "2026-01-27T20:42:10Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "#### Reply to https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3807305027\r\n\r\n> Well, we can move it to appendix with mark \"it is not normative yet, subject to future changes in EDN\" and describe it fully in next RFC together with zone files.\r\n\r\nOr just introduce integer representations in form of `dns-rrt` an `dns-cls` here to better illustrate the examples and provide possible future EDN extensions _in the future_ (i.e., in a separate document altogether)... Nothing that we propose with `dns-rrt` or `dns-cls` is preventing that and it is not like the namespace for EDN literals is limited. In fact, I think providing the ground work by importing these literals on their own can ease further migration to a more zone-file-like string format: The values would already be imported from the IANA registry to EDN, so a future extension would just need to reference that.\r\n\r\n> BTW, I'd want to include `$ORIGIN` (and may be even `$TTL` adding to _V_ even without `packed=1`) in this version, because labels are not absolute now, though full zone files should be postponed to separate document.\r\n\r\nWe are not talking about zone files here, just using their format for `dns-rr`, so not sure what you are trying to say.\r\n\r\n---\r\n\r\n#### Reply to https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3807340914\r\n\r\n>> [...]\r\n>\r\n> Won't this need more complicated parser as now you are not passed just contents of app-string bit have to process whole message deducing it should be exactly simple(0) and not some other reference?.. Too complex, I think.\r\n>\r\n>> [...]\r\n> This could be something like dns-rr'iot.{0} 3600 [AAAA]' to denote index 0 in V but now this complicates syntax even more for human reader...\r\n\r\nNoted for future extension.\r\n\r\n---\r\n\r\n#### Reply to https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3807436744\r\n\r\n> > I also talked to @waehlisch now. He doesn't like the `dns-rr''` format either. Besides potentially confusing CBOR people by hiding structure, as @mguetschow pointed out, we also risk confusing DNS people. Yes, they are familiar with zone file formatting, but\r\n> > ```\r\n> > 1. This familiarity and the unfamiliarity with EDN may become a problem (\"What, those people want to put zone file data into DNS messages??!?\")\r\n> > ```\r\n> \r\n> Well, this is simply not true. The 1035's format is used not only in zone files but also in utilities exactly for DNS messages. Two examples (this is `drill` from `unbound` because on my local machine, but it modeled after more popular `dig` from BIND):\r\n> [...]\r\n\r\nMisunderstanding _may and do_ happen.  Making things more complicated to discuss because of misunderstandings is something that should be avoided. We already need to explain to people that EDN _is not_ what is sent over the wire. When you then bunch several array elements into one string, hiding actual structure, you confuse people. The examples here are to provide context, not to make things neat. Yes, familiarity helps to make things comfortable for the reader, but if the reader does not understand _at a glance_ that `[dns-rr'example.org IN']` is actually `[\"example\", \"org\", 1]` and not `[\"example.org IN\"]` (which then actually translates to `0x83676578616D706C65636F726701` or `0x816E6578616D706C652E6F726720494E`, respectively) you are just asking for negative reviews which then lead to endless discussions that are simply not be necessary.\r\n\r\n> BTW this output suggests us to provide also EDN for flags/opcode/rcode.\r\n\r\nSee [original post](https://github.com/cbor-wg/cbor-dns/pull/14#issue-3830146143):\r\n\r\n> [!TIP]\r\n> [...] but even **Header Flags including Rcodes could be a point of extension**. But let's discuss by example first, if this is in scope. If so, I will also provide an ABNF.\r\n\r\nReminder: We don't _need_ to provide a full extension here. We should also avoid feature creep to this document which already includes a lot of more batteries than anyone could ask for.\r\n\r\n> OK, point 2 is more serious, but alternative with `[\"example\", \"com\", dns-rrt'A', dns-cls'IN', ip'192.0.2.1']` still looks ugly (lengthy, too much punctuation) and I doubt people will like it - because it would be more simple and readable to just use comments: `[\"example\", \"com\", 5 /CNAME/, 1 /IN/, ip'192.0.2.1']`\r\n\r\nI find the latter example less readable, TBH... and it is basically the current state. If we would go that route, I would just close this PR and add those ugly comments ;-). But: We then wouldn't have these numbers already imported into EDN.\r\n\r\n> Given that main usage in RR head is for constants if types/classes, I think we can make following compromise:\r\n> \r\n> * name it `dns''` - as short as possible (`dns-svcb` and like are not affected)\r\n> * when presenting from CBOR, tools ALWAYS generate EDN without hiding structure, on individual fields: `dns'A', dns'IN'` and only for type & class\r\n\r\nThat would import from two registries and would make room for ambiguity.\r\n\r\n> * human MAY write combined `dns'example.com 3000 IN NS'` for machine to parse for non-complicated cases - e.g. it would require distinct `[dns'iot.subdomain', simple(0), dns'CNAME IN', ...]` to not invent much syntax.\r\n\r\nCase and point: Would `[dns'NS']` then resolve to `[\"NS\"]` (the domain name \"ns\", domain names are case insensitive after all) or `[2]` (the RRTYPE NS)? Is `dns'ANY'` a name \"any\", an rrtype value \"255\", or a class value \"255\"?\r\n\r\nThe \"MAY\" is confusing EDN literals are optional regardless.\r\n\r\n> That is, being used mostly for constants and labels with dots, as single `[\"www\", ...]` is shorter/readable than `[dns'www', ...]` [..]\r\n\r\nI also would prefer shorter app-extension identifiers ;-). See https://github.com/cbor-wg/cbor-dns/pull/14#discussion_r2712512085\r\n\r\n> [...] - and described in text as used for constants, with phrasing which can't give impression \"this is a new zone file syntax\". Just helpers.\r\n\r\nWe already had the case of people only looking at the examples and being confused how the mechanism actually works even though it was described in the text...\r\n\r\n---\r\n\r\n#### Conclusion\r\n\r\nMy proposal would be to stick with the current approach. This way, by importing those IANA values, we lay a foundation for possible future documents that makes things even neater. There is no conflict here, because the name space for EDN literals is unlimited (see https://datatracker.ietf.org/doc/html/draft-ietf-cbor-edn-literals#section-6.1). I am not stuck on the names, if they are shorter, all the better for me. But they should be disjunct between different IANA registries to prevent ambiguity.",
          "createdAt": "2026-01-29T10:50:39Z",
          "updatedAt": "2026-01-29T10:50:39Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is my 2 cent:\r\n\r\n[dns-rrtypes.cddl.txt](https://github.com/user-attachments/files/24938614/dns-rrtypes.cddl.txt)\r\n\r\nas produced by\r\n\r\n[dns-parameters.rb.txt](https://github.com/user-attachments/files/24938635/dns-parameters.rb.txt)\r\n",
          "createdAt": "2026-01-29T13:44:01Z",
          "updatedAt": "2026-01-29T13:44:01Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Can't automate that as well with CLASS as that isn't as well structured as the RRTYPE registry, but that changes so little that this can be done manually, I think.",
          "createdAt": "2026-01-29T13:44:49Z",
          "updatedAt": "2026-01-29T13:45:57Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here is my 2 cent:\r\n> \r\n> [dns-rrtypes.cddl.txt](https://github.com/user-attachments/files/24938614/dns-rrtypes.cddl.txt)\r\n> \r\n> as produced by\r\n> \r\n> [dns-parameters.rb.txt](https://github.com/user-attachments/files/24938635/dns-parameters.rb.txt)\r\n\r\nSo are you arguing to to use `e''` and import `dns-rrtypes.cddl.txt` (and a manual version of `CLASS`) into the draft? How will we update that list in the future then on a document level?",
          "createdAt": "2026-01-29T14:16:36Z",
          "updatedAt": "2026-01-29T14:17:27Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> So are you arguing to to use `e''` and import `dns-rrtypes.cddl.txt` (and a manual version of `CLASS`) into the draft? \r\n\r\nI was trying to show how this could be done.\r\nNote that examples usually are not normative, so the support files needed to expand the examples don't need to be either.\r\n(Of course, implementers will use them anyway if they are convenient.)\r\n\r\n> How will we update that list in the future then on a document level?\r\n\r\nAs long as the examples do not change, the support files don't neet to be updated.  Shipping the extractor would make it easy for implementers to create updated revisions of the support files as they need them.\r\n\r\nAgain, my point is not to ask that we do it this way (although I do like e'RR_CNAME', including the phonetics :-), but just a demonstration that this approach is a candidate that can be done in an automation-friendly way.",
          "createdAt": "2026-01-29T14:44:29Z",
          "updatedAt": "2026-01-29T14:44:29Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> #### Reply to [#14 (comment)](https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3807305027)\r\n> \r\n> > Well, we can move it to appendix with mark \"it is not normative yet, subject to future changes in EDN\" and describe it fully in next RFC together with zone files.\r\n> \r\n> Or just introduce integer representations in form of `dns-rrt` an `dns-cls` here to better illustrate the examples and provide possible future EDN extensions _in the future_ (i.e., in a separate document altogether)... Nothing that we propose with `dns-rrt` or `dns-cls` is preventing that and it is not like the namespace for EDN literals is limited. \r\n\r\nI am not fan of polluting namespace with things which will stay (because Standards Track) forever but will likely be unused by people.\r\n\r\n> In fact, I think providing the ground work by importing these literals on their own can ease further migration to a more zone-file-like string format: The values would already be imported from the IANA registry to EDN, so a future extension would just need to reference that.\r\n\r\nI don't understand what you mean by \"import\" here. We are not expecting to have anything else than already existing IANA registry.\r\n\r\n> > BTW, I'd want to include `$ORIGIN` (and may be even `$TTL` adding to _V_ even without `packed=1`) in this version, because labels are not absolute now, though full zone files should be postponed to separate document.\r\n> \r\n> We are not talking about zone files here, just using their format for `dns-rr`, so not sure what you are trying to say.\r\n> #### Reply to [#14 (comment)](https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3807340914)\r\n\r\nThis is because it is tied with problem of non-absolute names currently, and with different parsing of `dns'one.two'` and `dns'one.two.` - ok, I'll create new issue with this.\r\n\r\n> > > I also talked to @waehlisch now. He doesn't like the `dns-rr''` format either. Besides potentially confusing CBOR people by hiding structure, as @mguetschow pointed out, we also risk confusing DNS people. Yes, they are familiar with zone file formatting, but\r\n> > > ```\r\n> > > 1. This familiarity and the unfamiliarity with EDN may become a problem (\"What, those people want to put zone file data into DNS messages??!?\")\r\n> > > ```\r\n> > Well, this is simply not true. The 1035's format is used not only in zone files but also in utilities exactly for DNS messages. Two examples (this is `drill` from `unbound` because on my local machine, but it modeled after more popular `dig` from BIND):\r\n> > [...]\r\n> \r\n> Misunderstanding _may and do_ happen. Making things more complicated to discuss because of misunderstandings is something that should be avoided. We already need to explain to people that EDN _is not_ what is sent over the wire.\r\n\r\nYes, educating people is good thing.\r\n\r\n>  When you then bunch several array elements into one string, hiding actual structure, you confuse people.\r\n\r\nThen don't do it in the first place - only do it secondarily, after more simple examples first and after explanation that such form is *also* possible, providing for each example the form it maps to, for clarity.\r\n\r\n> The examples here are to provide context, not to make things neat. \r\n\r\nThis is fundamental mistake. I'm talking from practice user side here. The point of app-literals in EDN is exactly to make people's life easier by providing handy to use tools. Otherwise, it is the question what trash those ivory-tower standard-makers waste tax-payers money for.\r\n\r\n> Yes, familiarity helps to make things comfortable for the reader, but if the reader does not understand _at a glance_ that `[dns-rr'example.org IN']` is actually `[\"example\", \"org\", 1]` and not `[\"example.org IN\"]` (which then actually translates to `0x83676578616D706C65636F726701` or `0x816E6578616D706C652E6F726720494E`, respectively) you are just asking for negative reviews which then lead to endless discussions that are simply not be necessary.\r\n\r\nThe solution to this is easy - all main part of document must not use new app-strings. Introduce them in Appendix when reader already knows what really is sent over the wire. Then there will be no \"at a glance\" problem because it will be introduced and explained after 101 are taught.\r\n\r\n> Reminder: We don't _need_ to provide a full extension here. We should also avoid feature creep to this document which already includes a lot of more batteries than anyone could ask for.\r\n\r\nWe don't really need these things in first version of document at all. Everything in main part of text is sufficiently describable by comments or prose.\r\n \r\n> > OK, point 2 is more serious, but alternative with `[\"example\", \"com\", dns-rrt'A', dns-cls'IN', ip'192.0.2.1']` still looks ugly (lengthy, too much punctuation) and I doubt people will like it - because it would be more simple and readable to just use comments: `[\"example\", \"com\", 5 /CNAME/, 1 /IN/, ip'192.0.2.1']`\r\n> \r\n> I find the latter example less readable, TBH... and it is basically the current state. If we would go that route, I would just close this PR and add those ugly comments ;-). But: We then wouldn't have these numbers already imported into EDN.\r\n\r\nI still don't understand what is import and why it can't be done in Appendix.\r\n\r\n> > Given that main usage in RR head is for constants if types/classes, I think we can make following compromise:\r\n> > \r\n> > * name it `dns''` - as short as possible (`dns-svcb` and like are not affected)\r\n> > * when presenting from CBOR, tools ALWAYS generate EDN without hiding structure, on individual fields: `dns'A', dns'IN'` and only for type & class\r\n> \r\n> That would import from two registries and would make room for ambiguity.\r\n\r\nNo, 1035 says \"Since type and class mnemonics are disjoint, the parse is unique\". I read this as there will be never class and type with same name.\r\n\r\n> > * human MAY write combined `dns'example.com 3000 IN NS'` for machine to parse for non-complicated cases - e.g. it would require distinct `[dns'iot.subdomain', simple(0), dns'CNAME IN', ...]` to not invent much syntax.\r\n> \r\n> Case and point: Would `[dns'NS']` then resolve to `[\"NS\"]` (the domain name \"ns\", domain names are case insensitive after all) or `[2]` (the RRTYPE NS)? Is `dns'ANY'` a name \"any\", an rrtype value \"255\", or a class value \"255\"?\r\n\r\nIANA registry lists NONE and ANY only for class, so it is unambiguous here. Rule for labels is that it must contain at least one dot to be parsed as name - class/type won't contain dots. Rationale was already in previous comment: if you need name consisting of only one label, you can just write it as tstr `\"NS\"` without app-string and be done.\r\n\r\n> The \"MAY\" is confusing EDN literals are optional regardless.\r\n\r\nOk. The intent is that it is only input from human form, not what machine does in CBOR->EDN path.\r\n\r\n> > That is, being used mostly for constants and labels with dots, as single `[\"www\", ...]` is shorter/readable than `[dns'www', ...]` [..]\r\n> \r\n> I also would prefer shorter app-extension identifiers ;-). See [#14 (comment)](https://github.com/cbor-wg/cbor-dns/pull/14#discussion_r2712512085)\r\n\r\nYep, this is from I started my entire talk in this PR, and why suggested `dns''` , indirectly continuing to that your rightful comment.\r\n\r\n> > [...] - and described in text as used for constants, with phrasing which can't give impression \"this is a new zone file syntax\". Just helpers.\r\n> \r\n> We already had the case of people only looking at the examples and being confused how the mechanism actually works even though it was described in the text...\r\n\r\nAgain solvable by separating main part examples from EDN-ish Appendix and it's examples.\r\n\r\n> #### Conclusion\r\n> \r\n> My proposal would be to stick with the current approach. This way, by importing those IANA values, we lay a foundation for possible future documents that makes things even neater. There is no conflict here, because the name space for EDN literals is unlimited (see https://datatracker.ietf.org/doc/html/draft-ietf-cbor-edn-literals#section-6.1). I am not stuck on the names, if they are shorter, all the better for me. But they should be disjunct between different IANA registries to prevent ambiguity.\r\n\r\nI think above I've shown there is no \"two registries\" problem actually.",
          "createdAt": "2026-01-29T22:30:26Z",
          "updatedAt": "2026-01-29T22:30:26Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> > Here is my 2 cent:\r\n> > [dns-rrtypes.cddl.txt](https://github.com/user-attachments/files/24938614/dns-rrtypes.cddl.txt)\r\n> > as produced by\r\n> > [dns-parameters.rb.txt](https://github.com/user-attachments/files/24938635/dns-parameters.rb.txt)\r\n> \r\n> So are you arguing to to use `e''` and import `dns-rrtypes.cddl.txt` (and a manual version of `CLASS`) into the draft? How will we update that list in the future then on a document level?\r\n\r\nOh, so by \"import\" you've mean re-listing contents of IANA registries in a big `(A|NS|CNAME|...)` regexp? But this is absolutely wrong approach to go. You describe just base identifier syntax and then parser in code uses a table like Unix files `/etc/protocols` or `/etc/services` which are snapshots of corresponding IANA registries (those are in DNS-related standard C functions, BTW). Because it is not only documents updating problem, it's also code maintenance problem, if done other way.\r\n\r\nThat's why there were discussions about EDN in ML in 2025 about passing just raw app-string contents to application's parser, to make it work like \"plugin\" and not having to bloat ABNF by describing every extension. So application's parser is not obliged to be embedded in main EDN parser or use ABNF at all.",
          "createdAt": "2026-01-29T22:39:42Z",
          "updatedAt": "2026-01-29T22:39:42Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not fan of polluting namespace with things which will stay (because Standards Track) forever but will likely be unused by people.\r\n\r\nOk, then let's use `e''`. This is the solution that seems to be the one that everyone of us can live with, [it is least confusing,] we don't pollute the namespace (it exists already _and_ is by its very definition temporary), and it is easier to read than interlaced comments:\r\n\r\n```python\r\n[\"example\", \"com\", e'RR-A', e'C-IN', ip'192.0.2.1']\r\n```\r\n\r\nand, as proposed by @cabo, I will only add the types and classes used in the examples to the appendix. Any more complex nice-to-have should be put into a separate document.",
          "createdAt": "2026-01-30T11:55:26Z",
          "updatedAt": "2026-01-30T11:56:14Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> > I am not fan of polluting namespace with things which will stay (because Standards Track) forever but will likely be unused by people.\r\n> \r\n> Ok, then let's use `e''`. This is the solution that seems to be the one that everyone of us can live with, [it is least confusing,] we don't pollute the namespace (it exists already _and_ is by its very definition temporary), and it is easier to read than interlaced comments:\r\n> \r\n> ```python\r\n> [\"example\", \"com\", e'RR-A', e'C-IN', ip'192.0.2.1']\r\n> ```\r\n> \r\n> and, as proposed by @cabo, I will only add the types and classes used in the examples to the appendix. Any more complex nice-to-have should be put into a separate document.\r\n\r\nSeems to be good compromiss for *this* version, but as for version, immediately question arise - this is yet antoher draft, won't it postpone publishment yet even more after (currently required dependencies) drafts of EDN and -packed?\r\n\r\nWhile here, minor nitpick: `T-A` seems to be more consistent with `C-IN` (and due to temporary nature, also not expected to clash with anything).",
          "createdAt": "2026-01-30T20:21:50Z",
          "updatedAt": "2026-01-30T20:21:50Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Seems to be good compromiss for _this_ version, but as for version, immediately question arise - this is yet antoher draft, won't it postpone publishment yet even more after (currently required dependencies) drafts of EDN and -packed?\r\n\r\nYes, but different from our draft all of those are already adopted by the WG. So I expect them to progress faster. Also, as we have seen with `-packed`, this can provide valuable insights for the dependencies as well, so one should not shy away from using something in draft stage. And in the end they might just share a fate in the RFC editor queue.",
          "createdAt": "2026-01-30T20:42:15Z",
          "updatedAt": "2026-01-30T20:42:15Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Seems to be good compromiss for _this_ version, but as for version, immediately question arise - this is yet antoher draft, won't it postpone publishment yet even more after (currently required dependencies) drafts of EDN and -packed?\r\n> \r\n> Yes, but different from our draft all of those are already adopted by the WG. So I expect them to progress faster. Also, as we have seen with `-packed`, this can provide valuable insights for the dependencies as well, so one should not shy away from using something in draft stage. And in the end they might just share a fate in the RFC editor queue.\r\n\r\nPlus, we are discussing this minor addition I wanted to add for better readability of the examples now also for more than one week, which also adds to publish postponement ;-). So let's go with the simplest and more important already established solution.",
          "createdAt": "2026-01-30T20:44:11Z",
          "updatedAt": "2026-01-30T20:44:11Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> > > Seems to be good compromiss for _this_ version, but as for version, immediately question arise - this is yet antoher draft, won't it postpone publishment yet even more after (currently required dependencies) drafts of EDN and -packed?\r\n> > \r\n> > \r\n> > Yes, but different from our draft all of those are already adopted by the WG. So I expect them to progress faster. Also, as we have seen with `-packed`, this can provide valuable insights for the dependencies as well, so one should not shy away from using something in draft stage. And in the end they might just share a fate in the RFC editor queue.\r\n\r\nHm, was that WGLC on them already?\r\n\r\n> Plus, we are discussing this minor addition I wanted to add for better readability of the examples now also for more than one week, which also adds to publish postponement ;-). So let's go with the simplest and more important already established solution.\r\n\r\nNo, we are not adding here because publish of DNS-CBOR requires to publish -packed and EDN as RFCs first, and these are waiting anyway in WG queue. But draft on `e''` will also have some time after publishing EDN to be RFC and thus will delay DNS-CBOR becoming RFC even more, isn't it?",
          "createdAt": "2026-01-30T21:04:03Z",
          "updatedAt": "2026-01-30T21:04:03Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > > Seems to be good compromiss for _this_ version, but as for version, immediately question arise - this is yet antoher draft, won't it postpone publishment yet even more after (currently required dependencies) drafts of EDN and -packed?\r\n> > > \r\n> > > \r\n> > > Yes, but different from our draft all of those are already adopted by the WG. So I expect them to progress faster. Also, as we have seen with `-packed`, this can provide valuable insights for the dependencies as well, so one should not shy away from using something in draft stage. And in the end they might just share a fate in the RFC editor queue.\r\n> \r\n> Hm, was that WGLC on them already?\r\n\r\nNo, but they are _adopted_ by the WG (as you can see by their name `draft-ietf-cbor-...`). This draft is not yet and is an individual draft on my name (`draft-lenders-...`).",
          "createdAt": "2026-02-02T11:30:35Z",
          "updatedAt": "2026-02-02T11:30:35Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> No, we are not adding here because publish of DNS-CBOR requires to publish -packed and EDN as RFCs first, and these are waiting anyway in WG queue. But draft on `e''` will also have some time after publishing EDN to be RFC and thus will delay DNS-CBOR becoming RFC even more, isn't it?\r\n\r\nWe will see... Currently the WG is discussing serialization exclusively, which is unusual in and of itself. Once it got unstuck on that, things might progress faster again. In CoRE we also had interdependent drafts. There there was just a common WGLC on them. Since `-edn-literal` and `-edn-e-ref` are mostly independent of `-packed` and `-dns-cbor` they might (and should) progress faster.",
          "createdAt": "2026-02-02T11:34:37Z",
          "updatedAt": "2026-02-02T11:34:37Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here is my 2 cent:\r\n> \r\n> [dns-rrtypes.cddl.txt](https://github.com/user-attachments/files/24938614/dns-rrtypes.cddl.txt)\r\n> \r\n> as produced by\r\n> \r\n> [dns-parameters.rb.txt](https://github.com/user-attachments/files/24938635/dns-parameters.rb.txt)\r\n\r\nBy the way, there now also is a rubygem that can build the RRtype CDDL from IANA:\r\n\r\n```\r\ngem install iana-registry\r\ndns-parameters.rb > rrtypes.cddl\r\n```\r\n\r\nComments (what else should we generate?) welcome.",
          "createdAt": "2026-02-03T19:39:18Z",
          "updatedAt": "2026-02-03T19:39:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M7bSZxK",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-19T17:07:09Z",
          "updatedAt": "2026-01-19T17:21:18Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\nThe application-extension identifier \"dns-rt\" is used to notate a DNS resource record type (RRTYPE) literal.\n```\n\nmaybe? Just fearing that `rt` might be useful for something else in the future. See https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-6.1",
              "createdAt": "2026-01-19T17:07:09Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 50,
              "body": "hum, what do you mean with byte string here? are there DNS RRTYPE that are not ASCII?",
              "createdAt": "2026-01-19T17:09:12Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 51,
              "body": "I'm not sure I understand. Why would some mnemonic not be part of the IANA registry?",
              "createdAt": "2026-01-19T17:12:12Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\nIf the literal matches `[0-9][0-9]*` its value is decimal value of the number matching\n```\n\nWouldn't that also work and be more concise? I'd assume there can be no RRTypes containing numbers?",
              "createdAt": "2026-01-19T17:13:51Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 54,
              "body": "also \n\n\n```suggestion\nIf the literal matches `TYPE[0-9][0-9]*` its value is the decimal value of the number matching\n```",
              "createdAt": "2026-01-19T17:14:21Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 56,
              "body": "You say this twice, or am I overlooking something?",
              "createdAt": "2026-01-19T17:15:17Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\nThe application-extension identifier \"dns-rc\" is used to notate a DNS resource record class (RR CLASS) literal.\n```\n\nSame as above",
              "createdAt": "2026-01-19T17:18:16Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\nOtherwise it must be a mnemonic that is assigned in the paranthesis of the \"Name\" column in the \"DNS\n```",
              "createdAt": "2026-01-19T17:18:31Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            },
            {
              "originalPosition": 135,
              "body": "much nicer-looking examples!",
              "createdAt": "2026-01-19T17:19:16Z",
              "updatedAt": "2026-01-19T17:21:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxdqE",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:10:07Z",
          "updatedAt": "2026-01-21T13:10:07Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "> Just fearing that `rt` might be useful for something else in the future. See https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-6.1\r\n\r\nI leave that decision to the experts of that IANA registry. I was actually taking inspiration from the initial set there and I think a short(er) identifier would motivate usage more. To me, if the identifier is longer than the content (dns-rt'A') or the actual value (1), I already see people using intransparent shorthands (like a/d+c for this format e.g.).",
              "createdAt": "2026-01-21T13:10:07Z",
              "updatedAt": "2026-01-21T13:10:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxhhN",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:13:53Z",
          "updatedAt": "2026-01-21T13:13:53Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "This wording was taken verbatim from EDN. E.g. for `ip''` [its draft says](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-3.2-2):\r\n\r\n> The content of the literal is a single IPv4address or IPv6address as per [Section 3.2.2](https://rfc-editor.org/rfc/rfc3986#section-3.2.2) of [[RFC3986](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#RFC3986)], as **a text or byte string**.\r\n\r\nAnd actually, given that in EDN [byte strings are notated with `''`](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-2.5.3), all examples out there (even the pure ASCII ones) are using byte strings. So your question should rather be \"why allow text strings ([which exclusively use `\"\"`](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#name-text-string-literals))?\" ;-)",
              "createdAt": "2026-01-21T13:13:53Z",
              "updatedAt": "2026-01-21T13:14:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxldX",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:17:42Z",
          "updatedAt": "2026-01-21T13:17:43Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Because a draft author might not have it registered yet. See in this draft e.g. TBD28259 for tag 28259. Having `TYPE1234` or `CLASS5678` gives draft authors (and also just example authors a nice way to distinguish between type and class (which in raw CBOR would both be just unsigned integers) when there is no mnemonic for that number (yet).",
              "createdAt": "2026-01-21T13:17:42Z",
              "updatedAt": "2026-01-21T13:17:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxsqh",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:24:44Z",
          "updatedAt": "2026-01-21T13:24:45Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "> Wouldn't that also work and be more concise? I'd assume there can be no RRTypes containing numbers?\r\n\r\nEDN isn't and shouldn't be about conciseness, but readability and familiarity. When using just numbers I can also just use the unsigned integer outright (yes there is the EDN identifier 'rt' marking it as a type, but that can easily be overlooked) and using `TYPE1234` or `CLASS5678` is something already used within the DNS community for generic types and classes (see [RFC3597, section 5](https://datatracker.ietf.org/doc/html/rfc3597#section-5)).",
              "createdAt": "2026-01-21T13:24:44Z",
              "updatedAt": "2026-01-21T13:24:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxvCN",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:26:43Z",
          "updatedAt": "2026-01-21T13:26:44Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Can you point me to the other mention please? I only see [the definition that the mnemonic \"ANY\" is a legal content of `rt`](https://github.com/cbor-wg/cbor-dns/pull/14/changes#diff-c1ee54122d8c0f166af4524c64e92b0795cd43782536a16364a57a948d8cc838R959). Here I state, that that mnemonic \"ANY\" evaluates to the value 255.",
              "createdAt": "2026-01-21T13:26:43Z",
              "updatedAt": "2026-01-21T13:27:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxwiH",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:28:11Z",
          "updatedAt": "2026-01-21T13:28:11Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "And my answer is the same as in https://github.com/cbor-wg/cbor-dns/pull/14/changes#r2712512085",
              "createdAt": "2026-01-21T13:28:11Z",
              "updatedAt": "2026-01-21T13:28:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bxyii",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:30:13Z",
          "updatedAt": "2026-01-21T13:30:13Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Would it still be nice if it were `[[\"example\", \"org\", dns-rt'255', dns-rc'255']]`? ;-)",
              "createdAt": "2026-01-21T13:30:13Z",
              "updatedAt": "2026-01-21T13:30:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7b2ypl",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T17:44:38Z",
          "updatedAt": "2026-01-21T17:44:39Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "@cabo do you maybe have an opinion on the matter?",
              "createdAt": "2026-01-21T17:44:38Z",
              "updatedAt": "2026-01-21T17:44:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI8CK",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:18:27Z",
          "updatedAt": "2026-01-22T16:18:27Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Ah so both `rt'XXX'` and `rt\"XXX\"` would be valid and equivalent? Not sure I like that design decision of allowing both, especially if we already know we would only ever use ASCII strings here.",
              "createdAt": "2026-01-22T16:18:27Z",
              "updatedAt": "2026-01-22T16:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI8hQ",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:18:56Z",
          "updatedAt": "2026-01-22T16:18:57Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Hum okay, I see. Maybe make that intention explicit?",
              "createdAt": "2026-01-22T16:18:57Z",
              "updatedAt": "2026-01-22T16:18:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI9Lw",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:19:33Z",
          "updatedAt": "2026-01-22T16:19:34Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Convincing, especially now that I understood what `TYPEXXX` is meant for :)",
              "createdAt": "2026-01-22T16:19:33Z",
              "updatedAt": "2026-01-22T16:19:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI_As",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:20:55Z",
          "updatedAt": "2026-01-22T16:20:55Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> [\u2026] especially if we already know we would only ever use ASCII strings here.\r\n\r\nNot sure where this ASCII constraint is coming from, btw... Text strings in CBOR are UTF-8. And binary strings do not carry any encoding AFAIK.",
              "createdAt": "2026-01-22T16:20:55Z",
              "updatedAt": "2026-01-22T16:20:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cI_E2",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:20:59Z",
          "updatedAt": "2026-01-22T16:20:59Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "No, but it would if it were `[[\"example\", \"org\", dns-rt'ANY', dns-rc'ANY']]`!",
              "createdAt": "2026-01-22T16:20:59Z",
              "updatedAt": "2026-01-22T16:20:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cJAca",
          "commit": {
            "abbreviatedOid": "61a175b"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T16:22:18Z",
          "updatedAt": "2026-01-22T16:22:18Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "True, my bad.",
              "createdAt": "2026-01-22T16:22:18Z",
              "updatedAt": "2026-01-22T16:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cOJV_",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-22T21:35:54Z",
          "updatedAt": "2026-01-22T21:35:54Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "See 96b48f30e20fe82b1f3cf21ee",
              "createdAt": "2026-01-22T21:35:54Z",
              "updatedAt": "2026-01-22T21:35:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVhL6",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:37:27Z",
          "updatedAt": "2026-01-23T09:37:27Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Good point, then I'd rephrase the above as\r\n\r\n> Ah so both `rt'XXX'` and `rt\"XXX\"` would be valid and equivalent? Not sure I like that design decision of allowing both, especially if we already know we would only ever use UTF-8 strings here.\r\n\r\n(I highly doubt RTYPE or RCLASS would have names that are not UTF-8 at some point, which would be an argument for allowing byte strings, but maybe I'm wrong?)\r\n\r\n",
              "createdAt": "2026-01-23T09:37:27Z",
              "updatedAt": "2026-01-23T09:37:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYQRj",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T12:52:44Z",
          "updatedAt": "2026-01-23T12:52:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Again, I just copied verbatim from the EDN draft. See https://github.com/cbor-wg/cbor-dns/pull/14#discussion_r2712525828. `dt` has the same wording as `ip`\r\n\r\n> The content of the literal is a single Standard Date/Time String as per Section [3.4.1](https://rfc-editor.org/rfc/rfc8949#section-3.4.1) of RFC 8949 [[STD94](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#STD94)], as a *text or byte string*.\r\n\r\n`hash` only says \"string\" and does not specify and `cri` does not mention strings at all:\r\n\r\n> The content of the literal is a single Standard Date/Time String as per Section [3.4.1](https://rfc-editor.org/rfc/rfc8949#section-3.4.1) of RFC 8949 [[STD94](https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#STD94)], as a text or byte string.\r\n\r\nGiven that `dt` and `ip` are the only ones that explicitly mention text and byte strings and from their semantic `rt` and `rc` are closer to them, why should they only allow byte strings while `dt` and `ip` also allow text strings. Not sure what this extra restriction would achieve.\r\n\r\n> > Ah so both `rt'XXX'` and `rt\"XXX\"` would be valid and equivalent? Not sure I like that design decision of allowing both, especially if we already know we would only ever use UTF-8 strings here.\r\n> \r\n> (I highly doubt RTYPE or RCLASS would have names that are not UTF-8 at some point, which would be an argument for allowing byte strings, but maybe I'm wrong?)\r\n\r\nYes, the definition of the mnemonics makes it clear that they are only ASCII (only upper case letters and digits, in fact) and it will be part of the ABNF once the format somewhat settles. But I am not sure what you expect from me here? I already refer to the definition and there is no dedicated type for ASCII strings in CBOR.",
              "createdAt": "2026-01-23T12:52:44Z",
              "updatedAt": "2026-01-23T12:52:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYvIW",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:26:49Z",
          "updatedAt": "2026-01-23T13:26:49Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I'm challenging the design decision in EDN that now trickled down into this draft of allowing both `ip'xxx'` and `ip\"xxx\"` even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.",
              "createdAt": "2026-01-23T13:26:49Z",
              "updatedAt": "2026-01-23T13:26:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cY1bi",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:33:48Z",
          "updatedAt": "2026-01-23T13:33:48Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> I'm challenging the design decision in EDN that now trickled down into this draft of allowing both ip'xxx' and ip\"xxx\" even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.\r\n\r\nBut what has the major type of the content to do with wether it is non-UTF8 or not? Both byte strings and text strings are allowed to carry UTF-8 in EDN. The only difference between them in [raw] EDN is the type of quotation marks and some differring rules on escaping (when necessary) as far as I understand.",
              "createdAt": "2026-01-23T13:33:48Z",
              "updatedAt": "2026-01-23T13:34:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cZFCe",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:47:41Z",
          "updatedAt": "2026-01-23T13:47:42Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> I'm challenging the design decision in EDN that now trickled down into this draft of allowing both `ip'xxx'` and `ip\"xxx\"` even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.\r\n\r\nCan you explain that decision some more?\r\n\r\nAs far as I can see, the grammar only allows\r\n\r\n```abnf\r\napp-string      = app-prefix sqstr\r\n```\r\n(where sqstr is a single-quoted string.)\r\n\r\nWe may need to add some text on the equivalence of ext'foo' and ext<<\"foo\">>, is that what you are criticizing?",
              "createdAt": "2026-01-23T13:47:41Z",
              "updatedAt": "2026-01-23T13:47:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cZJDy",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:51:05Z",
          "updatedAt": "2026-01-23T13:51:06Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) and rc'', but could this also be addressed with e''?\r\ne'' is really what was designed to address these cases.",
              "createdAt": "2026-01-23T13:51:06Z",
              "updatedAt": "2026-01-23T13:51:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7caOWm",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:41:37Z",
          "updatedAt": "2026-01-23T14:41:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> > I'm challenging the design decision in EDN that now trickled down into this draft of allowing both `ip'xxx'` and `ip\"xxx\"` even if they are equivalent and having non-UTF8 (actually anything else than numbers and dots or colons) is never needed. But given the precedent, I can live with it.\r\n> \r\n> Can you explain that decision some more?\r\n> \r\n> As far as I can see, the grammar only allows\r\n> \r\n> ```abnf\r\n> app-string      = app-prefix sqstr\r\n> ```\r\n> \r\n> (where sqstr is a single-quoted string.)\r\n\r\nMh, did not see that ABNF, but this discussion was purely based on the wording in https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-3.1-2 and https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-3.2-2 where it explicitly mentions text strings (double quoted as per https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-2.5.1) and byte strings (single quoted as per https://www.ietf.org/archive/id/draft-ietf-cbor-edn-literals-19.html#section-2.5.1).\r\n\r\n> We may need to add some text on the equivalence of ext'foo' and ext<<\"foo\">>, is that what you are criticizing?\r\n\r\nAt least I understand this equivalent and pretty sure @mguetschow does, too. As far as I understand, @mguetschow is concerned about a pure ASCII string being able to be expressible in two data types (but that's then where I am not sure what the actual problem is).",
              "createdAt": "2026-01-23T14:41:37Z",
              "updatedAt": "2026-01-23T14:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7caUo1",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:46:39Z",
          "updatedAt": "2026-01-23T14:46:40Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) and rc'', but could this also be addressed with e''?\r\n> e'' is really what was designed to address these cases.\r\n\r\nYou mean https://www.ietf.org/archive/id/draft-ietf-cbor-edn-e-ref-02.html? Only learned about this draft now, but from what I can gather: Yes, it could fit, but due to its temporary nature (as far as I understand this is meant for drafts) would probably mean continuous updating of the `e''` constants to stay in sync with the IANA tables later on. So having something fixed that can be used in more official documents (or even parsers/sniffers/...) would be great, IMHO.",
              "createdAt": "2026-01-23T14:46:39Z",
              "updatedAt": "2026-01-23T14:46:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7calWf",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:59:17Z",
          "updatedAt": "2026-01-23T14:59:17Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> > As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) and rc'', but could this also be addressed with e''?\r\n> > e'' is really what was designed to address these cases.\r\n> \r\n> You mean https://www.ietf.org/archive/id/draft-ietf-cbor-edn-e-ref-02.html? Only learned about this draft now, but from what I can gather: Yes, it could fit, but due to its temporary nature (as far as I understand this is meant for drafts) would probably mean continuous updating of the `e''` constants to stay in sync with the IANA tables later on. So having something fixed that can be used in more official documents (or even parsers/sniffers/...) would be great, IMHO.\r\n\r\nI dimly remember some work (I think it was even yours, @cabo) to import a IANA registry into _something_..., I couldn't find it that quickly in the datatracker (since I am unsure about the \"something\" I am not even sure where to search) but if the \"something\" was EDN, that would help more!",
              "createdAt": "2026-01-23T14:59:17Z",
              "updatedAt": "2026-01-23T14:59:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cbMo0",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T15:27:16Z",
          "updatedAt": "2026-01-23T15:27:17Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> As a general observation, we could add rt'' (indeed not a great abbrev, as rt usually is a CoAP resource type) [...]\r\n\r\nOk, conceding to a 2:1 vote then and changed the names to `dns-rrt` (DNS resource record type) and `dns-cls` (DNS class) in 0cf0f06",
              "createdAt": "2026-01-23T15:27:16Z",
              "updatedAt": "2026-01-23T15:27:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7ci4Ju",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T23:48:15Z",
          "updatedAt": "2026-01-23T23:48:15Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "`e''` and `ref''` extensions are good (though I don't remember their discussion in m.list right now), but are solving slightly different task: if all your data are described by authoritative primary source being CBOR-oriented, currently meaning CDDL.\r\nBut for DNS data such source is outside of us, and people are already accustomed for decades to textual form from RFC 1035. So I've put a top-level comment below about that we should take it different way...",
              "createdAt": "2026-01-23T23:48:15Z",
              "updatedAt": "2026-01-23T23:48:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7ci44T",
          "commit": {
            "abbreviatedOid": "e56f73e"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T23:49:57Z",
          "updatedAt": "2026-01-23T23:49:57Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "As per https://github.com/cbor-wg/cbor-dns/pull/14#issuecomment-3792984448, the\r\n`[[dns-rr'example.org ANY ANY']]`\r\nis looking much more better!",
              "createdAt": "2026-01-23T23:49:57Z",
              "updatedAt": "2026-01-23T23:49:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7eNTLL",
          "commit": {
            "abbreviatedOid": "45ec241"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-30T12:26:38Z",
          "updatedAt": "2026-01-30T12:26:38Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "`CNAME` is not used here, but in the examples of #16, so I already included it to not forget.",
              "createdAt": "2026-01-30T12:26:38Z",
              "updatedAt": "2026-01-30T12:26:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7eV2VE",
          "commit": {
            "abbreviatedOid": "45ec241"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-30T20:25:10Z",
          "updatedAt": "2026-01-30T20:25:10Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "So you postpone app-extensions for RRDATA also?",
              "createdAt": "2026-01-30T20:25:10Z",
              "updatedAt": "2026-01-30T20:25:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7eWEEg",
          "commit": {
            "abbreviatedOid": "45ec241"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-30T20:39:14Z",
          "updatedAt": "2026-01-30T20:39:14Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Yes, it is not used in our examples at the moment. If, and only if, we introduce some SVCB or OPT examples we can add some values for `e''` as well.",
              "createdAt": "2026-01-30T20:39:14Z",
              "updatedAt": "2026-01-30T20:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7eWSuL",
          "commit": {
            "abbreviatedOid": "45ec241"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-30T20:59:16Z",
          "updatedAt": "2026-01-30T20:59:16Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I mean, those are not just integers, they have syntax - options, cookie, etc... So are not `e''`.",
              "createdAt": "2026-01-30T20:59:16Z",
              "updatedAt": "2026-01-30T20:59:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7e2ktq",
          "commit": {
            "abbreviatedOid": "45ec241"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-02-02T11:29:24Z",
          "updatedAt": "2026-02-02T11:29:24Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "> I mean, those are not just integers, they have syntax - options, cookie, etc... So are not `e''`.\r\n\r\nNo, not like I have intended them. There they are just integers for OPT numbers and SvcParamKeys respectively.",
              "createdAt": "2026-02-02T11:29:24Z",
              "updatedAt": "2026-02-02T11:29:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOIM0M7M6-CFs7",
      "title": "Make options a list again",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/15",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "TBD28259 (see section Name Compression) put the final death nail into the idea of the EDNS(0) options being a map.",
      "createdAt": "2026-01-19T15:24:11Z",
      "updatedAt": "2026-01-27T09:47:20Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "491f40872d0a50ba8f4f87431b152501fb319d71",
      "headRepository": "miri64/cbor-dns",
      "headRefName": "opt-list",
      "headRefOid": "812bdbfba76c56c9578bce1352a4fbe3efe68b1f",
      "closedAt": "2026-01-27T09:47:16Z",
      "mergedAt": "2026-01-27T09:47:16Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "a36070680414deb0dd52b058664244237f9e3566"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "In the interest of consistency it probably makes sense to encode the list of options in the same manner as we do SvcParams (a flat list with interleaving optnum-optval-pairs). We do that their, because SvcParams MUST have a predetermined order, but does not hurt to do it here as well. Will do!",
          "createdAt": "2026-01-21T15:49:13Z",
          "updatedAt": "2026-01-21T15:50:14Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "I support making it array (so that *everything* structured is array which allows for subset coding in CBAPT, but this I'll write more detailed later in #12), however did not quite understand why name compression was that nail.\r\n\r\nThe only possible thing I may be suggesting here is to add a phrase that order of key-value pairs is, like in original DNS, not important (behaves like map) - for those fearless who could try to add determinism here in future...",
          "createdAt": "2026-01-23T23:40:05Z",
          "updatedAt": "2026-01-23T23:40:05Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> ..., however did not quite understand why name compression was that nail.\r\n\r\nBecause the order, strings appear within the object, is important with name compression. Unless when using deterministic encoding (or more specific just what used to be called `lexicographic-map-sorting` encoding constrained) there is no given order to maps in CBOR. So unless we enforce the encoding constraint we can't use maps within TBD28259. However, given that we don't have strings here in the keys, but unsigned ints, and those ints are to be in numerical order for SvcParamKeys, I'd rather avoid confusion and don't use such encoding constraints and just provide an order with the list encoding.",
          "createdAt": "2026-01-26T13:33:34Z",
          "updatedAt": "2026-01-26T13:33:34Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "Ah, so we could get different compressed size depending on order of strings within maps. Got it.\r\nWhere's the approve button here...",
          "createdAt": "2026-01-26T18:29:58Z",
          "updatedAt": "2026-01-26T18:29:58Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ah, so we could get different compressed size depending on order of strings within maps. Got it.\r\n> Where's the approve button here...\r\n\r\nNot a different size. Depending on how you write and in which programming language your encoder, e.g., use an in-memory representation of a hash map of objects first, and then convert to binary. This can actually completely mess up your references, as strings might not be in the same order in the binary as they were in your in-memory representation.",
          "createdAt": "2026-01-26T21:09:44Z",
          "updatedAt": "2026-01-26T21:09:44Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Where's the approve button here...\r\n\r\nUnder the \"Files changed\" tab.",
          "createdAt": "2026-01-26T21:10:08Z",
          "updatedAt": "2026-01-26T21:10:08Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Not a different size. Depending on how you write and in which programming language your encoder, e.g., use an in-memory representation of a hash map of objects first, and then convert to binary. This can actually completely mess up your references, as strings might not be in the same order in the binary as they were in your in-memory representation.\r\n\r\nAnd sure, a smart programmer will not make such a mistake, but let's try to prevent potentials for programmers to shoot themselves in the foot directly here.",
          "createdAt": "2026-01-26T21:11:47Z",
          "updatedAt": "2026-01-26T21:12:29Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> The only possible thing I may be suggesting here is to add a phrase that order of key-value pairs is, like in original DNS, not important (behaves like map) - for those fearless who could try to add determinism here in future...\r\n\r\nThought I amended something for that, but apparently, I forgot. Please wait with the merge until tomorrow when I can check my work machine.",
          "createdAt": "2026-01-26T21:14:56Z",
          "updatedAt": "2026-01-26T21:14:56Z"
        },
        {
          "author": "nuclight",
          "authorAssociation": "NONE",
          "body": "> > Ah, so we could get different compressed size depending on order of strings within maps. Got it.\r\n> > Where's the approve button here...\r\n> \r\n> Not a different size. Depending on how you write and in which programming language your encoder, e.g., use an in-memory representation of a hash map of objects first, and then convert to binary. This can actually completely mess up your references, as strings might not be in the same order in the binary as they were in your in-memory representation.\r\n\r\nAh, not thought about it. So I am not so smart programmer :) let's prevent foot guns directly.\r\n\r\n> Under the \"Files changed\" tab.\r\n\r\nDon't see it here either, but OK, let's wait.",
          "createdAt": "2026-01-26T22:09:37Z",
          "updatedAt": "2026-01-26T22:09:37Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thought I amended something for that, but apparently, I forgot. Please wait with the merge until tomorrow when I can check my work machine.\r\n\r\nDone.",
          "createdAt": "2026-01-27T09:23:55Z",
          "updatedAt": "2026-01-27T09:23:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M7bSjnk",
          "commit": {
            "abbreviatedOid": "4815fc5"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-19T17:23:00Z",
          "updatedAt": "2026-01-19T17:25:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\nThe next element is a array of tuples of the options, with the option code (unsigned integer) being the first tuple element and the option data (byte string) being the second tuple element.\n```\n\nDoes that match what you are trying to say?",
              "createdAt": "2026-01-19T17:23:00Z",
              "updatedAt": "2026-01-19T17:25:31Z"
            },
            {
              "originalPosition": 6,
              "body": "Mmmmh, doesn't this add 1B unnecessarily per tuple, also compared to the map encoding?\n\nMaybe this part also warrants a note on why you would not use maps instead of describing maps-semantics based on an array (-> ordering).\n\nBtw, would these options be ordered in any form, e.g., by option number?",
              "createdAt": "2026-01-19T17:25:14Z",
              "updatedAt": "2026-01-19T17:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7bx0Sj",
          "commit": {
            "abbreviatedOid": "4815fc5"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:31:47Z",
          "updatedAt": "2026-01-21T13:31:47Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I actually wanted to include as well, that the tuple has exactly 2 elements.... but maybe this can be done with\r\n\r\n```suggestion\r\nThe next element is a array of 2-tuples of the options, with the option code (unsigned integer) being the first tuple element and the option data (byte string) being the second tuple.\r\n```\r\n?",
              "createdAt": "2026-01-21T13:31:47Z",
              "updatedAt": "2026-01-21T13:31:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7byBR_",
          "commit": {
            "abbreviatedOid": "4815fc5"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-21T13:43:24Z",
          "updatedAt": "2026-01-21T13:43:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Mmmmh, doesn't this add 1B unnecessarily per tuple, also compared to the map encoding?\r\n>\r\n> Maybe this part also warrants a note on why you would not use maps instead of describing maps-semantics based on an array (-> ordering).\r\n\r\nSo you think we rather should put the lexicographic ordering encoding constrained from [from draft-ietf-cbor-serialization](https://www.ietf.org/archive/id/draft-ietf-cbor-serialization-01.html#section-4.1) here? Could be tricky to just get that out of there, since the draft does not define that independently as `draft-ietf-cbor-cde` did (while \"ordinary serialization\" is preferred, I don't think it should be a requirement). Maybe an incentive for the working group to have this defined independently? However ...\r\n\r\n> Btw, would these options be ordered in any form, e.g., by option number?\r\n\r\nSee [RFC 6891, section 6.1.2](https://datatracker.ietf.org/doc/html/rfc6891#section-6.1.2):\r\n\r\n>    The order of appearance of option tuples is not defined.  If one\r\n>    option modifies the behaviour of another or multiple options are\r\n>    related to one another in some way, they have the same effect\r\n>    regardless of ordering in the RDATA wire encoding.\r\n\r\nSo no. But continuing my parenthesis from above ... However, I think it is better to not put any requirement on the order of options on an encoder. This might come directly from another server. Putting then work into reordering the options seems like a waste to me and I have the hunch that it does not really help us with our problem for name compression here...",
              "createdAt": "2026-01-21T13:43:24Z",
              "updatedAt": "2026-01-21T13:43:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dI-yM",
          "commit": {
            "abbreviatedOid": "812bdbf"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2026-01-27T09:36:58Z",
          "updatedAt": "2026-01-27T09:36:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOIM0M7M6-y9dm",
      "title": "Pass on name compression",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/16",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This reworks the name compression as discussed during the last few meetings we had.\r\n\r\nNamely:\r\n\r\n- TBD28259 now appends, rather than prepends to existing packing tables to allow for single pass decoders with minimum state.\r\n-  Consequently, disallow inner table setup tags to TBD28259, as that would increase complexity of both decoders and encoders\r\n- Clarify implicit nature with `packed`\r\n- Use actual DNS examples\r\n- Add example decoder as pseudo-code\r\n- Additionally, add some considerations on maps within TBD28259 (see also #15)",
      "createdAt": "2026-01-22T21:30:42Z",
      "updatedAt": "2026-02-04T11:52:44Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "522aa6c432e7337edb27607a88edf305cd3d0b12",
      "headRepository": "miri64/cbor-dns",
      "headRefName": "tbd28259-order",
      "headRefOid": "c93675d3f4f3c592b30d9b462b826f41ae82e02a",
      "closedAt": "2026-02-04T11:52:40Z",
      "mergedAt": "2026-02-04T11:52:40Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "8c8ca76f58944a14ffd753fa2ed29f56357b5f9e"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Also added some code for straight references with the 113 tag.",
          "createdAt": "2026-01-29T11:31:41Z",
          "updatedAt": "2026-01-29T11:31:41Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we proceed with this? Not sure, if we want to discuss a new version on Wednesday, but would be a good milestone to have `-16` by then.",
          "createdAt": "2026-02-02T15:20:52Z",
          "updatedAt": "2026-02-02T15:20:52Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> What's the status of moving the pseudocode into the appendix?\r\n\r\n98dcd6db376a5667ae214f37aa3bc17dcdc2111f moves all examples to the appendices now and 81425c4aab3e72950b72d5ab3cbb2477e2aea9b5 references these appendices in the main body.",
          "createdAt": "2026-02-02T16:15:13Z",
          "updatedAt": "2026-02-02T16:15:13Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "And squashed.",
          "createdAt": "2026-02-02T16:16:39Z",
          "updatedAt": "2026-02-02T16:16:39Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased to current main and using `e''` EDN in examples now.",
          "createdAt": "2026-02-04T11:52:22Z",
          "updatedAt": "2026-02-04T11:52:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M7cUr0s",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks, this is a huge step forward. Some nits and a few major points below.",
          "createdAt": "2026-01-23T08:46:08Z",
          "updatedAt": "2026-01-23T09:30:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd argue that the order of adding the sequence and its suffixes could be more explicit. Maybe\n\n\n```suggestion\nAny coherent sequence of text strings encountered within the rump of tag TBD28259 when reading it depth-first, as well as any of its non-empty suffixes, ordered by sequence length, are added to the table as arrays marked with the splice integration tag 1115 (see {{-cbor-packed, Section 5.1}}).\n```",
              "createdAt": "2026-01-23T08:46:08Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 14,
              "body": "I think we could remove this sentence now that inner table setups are NOT RECOMMENDED (which is different to disallowed, as you state in the PR description, btw).",
              "createdAt": "2026-01-23T08:47:09Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\nIf a sequence for which a tagged array is already in _V_ is encountered, a shared item reference _i_ is added to the rump instead, splicing the content of the array within tag 1115 into the existing array (see {{-cbor-packed, Section 5.1}}) and that sequence as well as its non-empty suffixes is not added again to _V_.\n```",
              "createdAt": "2026-01-23T08:48:32Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 22,
              "body": "Do you mean future setup tags for dns+cbor? If so, I would explicitly say so.\n\nBut in any case I'd argue that this statement is not needed as it follows from the fact that table setup tags can define their semantics and (content) restrictions.",
              "createdAt": "2026-01-23T08:50:54Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\nDue to the order of strings being important, special care should be taken for the order of map (major type 5, {{-cbor}}) elements within tag TBD28259.\n```\n\nThis sentence could actually start a new paragraph.",
              "createdAt": "2026-01-23T08:51:54Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\nIf any other CBOR object than an object defined by `dns-message` in {{fig:dns-msg}} is compressed using TBD28259, map elements MUST be encoded in bytewise lexicographic order of their keys, as specified in {{Section 4.2.1 of -cbor}}, unless the definition of that particular object type provides a different predetermined order.\n```",
              "createdAt": "2026-01-23T08:53:16Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\nIf the decoder encounters an object marked with \"application/dns+cbor;packed=0\" that is tagged TBD28259, it MUST NOT discard it and treat the tag as explicit.\n```\n\nor is there a reason not to capitalize it?",
              "createdAt": "2026-01-23T08:54:11Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\nOtherwise, it might incur an additional message to be sent and media type negotiation might fail unnecessarily.\n```",
              "createdAt": "2026-01-23T08:55:49Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 34,
              "body": "Also, what does \"treat the tag as explicit\" mean? I'd rather say it the other way around, i.e. \"treat the content of the tag as the object, i.e., ignoring the explicit tag\".",
              "createdAt": "2026-01-23T08:57:00Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 37,
              "body": "Why \"only within _V_\"? Why couldn't I (for some reason) add a 1115-tagged array in my outer setup table provided to 113?",
              "createdAt": "2026-01-23T08:58:10Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\nAlso note that, e.g., the sequence \"www\", \"example\", \"org\" (appears as index 0) is not referenced as `simple(0)` within index 3 as this is how _V_ would be read given {{fig:name-compression-example-unpacked}}.\n```",
              "createdAt": "2026-01-23T09:00:47Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\nNote that the sequence \"org\", \"example\", \"org\" is added at index 4 with leading \"org\", instead of referencing index 2 + index 1 (`simple(2), simple(1)`), as it is its own distinct suffix sequence.\nIts suffix \"example\", \"org\" is however not added to the table again, as it is already present at index 2.\n```\n\nJust to make it more explicit.",
              "createdAt": "2026-01-23T09:01:51Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 283,
              "body": "```suggestion\n(see {{Section 3.1 of -cbor-packed}}) compressing the name-compressed response as rump.\n```",
              "createdAt": "2026-01-23T09:05:09Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 299,
              "body": "```suggestion\nPacked-Text-String-Suffix-Sequence-Packed-CBOR = #6.113(\n```\n\n(typo :P)",
              "createdAt": "2026-01-23T09:05:51Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 311,
              "body": "So this means sending tag 113 explicitly is _not_ allowed, while sending tag TBDnc for `packed=0` MUST be accepted? But sending TBDnc explicitly within `packed=1` is again disallowed? Why this difference?\n\nAs argued offline, I'd rather prohibit the explicit tag TBDnc for `packed=0` as well, as I see no benefit of allowing it, but might lead to confusion of the reader of the document and potential encoder implementation that introduce 3B of overhead in every response. But if we allow it for `packed=0`, we should also for `packed=1`, and for both tags.",
              "createdAt": "2026-01-23T09:12:17Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 314,
              "body": "Okay, this was a bit surprising for me. Maybe make it more explicit that `packed=0` can be used for both queries and responses above.",
              "createdAt": "2026-01-23T09:13:31Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 371,
              "body": "```suggestion\nNote, that the encoder needs to rewrite the references from {{fig:name-compression-example-unpacked}} as the implicit table _V_ is appended to the shared argument table `[\"org\", 600]`.\n```\n\nwhy confusing the reader by describing it the other way round here?",
              "createdAt": "2026-01-23T09:15:39Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 481,
              "body": "Thanks for the pseudocode! I would move it to the appendix, though.",
              "createdAt": "2026-01-23T09:16:45Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 501,
              "body": "This is invalid according to https://github.com/cbor-wg/cbor-dns/pull/16/changes#r2720352516",
              "createdAt": "2026-01-23T09:17:47Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 543,
              "body": "This could be misinterpreted to get the reference to the tag 1115.\n\nI think what you mean is storing the index of the last start of a consecutive string sequence, right? Maybe it's clearer if you get the index here...",
              "createdAt": "2026-01-23T09:25:28Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 552,
              "body": "... and iterate from that index here (and below)",
              "createdAt": "2026-01-23T09:25:40Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 567,
              "body": "I fear this could break if for some reason \"example\" would have been part of the outer 113-packing table in our running example. Maybe worth going through step-by-step again to double-check.",
              "createdAt": "2026-01-23T09:27:44Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 580,
              "body": "```suggestion\n          /* not part of a name anymore, so close local name reference */\n```",
              "createdAt": "2026-01-23T09:28:20Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            },
            {
              "originalPosition": 588,
              "body": "```suggestion\n              result.append(Tag(elem.value, _rec_unpack_names(elem.content, unpacker)))\n```",
              "createdAt": "2026-01-23T09:29:23Z",
              "updatedAt": "2026-01-23T09:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVhyX",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:37:57Z",
          "updatedAt": "2026-01-23T09:37:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "It's not ordered by sequence length. Its ordered by appearance in the rump (which coincides of course with the length for a sequence of strings; but ordered by length could make this make misunderstandable). I think \"ordered by appearance\" just duplicates the first half of the sentence, but if it helps getting a better idea, I can add it.",
              "createdAt": "2026-01-23T09:37:57Z",
              "updatedAt": "2026-01-23T09:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVqyl",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:45:47Z",
          "updatedAt": "2026-01-23T09:45:48Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "> This could be misinterpreted to get the reference to the tag 1115.\r\n\r\nI'm confused... I _want_ (an array of) references to whatever is in the packing table here, so yes to tag 1115. That's why I use `table_entry.`_`content`_ to append the string to all table rows down in l1014 which in my pseudo-code accesses the content of a tag.\r\n\r\n> I think what you mean is storing the index of the last start of a consecutive string sequence, right? Maybe it's clearer if you get the index here... \r\n\r\nNo, I want a reference to the last few string sequence_s_, including all the suffixes that came before, so I can append the current string to _all_",
              "createdAt": "2026-01-23T09:45:48Z",
              "updatedAt": "2026-01-23T09:45:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVrW1",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:46:20Z",
          "updatedAt": "2026-01-23T09:46:20Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "Not sure, how to help here. The comments already describe what I was saying.",
              "createdAt": "2026-01-23T09:46:20Z",
              "updatedAt": "2026-01-23T09:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVsfs",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:47:27Z",
          "updatedAt": "2026-01-23T09:47:28Z",
          "comments": [
            {
              "originalPosition": 552,
              "body": "mhh... if it really helps, I can use indexes. Maybe indeed more useful from a C perspective, too.",
              "createdAt": "2026-01-23T09:47:27Z",
              "updatedAt": "2026-01-23T09:47:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cVt0t",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:48:50Z",
          "updatedAt": "2026-01-23T09:48:50Z",
          "comments": [
            {
              "originalPosition": 567,
              "body": "??!? the outer packing table should not be touched here, as it is before the reference that the _local variable_ `name_ref` carries.",
              "createdAt": "2026-01-23T09:48:50Z",
              "updatedAt": "2026-01-23T09:48:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cV3Kc",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T09:57:35Z",
          "updatedAt": "2026-01-23T09:57:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm referring to the order of the suffixes. Going by your description, I would have `1115([\"www\"]), 1115([\"www\", \"example\"]), 1115([\"www\", \"example\", \"org\"])` as my first three packing table entries, as \"www\" appears first in the rump.\r\n\r\nSo the idea is: Identify coherent sequences of text strings. For each of them, in order of appearance in the rump, you add the sequence and all its non-empty suffixes starting from the longest suffix.\r\n\r\nNot sure how to phrase that in an easily understandable way. Maybe breaking the sentence into several parts.",
              "createdAt": "2026-01-23T09:57:35Z",
              "updatedAt": "2026-01-23T09:57:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cV-zP",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:03:21Z",
          "updatedAt": "2026-01-23T10:03:21Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "> I'm confused... I _want_ (an array of) references to whatever is in the packing table here, so yes to tag 1115.\r\n\r\nBut if you get a reference to tag 1115, then you get the reference only to this one entry, and not to the subsequent ones?\r\n\r\n> No, I want a reference to the last few string sequence_s_, including all the suffixes that came before, so I can append the current string to _all_\r\n\r\nbefore the current string, but after the tag 1115 that is stored in `name_ref` right? This is where it is confusing for me, when you store `name_ref`, it is at the end of the packing table, and these suffixes are only added afterwards. That's why I think indexes are much clearer.",
              "createdAt": "2026-01-23T10:03:21Z",
              "updatedAt": "2026-01-23T10:03:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWAZx",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:04:57Z",
          "updatedAt": "2026-01-23T10:04:57Z",
          "comments": [
            {
              "originalPosition": 567,
              "body": "Sure, but we are decoding, we have (for some reason) `[\"example\"]` as our 113 packing table, and we encounter `\"www\", simple(0), \"org\"`.",
              "createdAt": "2026-01-23T10:04:57Z",
              "updatedAt": "2026-01-23T10:04:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWM9x",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:18:15Z",
          "updatedAt": "2026-01-23T10:18:15Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "The outer setup table is not part of the TBD28259 table setup and comes with its own sets of rules. But I guess this point became moot since there are no inner table setups with TBD28259, and https://datatracker.ietf.org/doc/html/draft-ietf-cbor-packed#section-5-2 makes it clear that integration tags are only allowed in reference tables.",
              "createdAt": "2026-01-23T10:18:15Z",
              "updatedAt": "2026-01-23T10:18:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWQjU",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:22:16Z",
          "updatedAt": "2026-01-23T10:22:16Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "> So this means sending tag 113 explicitly is _not_ allowed, while sending tag TBDnc for `packed=0` MUST be accepted? But sending TBDnc explicitly within `packed=1` is again disallowed? Why this difference?\n\nBecause our argument confused me now \ud83d\ude05. Of course tag 113 is also allowed explicitly. Should I put it into the rule again or just mention it here.",
              "createdAt": "2026-01-23T10:22:16Z",
              "updatedAt": "2026-01-23T10:25:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWRKu",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:23:00Z",
          "updatedAt": "2026-01-23T10:23:01Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "This has _always_ been the case for `packed=1`, so I am a bit confused how this surprised you.",
              "createdAt": "2026-01-23T10:23:00Z",
              "updatedAt": "2026-01-23T10:23:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWSBG",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:24:01Z",
          "updatedAt": "2026-01-23T10:24:01Z",
          "comments": [
            {
              "originalPosition": 481,
              "body": "Agreed, but let's keep it here for the review first.",
              "createdAt": "2026-01-23T10:24:01Z",
              "updatedAt": "2026-01-23T10:24:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWTUy",
          "commit": {
            "abbreviatedOid": "38db69f"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:25:31Z",
          "updatedAt": "2026-01-23T10:25:31Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "See https://github.com/cbor-wg/cbor-dns/pull/16/changes#r2720612202",
              "createdAt": "2026-01-23T10:25:31Z",
              "updatedAt": "2026-01-23T10:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cWXPd",
          "commit": {
            "abbreviatedOid": "0b62f08"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T10:29:10Z",
          "updatedAt": "2026-01-23T10:29:10Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "> Maybe make it more explicit that `packed=0` can be used for both queries and responses above.\n\nhttps://github.com/cbor-wg/cbor-dns/pull/16/changes#diff-c1ee54122d8c0f166af4524c64e92b0795cd43782536a16364a57a948d8cc838R600 isn't explicit enough?",
              "createdAt": "2026-01-23T10:29:10Z",
              "updatedAt": "2026-01-23T10:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cXqDx",
          "commit": {
            "abbreviatedOid": "0b62f08"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T12:04:30Z",
          "updatedAt": "2026-01-23T12:04:40Z",
          "comments": [
            {
              "originalPosition": 543,
              "body": "Ah, true I meant `[-1:]` instead of `[:-1]` \ud83d\ude05 will go for indexes, then it should be clearer.",
              "createdAt": "2026-01-23T12:04:30Z",
              "updatedAt": "2026-01-23T12:04:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cXxyz",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T12:14:10Z",
          "updatedAt": "2026-01-23T12:14:10Z",
          "comments": [
            {
              "originalPosition": 567,
              "body": "Ah, right, those would need to be resolved first.",
              "createdAt": "2026-01-23T12:14:10Z",
              "updatedAt": "2026-01-23T12:14:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYfHR",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:10:21Z",
          "updatedAt": "2026-01-23T13:10:21Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "No, don't put the rule in again, that will make it more confusing. As stated before, I'd ideally have a sentence mirroring what is said above about TBDnc but for 113.\r\n\r\nEDIT: seen, you've already added that.",
              "createdAt": "2026-01-23T13:10:21Z",
              "updatedAt": "2026-01-23T13:21:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYf_k",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:11:20Z",
          "updatedAt": "2026-01-23T13:11:21Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "Yes, thats enough, thanks for making it explicit.",
              "createdAt": "2026-01-23T13:11:20Z",
              "updatedAt": "2026-01-23T13:15:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cYjEL",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:14:38Z",
          "updatedAt": "2026-01-23T13:14:39Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Minor: something in this sentence is off grammatically. Maybe missing a \"for\".\n\nBut I'd also argue that the whole sentence is mood as in why would I expect another integration tag to be used, if it was not defined to be used above?",
              "createdAt": "2026-01-23T13:14:39Z",
              "updatedAt": "2026-01-23T13:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cY5S9",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T13:37:35Z",
          "updatedAt": "2026-01-23T13:37:35Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> But I'd also argue that the whole sentence is mood as in why would I expect another integration tag to be used, if it was not defined to be used above?\r\n\r\nThe sentence is required by `-packed`:\r\n\r\n> Application protocol specifications need to be **explicit about which integration tags are in use** [...]\r\n\r\nThe rest I will look into, once I have a physical keyboard under my fingers again. ",
              "createdAt": "2026-01-23T13:37:35Z",
              "updatedAt": "2026-01-23T13:37:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7caRBO",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-23T14:43:44Z",
          "updatedAt": "2026-01-23T14:43:44Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Fun, well, good point indeed.",
              "createdAt": "2026-01-23T14:43:44Z",
              "updatedAt": "2026-01-23T14:43:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7cjGNq",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2026-01-24T00:20:21Z",
          "updatedAt": "2026-01-24T13:42:34Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Why had it lost `simple(0)` ? Constrained implementations probably will want to save some memory as table _V_ already grows fast.\r\n\r\nUPD: I see a paragraph about it below at line 720 but phrasing is not clear to me.",
              "createdAt": "2026-01-24T00:20:21Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 509,
              "body": "What does `register()`  method of unpacker do?",
              "createdAt": "2026-01-24T13:21:50Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 545,
              "body": "This pseudocode looks more like some existing language which may be unfamiliar to significant part of readers. The pseudocode should be more similar to English prose, prog.language-independent. While `if` and `for` are ubiquitous, `match`/`type_match` are not so.\r\nAlso, it's better to use CBOR types - what is `None` when mapped to CBOR? Is it `null` or `undef`? Probably this line should look like:\r\n`idx: Int or null = null`\r\n\r\nAnd also we call it `map` in CBOR instead of JavaScript's `Object`.",
              "createdAt": "2026-01-24T13:29:10Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 560,
              "body": "What is `content` here?",
              "createdAt": "2026-01-24T13:30:57Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 559,
              "body": "`range` may be different in different programming languages. In pseudocode it is better (less ambiguously) written as:\r\n\r\n`for i := idx to unpacker.packing_table.length inclusive {`\r\n\r\nbecause off-by-one errors are too common.",
              "createdAt": "2026-01-24T13:32:28Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 502,
              "body": "`value` and `content` sound too synonymous. I think better names would be `tag_number` and `tag_content`.",
              "createdAt": "2026-01-24T13:39:12Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 585,
              "body": "What does `extend()` method do?",
              "createdAt": "2026-01-24T13:40:27Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            },
            {
              "originalPosition": 481,
              "body": "I was unable to grok algorithm in 5 minutes. I'll try again and return if it should be made more \"pseudo\".",
              "createdAt": "2026-01-24T13:42:25Z",
              "updatedAt": "2026-01-24T13:42:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c40so",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T12:44:06Z",
          "updatedAt": "2026-01-26T12:44:06Z",
          "comments": [
            {
              "originalPosition": 560,
              "body": "`.content` is used to access the tag content",
              "createdAt": "2026-01-26T12:44:06Z",
              "updatedAt": "2026-01-26T12:44:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c41sH",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T12:45:11Z",
          "updatedAt": "2026-01-26T12:45:11Z",
          "comments": [
            {
              "originalPosition": 502,
              "body": "+1 for tag number instead of value, but I'd leave out the `tag_` prefix",
              "createdAt": "2026-01-26T12:45:11Z",
              "updatedAt": "2026-01-26T12:45:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c42r9",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T12:46:26Z",
          "updatedAt": "2026-01-26T12:46:26Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "extending an array (in-place) by another array, as in\r\n\r\n```\r\n[1,2].extend([3,4]) == [1,2,3,4]\r\n```",
              "createdAt": "2026-01-26T12:46:26Z",
              "updatedAt": "2026-01-26T12:46:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c5QzC",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T13:17:56Z",
          "updatedAt": "2026-01-26T13:17:56Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Before _V_ was more how a decoder would see it. Since the construction algorithm above is more from an encoder view, I decided to bring it more in line with that. Still, an encoder can decide to use the reference here (as described below), as it will eventually find it when searching for `\"www\", \"example\", \"org\"`. Memory isn't that much of an issue here as _V_ is an implicit table. I find it more important to be in line with the text to understand the construction of _V_ than prematurely provide optimizations for implementers.",
              "createdAt": "2026-01-26T13:17:56Z",
              "updatedAt": "2026-01-26T13:17:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c5SpA",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T13:19:57Z",
          "updatedAt": "2026-01-26T13:19:57Z",
          "comments": [
            {
              "originalPosition": 509,
              "body": "Tell it that \"113\" is a setup tag. In my mind, this would allow the unpacker to recognize references in the first place (e.g., simple values can be, as we know, used for something else in different contexts). But maybe I am shooting over the target here.",
              "createdAt": "2026-01-26T13:19:57Z",
              "updatedAt": "2026-01-26T13:19:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c5UTj",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T13:21:57Z",
          "updatedAt": "2026-01-26T13:21:57Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "> This pseudocode looks more like some existing language which may be unfamiliar to significant part of readers. The pseudocode should be more similar to English prose, prog.language-independent. While `if` and `for` are ubiquitous, `match`/`type_match` are not so.\r\n> Also, it's better to use CBOR types - what is `None` when mapped to CBOR? Is it `null` or `undef`? Probably this line should look like:\r\n> `idx: Int or null = null`\r\n\r\nAgreed. My pseudo code could be more pseudo and not some wild mixture of Python and Rust ^^.\r\n\r\n> And also we call it `map` in CBOR instead of JavaScript's `Object`.\r\n\r\nObject isn't meant to be an Object in the JavaScript sense here, but a general CBOR-represented object that we do not know the type of (yet). In OOP, all major types would inherit from Object. But again, I guess this needs to be more generalistic.",
              "createdAt": "2026-01-26T13:21:57Z",
              "updatedAt": "2026-01-26T13:21:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c-ziC",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T18:42:35Z",
          "updatedAt": "2026-01-26T18:42:35Z",
          "comments": [
            {
              "originalPosition": 509,
              "body": "Just that reminds me we discussed registering things for Tag Equivalence on one of cbor-packed meetings in December. But probably your intent was different: does\r\n```\r\n/* make simple(N) and 6() references behave as per cbor-packed */\r\nunpacker.we_are_in_cbor-packed_rump_now(true)\r\n```\r\ndescribe what you wanted to express or something missing yet?",
              "createdAt": "2026-01-26T18:42:35Z",
              "updatedAt": "2026-01-26T18:42:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c_DK6",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T18:57:47Z",
          "updatedAt": "2026-01-26T18:57:59Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "So the ambiguity had rise because usually such RFCs are written from decoder's point of view (encoder's parts are non-default explicitly marked), and line 718 left text from decoder's part. Memory has some issue on constrained devices because _V_ grows faster than in 113's case. May be make two figures, for encoder and decoder, with corresponding comments? 720 has thus ambiguity currently.",
              "createdAt": "2026-01-26T18:57:47Z",
              "updatedAt": "2026-01-26T18:57:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c_IzP",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T19:01:47Z",
          "updatedAt": "2026-01-26T19:01:47Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "I'd suggest SQL's style as English-enough here:\r\n```\r\ncase typeof(X)\r\nwhen Array then {...\r\n```\r\n\r\nFor Object, to not include these explanations, in assumption that reader will read code more than once, I think adding just one line in appropriate place could give enough hint:\r\n`when Map then throw error \"Maps were supported in pre-RFC version, upgrade your code\"`",
              "createdAt": "2026-01-26T19:01:47Z",
              "updatedAt": "2026-01-26T19:02:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c_LlG",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T19:03:51Z",
          "updatedAt": "2026-01-26T19:03:51Z",
          "comments": [
            {
              "originalPosition": 560,
              "body": "Again too generic, better have `tag_content` in such places for clarity.",
              "createdAt": "2026-01-26T19:03:51Z",
              "updatedAt": "2026-01-26T19:03:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c_NwZ",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T19:05:58Z",
          "updatedAt": "2026-01-26T19:05:59Z",
          "comments": [
            {
              "originalPosition": 502,
              "body": "I'd agree if we were in real programming language (terseness is one of things for which I love Perl), but in standard specification clarity is better and verboseness is not a problem (we write it once).",
              "createdAt": "2026-01-26T19:05:58Z",
              "updatedAt": "2026-01-26T19:05:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7c_QKz",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-26T19:08:39Z",
          "updatedAt": "2026-01-26T19:08:39Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Ah, those `push_back`, `push_front` in different languages... So in pseudocode it reads\r\n\r\n`add elements of packed_obj.tag_content array to end of result array`\r\n\r\nwhich you can try to translate to your \"language\" if it is needed :)",
              "createdAt": "2026-01-26T19:08:39Z",
              "updatedAt": "2026-01-26T19:09:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dI093",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T09:27:42Z",
          "updatedAt": "2026-01-27T09:27:42Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "That's maybe turning into bikeshedding, but I really prefer the `match` syntax instead of your switch-case example, arguing that it is even harder to grasp the context in further `when` statements below.\r\n\r\nIf this gets too controversial, we could also simply use several if-else-ifs.",
              "createdAt": "2026-01-27T09:27:42Z",
              "updatedAt": "2026-01-27T09:27:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dI172",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T09:28:36Z",
          "updatedAt": "2026-01-27T09:28:36Z",
          "comments": [
            {
              "originalPosition": 560,
              "body": "In this place I actually do agree it would help for clarity. So yes, +1 for switching to `tag_content` and `tag_number`.",
              "createdAt": "2026-01-27T09:28:36Z",
              "updatedAt": "2026-01-27T09:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dJUjo",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T09:56:01Z",
          "updatedAt": "2026-01-27T09:56:01Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "See 3a6b9b5.",
              "createdAt": "2026-01-27T09:56:01Z",
              "updatedAt": "2026-01-27T09:56:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dJWod",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T09:57:54Z",
          "updatedAt": "2026-01-27T09:57:54Z",
          "comments": [
            {
              "originalPosition": 509,
              "body": "> [...] does\r\n>\r\n> ```\r\n> /* make simple(N) and 6() references behave as per cbor-packed */\r\n> unpacker.we_are_in_cbor-packed_rump_now(true)\r\n> ```\r\n> \r\n> describe what you wanted to express or something missing yet?\r\n\r\nI would even say `unpacker.we_are_in_cbor-packed-table-setup-113-rump-now(true)` as future, currently unspecified, table setup tags may choose to have different reference tags.",
              "createdAt": "2026-01-27T09:57:54Z",
              "updatedAt": "2026-01-27T09:57:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dJXp0",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T09:58:52Z",
          "updatedAt": "2026-01-27T09:58:53Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "> That's maybe turning into bikeshedding, but I really prefer the `match` syntax instead of your switch-case example, arguing that it is even harder to grasp the context in further `when` statements below.\r\n> \r\n> If this gets too controversial, we could also simply use several if-else-ifs.\r\n\r\nIt's all pseudo-code. I will try to come up with something mostly universally intuitive.",
              "createdAt": "2026-01-27T09:58:53Z",
              "updatedAt": "2026-01-27T09:58:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dLn3I",
          "commit": {
            "abbreviatedOid": "3a6b9b5"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T12:05:52Z",
          "updatedAt": "2026-01-27T12:07:39Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "See 7578fa9",
              "createdAt": "2026-01-27T12:05:52Z",
              "updatedAt": "2026-01-27T12:07:39Z"
            },
            {
              "originalPosition": 559,
              "body": "It's exclusive actually, see 7578fa9",
              "createdAt": "2026-01-27T12:06:19Z",
              "updatedAt": "2026-01-27T12:07:39Z"
            },
            {
              "originalPosition": 560,
              "body": "See 7578fa9",
              "createdAt": "2026-01-27T12:06:28Z",
              "updatedAt": "2026-01-27T12:07:39Z"
            },
            {
              "originalPosition": 585,
              "body": "See 7578fa9, I just reused the already used `concat`.",
              "createdAt": "2026-01-27T12:06:42Z",
              "updatedAt": "2026-01-27T12:07:39Z"
            },
            {
              "originalPosition": 502,
              "body": "See 7578fa9.",
              "createdAt": "2026-01-27T12:07:04Z",
              "updatedAt": "2026-01-27T12:07:39Z"
            },
            {
              "originalPosition": 481,
              "body": "See 7578fa9.",
              "createdAt": "2026-01-27T12:07:15Z",
              "updatedAt": "2026-01-27T12:07:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dLthY",
          "commit": {
            "abbreviatedOid": "7578fa9"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T12:11:17Z",
          "updatedAt": "2026-01-27T12:16:12Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "s/obj/rump/",
              "createdAt": "2026-01-27T12:11:17Z",
              "updatedAt": "2026-01-27T12:16:12Z"
            },
            {
              "originalPosition": 59,
              "body": "28259",
              "createdAt": "2026-01-27T12:11:33Z",
              "updatedAt": "2026-01-27T12:16:12Z"
            },
            {
              "originalPosition": 138,
              "body": "`i == idx` to match above",
              "createdAt": "2026-01-27T12:14:07Z",
              "updatedAt": "2026-01-27T12:16:12Z"
            },
            {
              "originalPosition": 150,
              "body": "idx could probably have a more telling name, too",
              "createdAt": "2026-01-27T12:15:13Z",
              "updatedAt": "2026-01-27T12:16:12Z"
            },
            {
              "originalPosition": 186,
              "body": "... to result",
              "createdAt": "2026-01-27T12:16:00Z",
              "updatedAt": "2026-01-27T12:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dL6rG",
          "commit": {
            "abbreviatedOid": "a297c08"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-27T12:22:58Z",
          "updatedAt": "2026-01-27T12:22:58Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "here, too",
              "createdAt": "2026-01-27T12:22:58Z",
              "updatedAt": "2026-01-27T12:22:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dqTpf",
          "commit": {
            "abbreviatedOid": "1da6cd6"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T19:54:27Z",
          "updatedAt": "2026-01-28T19:54:27Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Forgotten comment that this is for `simple(N)/6(N)` to work.",
              "createdAt": "2026-01-28T19:54:27Z",
              "updatedAt": "2026-01-28T19:54:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dqWaR",
          "commit": {
            "abbreviatedOid": "1da6cd6"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T19:56:30Z",
          "updatedAt": "2026-01-28T19:56:31Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "`tag_content` ?",
              "createdAt": "2026-01-28T19:56:30Z",
              "updatedAt": "2026-01-28T19:56:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dqs3u",
          "commit": {
            "abbreviatedOid": "1da6cd6"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T20:14:25Z",
          "updatedAt": "2026-01-28T20:14:26Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Call here and below is without `outer_table_len` which has not default value in function description",
              "createdAt": "2026-01-28T20:14:26Z",
              "updatedAt": "2026-01-28T20:14:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dqxMm",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T20:18:13Z",
          "updatedAt": "2026-01-28T20:18:13Z",
          "comments": [
            {
              "originalPosition": 509,
              "body": "Well, in newer version (`Tell ...`) it is not yet in rump when we do setup for `unpacker` manually; may be move lines?\r\n\r\nAh, or it is due to references allowed inside table setup also? May be add comment or discuss tomorrow...",
              "createdAt": "2026-01-28T20:18:13Z",
              "updatedAt": "2026-01-28T20:18:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dq2Q1",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T20:23:19Z",
          "updatedAt": "2026-01-28T20:23:19Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "> That's maybe turning into bikeshedding, but I really prefer the `match` syntax instead of your switch-case example, arguing that it is even harder to grasp the context in further `when` statements below.\r\n> \r\n> If this gets too controversial, we could also simply use several if-else-ifs.\r\n\r\nWell, I made it somewhat redundant there: in SQL those `THEN` are delimiters for block before next `WHEN` so that you don't need braces or `begin/end`. So `then` may be omitted; as well as braces for single-line statements. That said, I still not understand your point about hard context and in what `match` syntax really differs from switch/case.\r\n\r\nHowever, we are not inventing real language here, a big opportunity to do this will be in CBOR-TPL (CBAPT/CBAR superset) and, especially, it's frontend languages :-)",
              "createdAt": "2026-01-28T20:23:19Z",
              "updatedAt": "2026-01-28T20:23:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dq4Ho",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T20:25:11Z",
          "updatedAt": "2026-01-28T20:25:11Z",
          "comments": [
            {
              "originalPosition": 481,
              "body": "Yeah, that's better! It has some inconsistencies though, `function` vs `fn` :-)",
              "createdAt": "2026-01-28T20:25:11Z",
              "updatedAt": "2026-01-28T20:25:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7dq4wc",
          "commit": {
            "abbreviatedOid": "7578fa9"
          },
          "author": "nuclight",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-28T20:26:00Z",
          "updatedAt": "2026-01-28T20:26:00Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Why? Isn't that assignment?",
              "createdAt": "2026-01-28T20:26:00Z",
              "updatedAt": "2026-01-28T20:26:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d2sUZ",
          "commit": {
            "abbreviatedOid": "1da6cd6"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T11:19:55Z",
          "updatedAt": "2026-01-29T11:19:55Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Addressed in 35d621e",
              "createdAt": "2026-01-29T11:19:55Z",
              "updatedAt": "2026-01-29T11:19:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d2scf",
          "commit": {
            "abbreviatedOid": "1da6cd6"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T11:20:03Z",
          "updatedAt": "2026-01-29T11:20:04Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Addressed in 35d621e",
              "createdAt": "2026-01-29T11:20:03Z",
              "updatedAt": "2026-01-29T11:20:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d2sko",
          "commit": {
            "abbreviatedOid": "1da6cd6"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T11:20:09Z",
          "updatedAt": "2026-01-29T11:20:09Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Addressed in 35d621e",
              "createdAt": "2026-01-29T11:20:09Z",
              "updatedAt": "2026-01-29T11:20:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d3STV",
          "commit": {
            "abbreviatedOid": "7578fa9"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T11:57:43Z",
          "updatedAt": "2026-01-29T11:57:43Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "> Why? Isn't that assignment?\r\n\r\nI decided to make inclusivity/exclusivity more explicit, so the iterator is now described as\r\n\r\n```\r\ni from idx == 0 /* read equals */ to i < end\r\n```",
              "createdAt": "2026-01-29T11:57:43Z",
              "updatedAt": "2026-01-29T11:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d3TWd",
          "commit": {
            "abbreviatedOid": "7578fa9"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T11:58:52Z",
          "updatedAt": "2026-01-29T11:58:52Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "in math this would be basically be\r\n\r\n$i \\in [0, end)$",
              "createdAt": "2026-01-29T11:58:52Z",
              "updatedAt": "2026-01-29T11:58:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d3VCv",
          "commit": {
            "abbreviatedOid": "7aba320"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T12:00:44Z",
          "updatedAt": "2026-01-29T12:00:44Z",
          "comments": [
            {
              "originalPosition": 481,
              "body": "Fixed in cc3d69e",
              "createdAt": "2026-01-29T12:00:44Z",
              "updatedAt": "2026-01-29T12:00:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d3ZpD",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T12:05:55Z",
          "updatedAt": "2026-01-29T12:05:55Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "> However, we are not inventing real language here, a big opportunity to do this will be in CBOR-TPL (CBAPT/CBAR superset) and, especially, it's frontend languages :-)\r\n\r\nLet's _not_ invent languages here at all (beyond DNS+CBOR and maybe some EDN... ;-)). Iff a document I can refer to exists and there is any chance of that becoming normative within the development time of this draft, I'd happily refer to it and change the pseudo-code later. For now, let's stick with understandable pseudo-code.\r\n\r\nBTW, the reason, I don't want to use `switch` or `case` here is because `switch`-`case`-statements in most programming languages are open-ended (i.e. need an explicit `break` or similar to not fall-through to the next case), while Rust's `match`-statements (or any pattern matching schemes in languages such as Haskell) do not do that.",
              "createdAt": "2026-01-29T12:05:55Z",
              "updatedAt": "2026-01-29T12:05:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d3bTT",
          "commit": {
            "abbreviatedOid": "55ed1d8"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T12:07:26Z",
          "updatedAt": "2026-01-29T12:07:26Z",
          "comments": [
            {
              "originalPosition": 545,
              "body": "> any pattern matching schemes in languages such as Haskell\r\n\r\nand before you get any ideas: No, I don't mean pattern matching in the sense of regexes or globs, just like they are used in basic Haskell (so matching to specific values, e.g.). ;-)",
              "createdAt": "2026-01-29T12:07:26Z",
              "updatedAt": "2026-01-29T12:07:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d615J",
          "commit": {
            "abbreviatedOid": "cc3d69e"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T14:46:00Z",
          "updatedAt": "2026-01-29T14:54:11Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Is this what you mean? I'd make it explicit.\n\n```diff\n-        elif (outer_table_len and unpacker.is_straight_reference(elem)) {\n+        elif (outer_table_len > 0 and unpacker.is_straight_reference(elem)) {\n```",
              "createdAt": "2026-01-29T14:46:00Z",
              "updatedAt": "2026-01-29T14:54:12Z"
            },
            {
              "originalPosition": 83,
              "body": "I'm not sure if I like the idea of explicitly supporting argument references in this pseudo-code, as nothing about it is dns+cbor specific, right? One might wonder,  why not also supporting inverted references?\n\nAlong the way, this introduces new syntax with `.get_arg` which is not needed anywhere else, is it?\n\nMaybe we could condense this branch by just saying \"handle argument references as per CBOR-packed, error if argument reference points outside of outer table\"",
              "createdAt": "2026-01-29T14:54:04Z",
              "updatedAt": "2026-01-29T14:54:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d82AL",
          "commit": {
            "abbreviatedOid": "cc3d69e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T16:16:34Z",
          "updatedAt": "2026-01-29T16:16:34Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I was just noticing, that while we step into 113, we do not really address it beyond shared refs in the pseudo-Code. Inverter refs are not really needed with dns+cbor due to name compression. ",
              "createdAt": "2026-01-29T16:16:34Z",
              "updatedAt": "2026-01-29T16:16:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7d82q7",
          "commit": {
            "abbreviatedOid": "cc3d69e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-01-29T16:17:07Z",
          "updatedAt": "2026-01-29T16:17:07Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n        elif (outer_table_len > 0 and unpacker.is_straight_reference(elem)) {\r\n```",
              "createdAt": "2026-01-29T16:17:07Z",
              "updatedAt": "2026-01-29T16:17:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7e7ewK",
          "commit": {
            "abbreviatedOid": "cc3d69e"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-02-02T15:19:32Z",
          "updatedAt": "2026-02-02T15:19:33Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I reverted parts of 2442fab now, see 7c75d64.",
              "createdAt": "2026-02-02T15:19:33Z",
              "updatedAt": "2026-02-02T15:19:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7e77dV",
          "commit": {
            "abbreviatedOid": "7c75d64"
          },
          "author": "mguetschow",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Just had another read-through and found some more minor nits.\n\nWhat's the status of moving the pseudocode into the appendix?",
          "createdAt": "2026-02-02T15:38:50Z",
          "updatedAt": "2026-02-02T15:56:53Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\nAny coherent sequence of text strings encountered within the rump of tag TBD28259 when reading it depth-first, as well as any of its non-empty suffixes, ordered by their appearance within the rump, are added to the table as arrays marked with the splice integration tag 1115 (see {{-cbor-packed, Section 5.1}}).\nIf a sequence for which a tagged array is already in _V_ is encountered, a shared item reference _i_ is added to the rump instead, splicing the content of the array within tag 1115 into the existing array (see {{-cbor-packed, Section 5.1}}) and that sequence as well as its non-empty suffixes are not added again to _V_.\n```\n\nI think it makes more sense to include the order in the first mention, not the second one.",
              "createdAt": "2026-02-02T15:38:50Z",
              "updatedAt": "2026-02-02T15:56:53Z"
            },
            {
              "originalPosition": 599,
              "body": "```suggestion\n          if (is_splice_tag(packed_obj) and\n              typeof(tag-content of packed_obj) is CBORTextString or\n              typeof(packed_obj) is CBORTextString) {\n```\n\nI think",
              "createdAt": "2026-02-02T15:53:13Z",
              "updatedAt": "2026-02-02T15:56:53Z"
            },
            {
              "originalPosition": 605,
              "body": "```suggestion\n                append elem to tag-content of unpacker.packing_table[i]\n```\n\nwe still have `.content` in several places",
              "createdAt": "2026-02-02T15:54:13Z",
              "updatedAt": "2026-02-02T15:56:53Z"
            },
            {
              "originalPosition": 599,
              "body": "Or could we even move that to the `is_splice_tag` function?",
              "createdAt": "2026-02-02T15:54:54Z",
              "updatedAt": "2026-02-02T15:56:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M7e8cPU",
          "commit": {
            "abbreviatedOid": "7c75d64"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2026-02-02T15:59:41Z",
          "updatedAt": "2026-02-02T15:59:41Z",
          "comments": [
            {
              "originalPosition": 599,
              "body": "No, the referenced will be an array of strings. I would rather put this into an `assume`.",
              "createdAt": "2026-02-02T15:59:41Z",
              "updatedAt": "2026-02-02T15:59:42Z"
            }
          ]
        }
      ]
    }
  ]
}
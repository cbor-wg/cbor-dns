{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-05-13T01:15:36.775514+00:00",
  "repo": "cbor-wg/cbor-dns",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOIM0M7M5t8SLz",
      "title": "Represent names as their compontents",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/2",
      "state": "CLOSED",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "During the [mailing list discussions of `-03`](https://mailarchive.ietf.org/arch/msg/cbor/JOHCCBOzC46PrSq-61MMev--mpU/), @chrysn proposed to represent names as their components instead of `tstr`, similar to how it is done in [draft-ietf-core-href](https://datatracker.ietf.org/doc/draft-ietf-core-href/):\r\n\r\n>     host-name   = (*text) ; lowercase, NFC labels\r\n>\r\n>   That is, rather than expressing some.hostname.example.com as `\"some.hostname.example.com\"`, it goes for `\"some\",  \"hostname\", \"example\", \"com\"`\r\n\r\nThere are several advantages to that representation:\r\n\r\n- If not put in their own array, but just verbatim into the arrays already used in the spec, we safe the list specifier, i.e, one byte at least\r\n- Dots (\".\") can be expressed as part of a name component without extra encoding (I don't think that is legal in DNS domain names; @chrysn says they can occur in DNS-SD service names though)\r\n- It would be more in line with how DNS encodes names (delimiter identifies the length of the following name component)\r\n   - This would have the additional advantage that we could use a DNS-like name compression (i.e. an int to refer to an offset in the CBOR binary). The only thing we need to do to make names also encodeable as `uint`s is to swap ttl in RR. This way, the first int in a CBOR array that potentially could contain names always would be identifiable as the name (questions always contain a name, so the first `uint` would just be the name).\r\n\r\nThe only disadvantage we found so far is that there is no straightforward way to use the value or inverted references for names with this... But maybe, if we have DNS-like name compression, this wouldn't be needed anyways.",
      "createdAt": "2023-08-10T06:43:08Z",
      "updatedAt": "2024-11-07T13:25:14Z",
      "closedAt": "2024-11-07T13:25:14Z",
      "comments": [
        {
          "author": "chrysn",
          "authorAssociation": "MEMBER",
          "body": "> I don't think that is legal in DNS domain names\n\nAIU it is perfectly legal in DNS, it's just that URIs can not (due to their interesting escaping rules) express that dot, not even with percent encoding (maybe punycode though?) -- so it works only where DNS names are never put into a URI.\n",
          "createdAt": "2023-08-10T07:09:28Z",
          "updatedAt": "2023-08-10T07:09:28Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is legal, but strongly discouraged: https://datatracker.ietf.org/doc/html/rfc1035#section-2.3.1",
          "createdAt": "2023-08-10T13:09:20Z",
          "updatedAt": "2023-08-10T13:09:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in the two most recent versions",
          "createdAt": "2024-11-07T13:25:14Z",
          "updatedAt": "2024-11-07T13:25:14Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOIM0M7M5t8Uu5",
      "title": "Pre-populated packing tables",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/3",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@chrysn wrote on the [CBOR mailing list](https://mailarchive.ietf.org/arch/msg/cbor/JOHCCBOzC46PrSq-61MMev--mpU/):\r\n\r\n> Are the packing tables pre-populated with any values? (\"_coap._udp.\"\r\n> and \".com\" would come to mind). If so, is the 1 in `;packed=1`\r\n> intended to serve as an extension point that dispatches the values of\r\n> the table?\r\n\r\nI really like this idea! However, some details need to be ironed out as this could go several (somewhat disjunct) routes:\r\n1. Are these extension points pre-defined tables?\r\n2. Do we use CRIs/URIs to identify and find tables (see e.g. https://datatracker.ietf.org/doc/draft-amsuess-cbor-packed-by-reference/)?\r\n3. Should the extension point be used in a similar manner as SCHC rule IDs, i.e., identify some pre-shared tables?\r\n\r\n1. and 3. don't necessarily contradict each other, as we could reserve number ranges for either pre-defined tables or pre-shared tables? 2. could also be integrated, e.g. with a dedicated number.",
      "createdAt": "2023-08-10T06:51:14Z",
      "updatedAt": "2023-08-10T06:51:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOIM0M7M6i7Am6",
      "title": "hex/EDN examples",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/8",
      "state": "OPEN",
      "author": "chrysn",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From today's interim:\r\n\r\n> @or13: Would be nice to see hex / EDN examples in this section: https://www.ietf.org/archive/id/draft-lenders-dns-cbor-10.html#name-dns-representation-in-cbor-",
      "createdAt": "2024-12-11T16:05:01Z",
      "updatedAt": "2024-12-11T16:05:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOIM0M7M6y_aZu",
      "title": "`AAAA` record compression",
      "url": "https://github.com/cbor-wg/cbor-dns/issues/9",
      "state": "OPEN",
      "author": "JeremyRand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello; I'm working with Tor Project on compact DNS zone files for usage in onion service descriptors. This spec caught our attention as potentially relevant. I have a question about how IPv6 addresses are represented.\n\nThe spec mentions:\n\n> Especially IPv6 addresses, e.g., in AAAA resource records can benefit from straight referencing to compress common address prefixes.\n\nHowever, this doesn't (unless I'm misreading) cover compression of individual IPv6 addresses. The example address used in the draft, `2001:db8::1`, uses 16 bytes, but it quite clearly has less entropy than this, as evidenced by the fact that its ASCII notation (certainly not optimal) is only 11 bytes long.\n\nWould there be interest in compression of IPv6 addresses? I did some experiments with real-world zone files, and found that the following algorithm worked pretty well:\n\n1. Convert IPv6 address to ASCII notation.\n2. Remove any redundant colons.\n3. Parse as base17.\n\nMaybe there's a better approach, I'm not sure. Curious what your thoughts are on whether IPv6 address compression is a reasonable thing to include within the scope of CBOR-DNS.\n\nBest regards.",
      "createdAt": "2025-04-17T16:34:16Z",
      "updatedAt": "2025-05-12T04:20:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting!\n\nThe assumption here was that \"hole\"-ey IPv6 addresses (with runs of zeros) mostly occur in manually constructed examples and that real-world IPv6 addresses are mostly filled with entropy.\n\nIs there a way you can provide some example data sets for us to look at?\n\nCBOR-Packed has a few tricks up its sleeve that we might want to use here, but then it does not focus on compression of the content of individual (atomic) data items.",
          "createdAt": "2025-04-17T16:43:23Z",
          "updatedAt": "2025-04-17T16:43:23Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "Hi!\n\n> Is there a way you can provide some example data sets for us to look at?\n\nI *think* I can provide the dataset that I was given, but let me double-check to make sure it's OK for me to share it.",
          "createdAt": "2025-04-17T16:50:22Z",
          "updatedAt": "2025-04-17T16:50:22Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "That would be really interesting! I did some cursory analysis back when I was thinking about that, but came to the same conclusion @cabo was mentioning: runs of zeros do not appear as often so that a string conversion\u2014which more than doubles the number of required bytes compared to the binary representation before we even can think about removing stuff\u2014would bring any benefit.",
          "createdAt": "2025-04-22T10:14:17Z",
          "updatedAt": "2025-04-22T10:14:17Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "@JeremyRand: We will have the next CBOR meeting on Wednesday this week, so having some real data that we could chew on and present would help us forward.\n",
          "createdAt": "2025-05-11T16:54:35Z",
          "updatedAt": "2025-05-11T16:54:35Z"
        },
        {
          "author": "JeremyRand",
          "authorAssociation": "NONE",
          "body": "I've just emailed you the zone files I was given (please let me know if they failed to arrive). Apologies for the delay.\n\nBased on this dataset, my findings were that the base17 approach I described above yielded a smaller size than the DNS wire format in all but two of the `AAAA` records in the dataset. Which would suggest that a potentially valid approach would be to define the format as \"If the `AAAA` data found in the CBOR is 16 bytes, treat it as DNS wire format, if it's less than 16 bytes, treat it as base17.\"\n\n(The savings aren't exactly massive, but they are significant for space-constrained systems like what we're working with.)",
          "createdAt": "2025-05-12T00:00:18Z",
          "updatedAt": "2025-05-12T00:00:18Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you.  The samples I find are highly skewed towards interface identifiers where only the lowest byte is non-zero; only some 3 % of the AAAA records have more bytes in use.  I don't think that is very typical, but it would be worth looking at this for a larger sample set.\n\nBesides the 97 % with a :: run of 7 bytes, there also may be some advantage from eliding leading zero nibbles in the hexlets -- normally the colon overhead would eat this advantage; but in the sample, 40 % of the hexlets don't have full quads (one would expect maybe 1 out of 16), and the average number of hex digits per quad is 2.92, with 30 % single-digit, so the colon conversion does help -- I'd consider this rather atypical as well.\n\nSo identifying a single run of zero bytes might be a near optimal solution that makes good use of the quirks of your sample data set.\nThis can be given as the start position of the run (0..15, and maybe 16 for no such run), and the length of the run can be derived as 16 minus the number of bytes remaining after removing the run.\nIn your sample, you would save almost 7 out of 16 bytes, minus paying a byte or so for the start position; a whopping 36 %.\n",
          "createdAt": "2025-05-12T04:20:09Z",
          "updatedAt": "2025-05-12T04:20:09Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOIM0M7M5XhDHB",
      "title": "Housekeeping",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/1",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-09T09:42:28Z",
      "updatedAt": "2023-08-09T15:46:09Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "6cb47d2b12a94d796511ad6f6bf4307a97af763b",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "housekeeping",
      "headRefOid": "36641398835e9837e8e5b77505dc30315414a8ba",
      "closedAt": "2023-08-09T15:46:01Z",
      "mergedAt": "2023-08-09T15:46:01Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "644f574a21471839d731eb87b596c8cb6542615d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M5dk3pl",
          "commit": {
            "abbreviatedOid": "3664139"
          },
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2023-08-09T15:45:46Z",
          "updatedAt": "2023-08-09T15:45:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOIM0M7M5co-6G",
      "title": "Create comparison table",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/4",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In https://mailarchive.ietf.org/arch/msg/cbor/KzRTl9QqtCiyMb4wYG_U542hjV0/ a comparison table was requested. This is a first draft for that.",
      "createdAt": "2023-10-12T14:20:44Z",
      "updatedAt": "2024-06-28T12:26:21Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "69b762130904ca9448679640a46f26f5d3c0781a",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "comparison-table",
      "headRefOid": "e2f6053399243ac2a99b83e7c35f727cecef427d",
      "closedAt": "2024-06-28T12:26:14Z",
      "mergedAt": "2024-06-28T12:26:14Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "b1a8e7557d6f1037094bec82f2baead42f227cd9"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I reworked the table according to an offline proposal by @cabo. Currently, I use an XML-table, since it does not seem to be possible with kramdown to have a two row header with row span, e.g., like this \r\n\r\n```markdown\r\n|----------|-----------------------------------------------|\r\n| Item     | RFC 1035 | application/dns+cbor [bytes]       |\r\n|          | format   | best    | realistic  | theoretical |\r\n|          | [bytes]  |         | worst      | worst       |\r\n|----------|---------:|--------:|-----------:|------------:|\r\n| Header   | 4        | 1       | 4          | 4           |\r\n|----------|----------|---------|------------|-------------|\r\n```\r\n\r\nIt renders somewhat correct but the table head rows are rendered incorrect:\r\n\r\n![image](https://github.com/anr-bmbf-pivot/draft-lenders-dns-cbor/assets/675644/61dd4e62-e252-459f-843c-c92547541444)\r\n\r\nbut I would interpret the kramdown doc differently\r\n\r\n> The first separator line after at least one table row is treated specially, namely as header separator line. It is used to demarcate header rows from normal table rows and/or to set column alignments. All table rows above the header separator line are considered to be header rows.\r\n\r\n(though this could be a local problem, as the Arch Linux kramdown package [wasn't updated in ages](https://archlinux.org/packages/extra/any/ruby-kramdown/), though there seems to be finally movement [in staging](https://archlinux.org/packages/extra-staging/any/ruby-kramdown/))",
          "createdAt": "2024-06-17T15:04:33Z",
          "updatedAt": "2024-06-17T15:04:33Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And yet another iteration. This time, I put the key for the CBOR format configuration into a separate table. I think this is the most readable version so far.",
          "createdAt": "2024-06-26T16:15:17Z",
          "updatedAt": "2024-06-26T16:15:17Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For reference: https://anr-bmbf-pivot.github.io/draft-lenders-dns-cbor/comparison-table/draft-lenders-dns-cbor.html#name-comparison-to-wire-format",
          "createdAt": "2024-06-26T16:16:39Z",
          "updatedAt": "2024-06-26T16:16:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOIM0M7M5v4eY-",
      "title": "Various changes from cabo for -07",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/5",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-19T08:47:45Z",
      "updatedAt": "2024-05-19T09:29:25Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "5454047df2e957cf9c47ae222c980be68d7509a8",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "cabo-07",
      "headRefOid": "964b1bc072385190075b10d0a0c4193322767479",
      "closedAt": "2024-05-19T09:29:12Z",
      "mergedAt": "2024-05-19T09:29:12Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "9fe12b3e5430cd3dfa9d8a4abbb312654960228a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M57Fe9F",
          "commit": {
            "abbreviatedOid": "964b1bc"
          },
          "author": "miri64",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-19T09:29:04Z",
          "updatedAt": "2024-05-19T09:29:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOIM0M7M6BK_Fj",
      "title": "Add capability to summarize rrsets",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/6",
      "state": "OPEN",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The capability to summarize resource records set was discussed in the past, but I stayed away from it so far, as it adds additional overhead. Well, we add overhead already, so lets add more overhead (but less that the overhead than duplicating TTL and type ;-)) to maybe still have it. This is my proposal to how to optionally provide summarized resource record sets.\r\n\r\nMaybe the CDDL can be streamlined, but at the moment, I don't see how.",
      "createdAt": "2024-11-07T11:05:10Z",
      "updatedAt": "2025-04-16T07:26:36Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "8e7957afb85235f33056f94db03e9eae655760a1",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "rrsets",
      "headRefOid": "d0705dbe935cd7d7f628218ef6a149e30aa22e39",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOIM0M7M6BVOlO",
      "title": "Make name compression be based on CBOR-packed",
      "url": "https://github.com/cbor-wg/cbor-dns/pull/7",
      "state": "MERGED",
      "author": "miri64",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During IETF 121 the idea came up to bring name compression to CBOR-packed after all by providing a special table setup tag. This is the work to that.",
      "createdAt": "2024-11-08T14:52:03Z",
      "updatedAt": "2025-04-16T11:42:01Z",
      "baseRepository": "cbor-wg/cbor-dns",
      "baseRefName": "main",
      "baseRefOid": "e82c5a3e5780d34bf78640c3a4ccab2c550e230f",
      "headRepository": "cbor-wg/cbor-dns",
      "headRefName": "name-comp-packed",
      "headRefOid": "ebe36d0bcce6732b153586fd2090a7401fe004c5",
      "closedAt": "2025-04-16T07:00:02Z",
      "mergedAt": "2025-04-16T07:00:02Z",
      "mergedBy": "miri64",
      "mergeCommit": {
        "oid": "8942b3613df00c4f380dfe432966e52f7939fe62"
      },
      "comments": [
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed...",
          "createdAt": "2025-04-16T06:39:04Z",
          "updatedAt": "2025-04-16T06:39:04Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "`s/level of packedness/packed value/g`",
          "createdAt": "2025-04-16T06:47:31Z",
          "updatedAt": "2025-04-16T06:47:31Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "Huh? Somehow, I messed this up when force pushing...",
          "createdAt": "2025-04-16T06:49:05Z",
          "updatedAt": "2025-04-16T06:49:20Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> `s/level of packedness/packed value/g`\r\n\r\nThis was meant to reference https://github.com/cbor-wg/cbor-dns/compare/25006971e1f4cb8210e400bc7b439e9bf34748e1..ccf2a04b19c65ddadb716dd8b469d1a7ffb823d4",
          "createdAt": "2025-04-16T06:50:19Z",
          "updatedAt": "2025-04-16T06:50:19Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "`s/CBOR-packed/Packed CBOR/`",
          "createdAt": "2025-04-16T06:55:13Z",
          "updatedAt": "2025-04-16T06:55:13Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "And rebased.",
          "createdAt": "2025-04-16T06:59:10Z",
          "updatedAt": "2025-04-16T06:59:10Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo gave his blessing to merge this offline but has not time to review this.",
          "createdAt": "2025-04-16T06:59:54Z",
          "updatedAt": "2025-04-16T06:59:54Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> @cabo gave his blessing to merge this offline but has not time to review this.\r\n\r\nDon't have time to review right now either, but did we came to a conclusion about the right tag order regarding table prependment?",
          "createdAt": "2025-04-16T10:26:01Z",
          "updatedAt": "2025-04-16T10:26:01Z"
        },
        {
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "body": "> did we came to a conclusion about the right tag order regarding table prependment?\r\n\r\nYes, see https://github.com/cbor-wg/cbor-dns/pull/7#discussion_r1888278854",
          "createdAt": "2025-04-16T11:22:08Z",
          "updatedAt": "2025-04-16T11:22:08Z"
        },
        {
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "body": "> Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nYes, correct. I've always phrased it as \"the inner tag prepends to the outer tag\", but that's the same statement.\r\n\r\n",
          "createdAt": "2025-04-16T11:41:07Z",
          "updatedAt": "2025-04-16T11:41:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOIM0M7M6Qe9sY",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Some content-related and several editorial suggestions and comments :)",
          "createdAt": "2024-11-08T15:00:57Z",
          "updatedAt": "2024-11-08T15:25:19Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nThis implicit (i.e. not explicitly represented) table _V_ is constructed as follows:\r\n```",
              "createdAt": "2024-11-08T15:00:58Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 151,
              "body": "```suggestion\r\nAny coherent sequence of text strings encountered within the rump of tag TBD28259, as well as any of its non-empty suffixes, are added to the table as arrays in depth-first order.\r\n```",
              "createdAt": "2024-11-08T15:05:13Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 151,
              "body": "Also, what exactly does \"coherent sequence\" mean? Is that a standing term?",
              "createdAt": "2024-11-08T15:05:57Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 159,
              "body": "I personally find it confusing that `packed=0` still means there is packing involved. Could we find a different naming?",
              "createdAt": "2024-11-08T15:09:37Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nIt provides an implicit text string suffix sequence table for shared items _V_ which is prepended to the existing table for shared items that apply to the content of tag TBD28259 (by default empty table).\r\n```\r\n?",
              "createdAt": "2024-11-08T15:10:54Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nTake the following CBOR object _o_ (note that this is intentionally not legal \"application/dns+cbor\" to illustrate generality).\r\n```\r\n\r\nor any other name, just to be able to reference it later.",
              "createdAt": "2024-11-08T15:12:35Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\n    [\"svc\", simple(0)],\r\n```\r\n\r\nis it not?",
              "createdAt": "2024-11-08T15:13:32Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\nNote that the sequence \"org\", \"example\", \"org\" is added at index 4 with leading \"org\", instead of referencing index 2 + index 1 (`simple(2), simple(1)`), as it is its own distinct suffix sequence.\r\n```",
              "createdAt": "2024-11-08T15:14:42Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 190,
              "body": "```suggestion\r\nThe packed representation of _o_ would thus be:\r\n```",
              "createdAt": "2024-11-08T15:14:51Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\nWith, e.g., table setup tag 113, further packing can be achieved via nesting table packing.\r\n```",
              "createdAt": "2024-11-08T15:16:55Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 210,
              "body": "```suggestion\r\n113(\r\n  TBD28259(\r\n```\r\n\r\notherwise prepending the table from 113 would shift the TBD28259 ones.",
              "createdAt": "2024-11-08T15:18:35Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 225,
              "body": "Could we get rid of this extra rule with by switching the tag order?",
              "createdAt": "2024-11-08T15:21:18Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 259,
              "body": "everything except `tag`, `array` and `map` wouldn't make sense, right?",
              "createdAt": "2024-11-08T15:23:11Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            },
            {
              "originalPosition": 210,
              "body": "Which clashes with the requirement that we want to elude TBD28259 for dns+cbor, hum...",
              "createdAt": "2024-11-08T15:24:53Z",
              "updatedAt": "2024-11-08T15:25:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf83K",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:30:30Z",
          "updatedAt": "2024-11-08T16:30:30Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "\u201eCBOR sequence\u201c is a standing term. Cohererent is meant wrt text strings, so a (sub) sequence that only contains text strings.",
              "createdAt": "2024-11-08T16:30:30Z",
              "updatedAt": "2024-11-08T16:30:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf9cx",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:31:40Z",
          "updatedAt": "2024-11-08T16:31:41Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "The idea is that `packed` might also provide other contexts later. Don't read it as boolean, more as, e.g., a level.",
              "createdAt": "2024-11-08T16:31:41Z",
              "updatedAt": "2024-11-08T16:31:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qf-3W",
          "commit": {
            "abbreviatedOid": "cfeb452"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T16:34:30Z",
          "updatedAt": "2024-11-08T16:40:11Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Since it is implicit, this is arbitrary. I thought it might be more helpful to the reader, if we show the full sequences here.",
              "createdAt": "2024-11-08T16:34:30Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 210,
              "body": "> otherwise prepending the table from 113 would shift the TBD28259 ones.\r\n\r\nHuh? From how I read my definition (and the definition for 113), the tables of the outer tag are prepended to the tables of the inner tag. I want the TBD28259 table _V_ to be the \u201cstart\u201d of the shared item table. \r\n\r\n",
              "createdAt": "2024-11-08T16:37:21Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 225,
              "body": "Then the indices for name compression would be larger than the 113 ones... Which would increase the risk of names having larger references (but as they are more common in DNS messages they should be smaller).",
              "createdAt": "2024-11-08T16:39:04Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            },
            {
              "originalPosition": 259,
              "body": "That would be the same for 113 or 1113. Nevertheless, they have any as data item as well.",
              "createdAt": "2024-11-08T16:39:42Z",
              "updatedAt": "2024-11-08T16:40:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgvXO",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:33:27Z",
          "updatedAt": "2024-11-08T17:33:27Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Then maybe \"any CBOR sequence consisting of only text strings\"? Maybe it's also just a personal English-word problem with \"coherent\".",
              "createdAt": "2024-11-08T17:33:27Z",
              "updatedAt": "2024-11-08T17:33:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgyJD",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:36:11Z",
          "updatedAt": "2024-11-08T17:36:11Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "At least for 113, it is definitely the other way around. I guess the rationale is that you enable shorter references within smaller contexts (inside the rump of an inner tag).",
              "createdAt": "2024-11-08T17:36:11Z",
              "updatedAt": "2024-11-08T17:36:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QgyVJ",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:36:40Z",
          "updatedAt": "2024-11-08T17:36:40Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "see above.",
              "createdAt": "2024-11-08T17:36:40Z",
              "updatedAt": "2024-11-08T17:36:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Qg023",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "mguetschow",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-08T17:41:32Z",
          "updatedAt": "2024-11-08T17:41:32Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I think this illustrates the implicit table setup algorithm better.",
              "createdAt": "2024-11-08T17:41:32Z",
              "updatedAt": "2024-11-08T17:41:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6QrMdW",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-11T13:03:39Z",
          "updatedAt": "2024-11-11T13:03:39Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Are you sure? Maybe @cabo can help to alleviate the confusion? Does the outer setup tag prepend its table(s) to the inner tag's table(s) or the inner tag to its outer tag's?",
              "createdAt": "2024-11-11T13:03:39Z",
              "updatedAt": "2024-11-11T13:03:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VJhxH",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-13T13:29:48Z",
          "updatedAt": "2024-12-13T13:29:48Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "The main argument is really composability.  A CBOR data item that uses cbor-packed should still work when it is embedded in some other table setup.",
              "createdAt": "2024-12-13T13:29:48Z",
              "updatedAt": "2024-12-13T13:29:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VJjsv",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-13T13:33:43Z",
          "updatedAt": "2024-12-13T13:33:43Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "This is a note, there is no extra rule.\r\nIf the rest of the text doesn't say that, it needs to be fixed.",
              "createdAt": "2024-12-13T13:33:43Z",
              "updatedAt": "2024-12-13T13:33:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6VhE9j",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T10:29:10Z",
          "updatedAt": "2024-12-17T10:29:10Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nE.g., taking the example\r\n\r\n```\r\n113(\r\n  TBD28259(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(5)],\r\n        [\"svc\", simple(0)],\r\n        simple(5), simple(1), simple(6),\r\n        simple(3), simple(6)\r\n      ]\r\n    ]\r\n  )\r\n)\r\n```\r\n\r\nwould still work with\r\n\r\n```\r\n  TBD28259(\r\n    [\r\n        [\"www\", \"example\", \"org\"],\r\n        [\"svc\", simple(0)],\r\n        \"org\", simple(1), 42,\r\n        simple(3), 42\r\n    ]\r\n  )\r\n```\r\n\r\nwhile the other way around \r\n\r\n```\r\nTBD28259(\r\n  113(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(5)],\r\n        [\"svc\", simple(0)],\r\n        simple(5), simple(1), simple(6),\r\n        simple(3), simple(6)\r\n      ]\r\n    ]\r\n  )\r\n)\r\n```\r\n\r\nwould completely need to rewrite the `simple(i)` references (and not just the new ones) for `113(...)` if `TBD28259(...)` is taken away to make sense.\r\n\r\n```\r\n  113(\r\n    [\r\n      [\"org\", 42],\r\n      [\r\n        [\"www\", \"example\", simple(0)],\r\n        [\"svc\", \"www\", \"example\", simple(0)],\r\n        simple(0), \"example\", simple(0), sample(1),\r\n        \"svc\", \"www\", \"example\", \"org\", sample(1)\r\n      ]\r\n    ]\r\n  )\r\n```\r\n\r\nThis makes sense to me. Will fix (and try to find a better wording to make the table setup clearer).",
              "createdAt": "2024-12-17T10:29:10Z",
              "updatedAt": "2024-12-17T10:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6Vibek",
          "commit": {
            "abbreviatedOid": "034b61a"
          },
          "author": "miri64",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T13:04:09Z",
          "updatedAt": "2024-12-17T13:04:17Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "I am not set on the term \u201clevel of packedness\u201d. In fact, I would love to get some alternative terms.",
              "createdAt": "2024-12-17T13:04:09Z",
              "updatedAt": "2024-12-17T13:04:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOIM0M7M6lPHvA",
          "commit": {
            "abbreviatedOid": "f672f80"
          },
          "author": "cabo",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-16T11:42:01Z",
          "updatedAt": "2025-04-16T11:42:01Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "> Ok, so in this case, if I understand correctly, the outer tag should append to the packing table(s) of the inner tag.\r\n\r\nThat is a funny way to say \"prepend tables built from inner tags to those inherited from an outer table building tag\", but it definitely is what has worked well so far.\r\n(An on-the-fly implementation could start at the node with the reference, go up until it finds the next table building tag, use what it finds there if the reference is covered, or subtract the size of the table from a reference index that goes beyond that table and continue upwards.)",
              "createdAt": "2025-04-16T11:42:01Z",
              "updatedAt": "2025-04-16T11:42:01Z"
            }
          ]
        }
      ]
    }
  ]
}